<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>think hy how to learn</title>
        <link>https://linjianshu.github.io/</link>
        <description>Recent content on think hy how to learn</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 28 Oct 2021 10:24:40 +0800</lastBuildDate><atom:link href="https://linjianshu.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>活连上线学习文档</title>
        <link>https://linjianshu.github.io/p/%E6%B4%BB%E8%BF%9E%E4%B8%8A%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Thu, 28 Oct 2021 10:24:40 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E6%B4%BB%E8%BF%9E%E4%B8%8A%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>维保
 优化内存占用 提高sql执行效率 索引 性能分析 慢查询日志 多线程上传数据 以后要设定阀值 上传数据总量等于5w(估算)的时候,先上传,放置因为很久没上传的数据因为累积过多,导致一次性上传50w数据裂开  image-20211117085507371</description>
        </item>
        <item>
        <title>Mysql高级</title>
        <link>https://linjianshu.github.io/p/test-chinese/</link>
        <pubDate>Tue, 12 Oct 2021 19:35:55 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/test-chinese/</guid>
        <description>&lt;img src="https://linjianshu.github.io/hutomo-abrianto-l2jk-uxb1BY-unsplash.jpg" alt="Featured image of post Mysql高级" /&gt;Mysql高级学习文档 mysql的架构介绍 mysql简介 mysqllinux版安装 mysql配置文件 mysql逻辑架构介绍 mysql存储引擎 索引优化分析 性能下降sql慢是执行时间长还是等待时间长 常见通用的join查询 索引简介 性能分析 索引优化 查询截取分析 查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志 mysql锁机制 锁的分类 主从复制 主从配置 mysql简介 高级mysql 完整的mysql优化
 mysql内核 sql优化攻城狮 mysql服务器的优化 各种参数常量设定 查询语句优化 主从复制 软硬件升级 容灾备份 sql编程  mysqllinux版的安装 image-20211012195826053
#查看当前ubuntu版本 yourtreedad@yourtreedad:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.3 LTS Release: 20.04 Codename: focal yourtreedad@yourtreedad:~$ 准备工作
#切换到root账户 yourtreedad@yourtreedad:~$ sudo passwd root New password: Retype new password: passwd: password updated successfully yourtreedad@yourtreedad:~$ su root Password: root@yourtreedad:/home/yourtreedad# #查看电脑里有没有mysql root@yourtreedad:/home/yourtreedad# service mysql status * MySQL is stopped.</description>
        </item>
        <item>
        <title>Go趣学指南</title>
        <link>https://linjianshu.github.io/p/go%E8%B6%A3%E5%AD%A6%E6%8C%87%E5%8D%97/</link>
        <pubDate>Mon, 11 Oct 2021 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/go%E8%B6%A3%E5%AD%A6%E6%8C%87%E5%8D%97/</guid>
        <description>Go趣学指南 备注:
内置函数
 len() cap() append() delete() new() copy()  本书未涉及:
 iota表示声明连续的常量 移位操作符&amp;laquo; &amp;raquo; 位运算符 &amp;amp; | 关键字continue和关键字goto和标签 遮蔽变量的具体规则 复数和虚数 裸返回(bare return) 空借口 interface{} 浅尝即止 介绍了类型断言但没有介绍类型判断 双向通道 初始化操作的init特殊函数 每个内置函数没有详细介绍,例如分配内存并返回指针的new函数和复制切片的copy函数 没有说明如何将自己的包分享给别人 git版本控制 丰富的工具和库组成的生态系统  入门 并非所有编程语言都需要编译才能运行,如python ruby和其他一些流行语言就选择了在程序运行的时候,通过解释器一条接一条地转换代码中的声明,但这也意味着bug可能会隐藏在测试尚未触及的代码当中.
解释器不仅能够让开发过程变得迅速且具有交互性,还能够让语言本身变得灵活,相反编译语言因为缓慢的编译速度常常为人诟病,但实际上并非所有的编译语言都是如此.
 go想要构造地像c++和java这类静态编译语言一样安全高效,还可以像python这类动态型解释性语言一样轻巧且充满乐趣.
 go编译器的优点 go的编译可以在极短的时间内完成,只需要一条命令,排除了可能会导致歧义的特性,为传统语言死板的数据结构提供了轻量级别的代替品.它可以在程序运行之前找出代码中一些人为失误,如拼写错误等.
go能够利用多核机器商的每个核心获得额外的性能优势.
包和函数 package关键字声明了代码所属的包,编写代码都会被组织称各式各样的包.go语言本身就提供了这些包,标准库.
import关键字导入自己将要用到的包,math包提供了sin cos tan sqrt 等等函数,fmt包则提供了用于格式化输入和输出的函数.
func关键字用于声明函数,每个函数的函数体body都要用大括号{}包围起来
main标识符具有特殊意义,从main包的main函数开始执行,如果main不存在,将报告一个错误
每次用到被导入包中的某个函数时,我们都需要在函数的名字前面加上包的名字以及一个点号座位前缀.
go语言的这一特性可以让用户在阅读代码的时候立即弄清楚各个函数分别来自哪些包.
速查  fmt包提供了格式化输入输出的功能 go程序从main包的main函数开始执行  唯一允许的大括号放置风格 go对于大括号{}的摆放位置非常挑剔.左大括号与func关键字位于同一行,而右大括号单独占一行,除此之外,其他的放置风格都是不允许的.
不需要加封号,go编译器将自动代劳,代价是遵守大括号放置风格
小结  每个go程序都有包中包含的函数组成 编程语言中的标点符号也是至关重要的 go关键字 package import func  命令式编程 被美化的计算器 执行计算 算术操作符 + - * / %</description>
        </item>
        <item>
        <title>Mysql基础</title>
        <link>https://linjianshu.github.io/p/mysql%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Sun, 10 Oct 2021 23:44:44 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/mysql%E5%9F%BA%E7%A1%80/</guid>
        <description>mysql学习文档 一 为什么要学习数据库 二 数据库的相关概念 DBMS DB SQL
三 数据库存储数据的特点 四 初始mysql mysql产品的介绍
mysql产品的安装
mysql服务的启动和停止
mysql服务的登陆和退出
mysql的常见命令和语法规范
五DQL语言的学习 基础查询
条件查询
排序查询
常见函数
分组查询
连接查询
子查询
分页查询
union联合查询
六 DML语言的学习 插入语句
修改语句
删除语句
七 DDL语言的学习 库和表的管理
常见数据类型介绍
常见约束
保存数据的容器:
数组 集合 内存数据 断电就没了
文件 但是文件不好查找
因此把文件做成方便增删改查的软件 对文件进行操作 这样的软件就叫做数据库
数据库的好处  实现数据持久化 使用完整的管理系统统一管理,易于查询  数据库的概念 DB 数据库 database:存储数据的仓库,保存了一系列有组织的数据.
DBMS 数据库管理系统 database management system 数据库是通过dbms创建和操作的容器
常见的数据库管理系统 mysql oracle db2 sqlserver
SQL 结构化查询语言 structure query language :专门用来与数据库通信的语言</description>
        </item>
        <item>
        <title>记辛亥革命110周年大会有感</title>
        <link>https://linjianshu.github.io/p/%E8%AE%B0%E8%BE%9B%E4%BA%A5%E9%9D%A9%E5%91%BD110%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E6%9C%89%E6%84%9F/</link>
        <pubDate>Sat, 09 Oct 2021 10:57:55 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E8%AE%B0%E8%BE%9B%E4%BA%A5%E9%9D%A9%E5%91%BD110%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E6%9C%89%E6%84%9F/</guid>
        <description>致中山樵 ​	我想告诉你
​	任何故土的消息
​	好也罢坏也罢
​	我想告诉你
​	碧云寺的彩塑依旧
​	钟山却已初秋
​	我想告诉你
​	故国的消息
​	风也好雨也好
​	祖国已思念她的游子多时
​	殊不知你已与这片大地相濡以沫
​	我想告诉你
​	才人的汹涌
​	如山间的松涛
​	一年胜过一年
​	我想告诉你
​	这盛世已定
​	你若在
​	太容易泪湿满襟
​	姓名:林健树
​	学院:机械工程学院
​	年级:20级033班
​	专业:工业工程与管理
​	学生类别:全日制
😜💖💕😋</description>
        </item>
        <item>
        <title>数据结构与算法学习文档</title>
        <link>https://linjianshu.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Wed, 01 Sep 2021 00:22:19 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>数据结构与算法 解决问题方法的效率，跟数据的组织方式有关。
循环和递归
解决问题方法的效率，跟空间的利用效率有关。
image-20210818161452286
image-20210818162018882
解决问题方法的效率，跟算法的巧妙程度有关
数据结构 数据对象在计算机中的组织方式
 逻辑结构：线性结构和树结构、图结构 物理存储结构：数组、链表  数据对象必定与一系列加在其上的操作相关联
完成这些操作所用的方法就是算法
抽象数据类型(Abstract Data Type)  数据类型  数据对象集 数据集合相关联的操作集   抽象：描述数据类型的方法不依赖于具体实现  与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关    只描述数据对象集和相关操作集是什么，并不涉及如何做到的问题
抽象 image-20210818163548512
算法  一个有限指令集 接收一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须  有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖与任何一种计算机语言以及具体的实现手段    image-20210818164049310
什么是好算法  空间复杂度sn  根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。
 时间复杂度Tn  根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。
递归的时候会占用内存，因为递归下一层的时候要暂存上一层的结果
Sn = C*N</description>
        </item>
        <item>
        <title>Go语言学习</title>
        <link>https://linjianshu.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Tue, 24 Aug 2021 00:17:57 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</guid>
        <description>Go语言学习 alt+enter
ctrl+space
ctrl+shift+space
ctrl+alt+L
ctrl+alt+M重构
F2查看错误
alt+6查看问题
ctrl+shift+/
alt+F8 评估表达式
ctrl+F8 切换断点
环境搭建，编译之后生成可执行exe文件，就可以直接使用了
image-20210725102106105
image-20210725102139391
编译
使用 go build
1.在项目目录下执行go build
2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）
3.go build -o hello.exe
go run
像执行脚本文件一样执行go代码
go install
分为两步：
1.先编译得到一个可执行文件
2.将可执行文件拷贝到gopath的bin目录
交叉编译，可以跨平台跑程序
例如在windows平台编译一个能在linux平台上执行的可执行文件
这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!
E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET CGO_ENABLE=0 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOOS=linux E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOARCH=amd64 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;go build image-20210725103733683
go语言的基本结构
package main //导入的包 import &amp;#34;fmt&amp;#34; //程序的入口函数 //函数外部只能放置标识符（变量、常量、函数、类型）的声明 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 变量和常量</description>
        </item>
        <item>
        <title>Docker Learning</title>
        <link>https://linjianshu.github.io/p/docker-learning/</link>
        <pubDate>Mon, 26 Jul 2021 00:23:34 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/docker-learning/</guid>
        <description>docker学习   docker概述
  docker安装
  docker命令
 镜像命令 容器命令 操作命令 &amp;hellip;    docker镜像
  容器数据卷
  dockerfile
  docker网络原理
  idea整合docker
  以上单机版本docker
 集群 docker compose docker swarm 简化版k8s ci/cd jenkins  docker概述
开发&amp;ndash;上线 两套环境 应用环境，应用配置
开发人员 运维人员
开发即运维！
环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop&amp;hellip;）费事费力
发布项目 jar（redis mysql jdk es） war
jar带上环境进行发布，项目能不能带上环境安装打包
之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台
windows与linux
传统：开发提供jar 运维部署环境
现在：开发打包部署上线，一套流程做完</description>
        </item>
        <item>
        <title>git学习文档</title>
        <link>https://linjianshu.github.io/p/git%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sat, 24 Jul 2021 16:18:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/git%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>Git学习文档 学习git之前，我们需要先明白一个概念，版本控制！
版本控制  什么是版本控制 版本迭代 版本管理器
 版本控制（revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份一遍恢复以前的版本的软件工程技术。
 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误  简单说就是用于管理多人协同开发项目的技术。
没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将引入很多问题，如关键代码的冗余，软件过程的事物性，软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。
多人开发就必须要使用版本控制，否则代价比较大
 常见的版本控制工具
 主流的版本控制器有如下这些：
 Git SVN(subversion) CVS(concurrent versions system) VSS(Microsoft Visual SourceSafe) TFS(team Foundation Server) Visual Studio Online  版本控制产品非常的多（preforce 、 rational clearcase 、 rcs 、serena dimention 、 svk 、bitkeeper、 monotone 、 bazaar 、 mercurial 、 sourcegear vault），现在影响力最大且使用最广泛的是git和svn
 版本控制分类
   本地版本控制
记录文件每次的更新，可以对每个版本做一个快照，或者记录补丁文件，适合个人用，如RCS
image-20210722211743148</description>
        </item>
        <item>
        <title>CSharpLinux环境部署学习文档</title>
        <link>https://linjianshu.github.io/p/csharplinux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Wed, 16 Jun 2021 00:25:03 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/csharplinux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>Linux学习 如果是阿里云记得配置安全组!!!
css js 静态文件都在wwwroot中,所以如果后台启动或者使用mvcTest.dll 的话会无法找到静态文件 因为静态文件的层级在她们上面一层 , 所以要cp一份wwwroot到存放dll那一层中 , 这样就可以看到样式了!!!
windows倾向于GUI操作，windows下的命令到了linux下不一定能用
windows有扩展名，linux中可以没有扩展名
windows不区分大小写，linux区分大小写
linux不同版本使用方法配置文件变化很大，要反复查找和调试
linux内核和发行版
linux内核是由linus及开源社区维护，内核包含内存管理、存储管理、进程管理、网络通讯等基础模块。很多公司、开元组织基于linux内核打包出很多发行版，不同的发行版的内核版本可能不一致，包含的软件也不一致，界面差别较大，但是命令行操作时互通的，大部分程序也是互通的。
内核和发行版的关系就像android内核和小米手机系统、华为手机系统的关系一样。常用的发行版有redhat、centos、debian、ubuntu等等。这里我们用ubuntu，因为其内置的软件最适合程序员，其他发行版要自己装。
linux常见命令
windows有多根目录
linux是单根
常用目录
boot 存放用于系统引导时的各种文件
bin 存放二进制可执行文件 例如ls，cat，mkdir等等
sbin 存放二进制可执行文件，只有root用户才能访问
usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录
opt 额外安装的可选应用程序包所放置的位置
dev用于存放设备文件
etc存放系统配置文件
home存放所有用户文件的根目录
lib存放跟文件系统中的程序运行所需要的共享库及内核模块
tmp 用于存放各种临时文件
var 用于存放运行时需要改变数据的文件
mnt 安装临时文件系统的安装点
常见命令
pwd 显示当前工作目录 print working directory
ls 目录
cd 更改目录 cd .. 返回上级目录 cd / 返回根目录 cd 文件夹 进入文件夹
mkdir 创建目录
rmdir 目录名 删除非空目录
rm-r 目录名 删除目录及其下目录与文件（递归删除）</description>
        </item>
        <item>
        <title>微信小程序学习文档</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Tue, 01 Jun 2021 00:27:43 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>小程序组件
view标签 类比p便签
text标签 类比span标签
selecttable :文档是否可选
image-20210404164128223
decode标签 :选中＆ｎｂｓｐ；/lt/gt/amp.apos/ensp/emsp这样的可以识别出来
button标签:
​	type: primary / default / warn
image-20210404164342281
​	form-type=&amp;ldquo;submit&amp;rdquo;/reset
​	open-type getuserinfo/getphonenumber/contact
image-20210404164741208
checkbox image-20210404165141036
开闭标签,可以在开闭标签内写上复选文字内容
value可以填入真实的值
checkboxgroup
radio单选按钮
开闭标签 , value可以填入真实的值 , 实现单选需要配合实现radiogroup
image-20210404165511648
block标签
​	标签块 , 其本身不会被渲染到页面中 , 只有内部的标签会被渲染进html页面
image-20210404170226484
image-20210404171030254
绑定事件+编写js方法
image-20210404183815644
image-20210404183822112
data的数据绑定以及数据更新
image-20210404185119026</description>
        </item>
        <item>
        <title>计算机组成原理学习文档</title>
        <link>https://linjianshu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 14 May 2021 00:26:49 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>计算机组成原理学习文档 CPU
内存
硬盘
主板
计算机硬件识别数据
高低电平0/1
通过电信号传递数据
金属针脚：传递电信号用的通道
通过很多条电路，可以传递多个二进制数位，每个二进制数位称为1bit比特
文字、数字、图像如何用二进制表示
如何存储二进制数
CPU如何对二进制数字进行加减乘除
如何从内存中取出想要的数据
CPU如何识别和执行我们写的程序
计算机系统 = 硬件 + 软件
硬件是计算机的实体，软件由具有各类特殊功能的程序组成
计算机性能的好坏取决于软硬件功能的总和
软件
  系统软件：用来管理整个计算机系统
 操作系统、DBMS、标准程序库、网络软件、语言处理程序、服务程序    应用软件
 按照任务需要编制成的各种程序    硬件的发展
第一台电子数字计算机 ENIAC1946 冯诺依曼
逻辑元件：电子管
第一代：电子管时代 纸带机编程
第二代：晶体管 开始出现操作系统 开始出现高级语言
第三代：中小规模集成电路 高级语言迅速发展 开始出现分时操作系统
第四代：大规模、超大规模集成电路 出现微处理器、微型计算机、个人计算机PC萌芽 、 操作系统
微处理器的发展：
机器字长：计算机一次整数运算所能处理的二进制位数
摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月就会增加一倍，整体性能也将提升一倍
软件的发展：
机器语言010101=&amp;gt;汇编语言=&amp;gt;FORTRAN/PASCAL/C++=&amp;gt;java、python
DOC操作系统=&amp;gt;windows、android、ios
目前的发展趋势：
两极分化：
1.微型计算机更微型化、网络化、高性能、多用途方向发展
2.巨型化、超高速、并行处理、智能化方向发展
计算机硬件的基本组成：
1.早期冯诺依曼的结构
2.现代计算机的结构
ENIAC手动接线来控制计算
冯诺依曼：”存储程序“的概念是指将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
早期冯诺依曼机：</description>
        </item>
        <item>
        <title>Blazor学习文档</title>
        <link>https://linjianshu.github.io/p/blazor%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sat, 24 Apr 2021 00:27:56 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/blazor%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>Blazor学习文档 调用webapi
 httpclient ihttpclientfactory  数据绑定
  单项绑定
  双向绑定
  &amp;lt;input @bind = &amp;#34;CurrentValue&amp;#34; /&amp;gt; &amp;lt;input @bind = &amp;#34;CurrentValue&amp;#34; @bind:event = &amp;#34;oninput&amp;#34;     &amp;lt;h1&amp;gt;单向绑定&amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;@Apsdetail.ProductBornCode&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;@Apsdetail.ProcedureCode&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;@Apsdetail.ProductBornCode&amp;lt;/h3&amp;gt; &amp;lt;h3&amp;gt;@Apsdetail.ProcedureCode&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;h1&amp;gt;双向绑定&amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;产品出生证&amp;lt;/h3&amp;gt; &amp;lt;input @bind=&amp;#34;@Apsdetail.ProductBornCode&amp;#34; /&amp;gt; &amp;lt;h3&amp;gt;工序编号&amp;lt;/h3&amp;gt; &amp;lt;input @bind=&amp;#34;@Apsdetail.ProcedureCode&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;h2&amp;gt;不同的触发event:&amp;lt;/h2&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;产品出生证&amp;lt;/h3&amp;gt; &amp;lt;input @bind=&amp;#34;@Apsdetail.ProductBornCode&amp;#34; @bind:event=&amp;#34;oninput&amp;#34;/&amp;gt; &amp;lt;h3&amp;gt;工序编号&amp;lt;/h3&amp;gt; &amp;lt;input @bind=&amp;#34;@Apsdetail.ProcedureCode&amp;#34; @bind:event=&amp;#34;oninput&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;button @onclick=&amp;#34;@button_click&amp;#34;&amp;gt;click&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; EditForm</description>
        </item>
        <item>
        <title>ApsDotnetCoreMVC学习文档</title>
        <link>https://linjianshu.github.io/p/apsdotnetcoremvc%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 16 Apr 2021 00:28:25 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/apsdotnetcoremvc%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>asp .net core mvc 学习文档 控制器向界面传值 通过viewbag/viewdata 来进行弱传递
controller中:
image-20210421230444662
index中:
image-20210421230455113
通过model进行强类型传递
controller中:
image-20210421230520009
index中:
@model IEnumerable&amp;lt;webmvcdemo.Models.Movie&amp;gt; &amp;lt;form asp-controller=&amp;#34;Movies&amp;#34; asp-action=&amp;#34;Index&amp;#34; &amp;gt; &amp;lt;p&amp;gt; &amp;lt;select name=&amp;#34;prop&amp;#34; required=&amp;#34;&amp;#34;&amp;gt; @foreach (var item in typeof(Movie).GetProperties()) { &amp;lt;option value=@item.Name&amp;gt;@item.Name&amp;lt;/option&amp;gt; } &amp;lt;/select&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;SerachString&amp;#34;/&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34;&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; 界面向控制器传参 通过name来准确传递
index:
&amp;lt;select name=&amp;#34;prop&amp;#34; required=&amp;#34;&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;SerachString&amp;#34;/&amp;gt; 控制器中:
image-20210421230911623
通过定位点标记帮助程序
https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/tag-helpers/built-in/anchor-tag-helper?view=aspnetcore-5.0#asp-route-value
Razor语法 使用@符号将c#转化为html代码提供展示 显式/隐式razor表达式 razor代码块 ​	Razor 代码块以开头 @ ，并由括起来 {} 。 代码块内的 C# 代码不会呈现，这点与表达式不同。 一个视图中的代码块和表达式共享相同的作用域并按顺序进行定义</description>
        </item>
        <item>
        <title>真会CSharp吗学习文档</title>
        <link>https://linjianshu.github.io/p/%E7%9C%9F%E4%BC%9Acsharp%E5%90%97%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sat, 30 Jan 2021 00:17:57 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E7%9C%9F%E4%BC%9Acsharp%E5%90%97%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>C#5.0+学习文档 特点：
 通用性语言 类型安全 面向对象  目标：生产力
 简洁性 表达力 高性能  平台中立，与平台无关
封装、继承、多态
统一的类型系统：
 类型 共同的基类  类和接口
 class interface  属性property、方法method和事件event
  唯一一种函数成员(Function Member):方法(method)
  方法还包括：属性(Property)和事件(Event)还有其他的
  属性
  事件
  C#主要是一种面向对象的语言，但是也借用了不少函数式编程的特性
  函数可以当做值来对待
 委托Delegate    支持纯(purity)模式
 避免使用值可变的变量    类型安全
 c#主要来说是类型安全的 静态类型 static typing 动态类型 dynamic 强类型 strongly typed language  内存管理</description>
        </item>
        <item>
        <title>RabbitMQ学习文档</title>
        <link>https://linjianshu.github.io/p/rabbitmq%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Tue, 01 Dec 2020 00:29:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/rabbitmq%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>RabbiMQ学习文档 rabbitMQ是遵循amqp协议的一个erlang实现。
amqp协议：高级消息队列协议
http协议：request、response
telnet协议：经常用来查看某一台ip上的指定端口是否是ping通的【远程登陆协议】
AMQP 0-9-1 complete Reference Guide rabbitmq 实现的amqp协议的版本号
 connection =&amp;gt;open , use , close [open-ok , close , une-ok] channel =&amp;gt;open, flow , close , [构建在connection之上，在amqp中常作为长连接] exchange =&amp;gt; queue basic =&amp;gt;发布和获取 message中的一些设置 tx =&amp;gt;事务处理 confirm =&amp;gt;发布确认机制  详细设计书一样
image-20201026164558077
image-20201026164701153
延时处理，拉长时间
以更长的时间来换取堆积的业务逻辑
异步处理：响应很快，增加服务器承载能力
流量削峰：
扩展性：UI和业务的解耦，可以独立演化
高可用：处理器发生故障以后，不会影响可用性
缺陷：
即时性降低，降低了用户体验&amp;mdash;无法避免；业务上来屈服；
复杂性提高
vhost：避免命名冲突
exchange：
 direct headers topic fanout  image-20201026211929666
在windows上是一个服务</description>
        </item>
        <item>
        <title>微服务2020.11.17微服务划分原则</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.17%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86%E5%8E%9F%E5%88%99/</link>
        <pubDate>Tue, 17 Nov 2020 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.17%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86%E5%8E%9F%E5%88%99/</guid>
        <description>2020.11.17微服务划分原则   独立运行、独立部署和持续交付  应该通过功能来划分微服务：微服务应该彼此独立，如果不能交付独立的应用程序功能块，那么划分只能增加复杂性。 划分微服务的目标应该是每个微服务可以单独的运行，单独的测试，不依赖其他的微服务，以便在大型项目开发中达到持续交付的目的，否则拆分微服务就失去意义了。 例如：子若姐的设备点检模块部分的微服务，划分为点检项配置和点检计划自动制定两个微服务，两个微服务可以单独的运行，只要无参调用或者给参数调用就能跑。    每个微服务对应一个数据库（也可以没有数据库）  每个微服务有自己的数据库，并与其他微服务完全解耦。 为每个微服务分配数据库，保证该微服务对其下数据库的支配权，数据库中的表应该包括微服务用到的所有表结构和实体，并且在其他微服务出现次数尽可能少（可以出现，如此就需要用MQTT或Rabbitmq保证数据的最终一致性）。 例如：点检项配置微服务有4个表，点检计划自动指定微服务有4个表，有一个表相同，但另外的表只有对应微服务在使用，其他微服务无法干涉。    微服务划分粒度  没有标准定义，个人认为：1.可以按照数据库的独立性来划分微服务（即：被剥离出来的a数据库，理论上只有A微服务可以调用，其他微服务不行）2.可以按照实现的功能层面来划分微服务（根据简单的CRUD构成了一个复杂/简单的功能，即：点检项的配置和点检计划的制定）3.在满足以上的情况下，不建议划分过小的微服务，例如简单的C、R、U、D划分为四个，那么在微服务调用时就会因为进程间调用造成极大的通信成本，另外微服务的搭建也十分繁琐，这是不合适的）    关于DDD原则划分微服务  书中建议我们，并不是所有的微服务都需要使用DDD原则来划分和构建。**每个微服务可以基于不同设计模式具有不同内部架构。并非所有微服务都应使用先进的DDD模式来实现，因为这可能导致过度设计。对于简单的CRUD维护应用程序，设计和实现DDD模式可能没什么意义。但对于核心领域或核心业务，可能需要应用更先进的模式来应对业务规则不断变化的业务复杂性。**我们不可能用“一种架构模式来解决所有问题”。根据优先级，必须为每个微服务选择不同方法。  image-20201116221753802
 个人理解：我们使用的ABP四层框架实际上就是按照DDD原则进行CRUD和构建复杂功能的框架。  image-20201117160828300
 在拆分的过程中，我们还应该考虑，是否有一些被拆分出去的微服务，它用不上DDD，诸如简单的CRUD，以及不涉及聚合数据、提取表中特定数据的Dto构造，我们就可以使用简单的单层或其他形式来进行该微服务的构建，以达到最适合该微服务搭建的目的。    低耦合  重点是构建低耦合的微服务，如果我们发现A微服务在运行的过程中会频繁的调用B微服务，那么我们可能会考虑将A微服务和B微服务进行组合。以解耦提高内聚，降低通信成本，降低出现故障的可能。 微服务间的交互越少越好，核心规则是微服务间的交互需要异步    </description>
        </item>
        <item>
        <title>微服务2020.11.16</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.16/</link>
        <pubDate>Mon, 16 Nov 2020 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.16/</guid>
        <description>2020.11.16微服务继续学习 Docker数据卷技术 数据卷是指从主机操作系统映射到容器的目录。当容器中的代码访问这些目录时，实际上是在访问主机操作系统中的文件夹。这些目录并没有绑定到容器本身的生命周期中，它们能被直接运行在主机操作系统中的代码访问，或被其他同样映射了该目录的容器访问。因此，数据卷按照设计可独立于容器生命周期来实现数据的持久存储。如果从docker主机删除容器或镜像，数据卷中的数据并不会被删除，其中的数据依然能从主机操作系统访问。
微服务架构 每个微服务负责实现一个特定的端到端领域，或有着确定边界的业务逻辑，并且每个微服务必须能独立开发和部署。每个微服务应该拥有自己特定的领域数据模型和领域逻辑（自治和去中心化的数据管理），它们是基于不同数据存储技术（SQL、NoSQL）和不同编程语言实现的。
重点是要创建低耦合的服务，只要它们之间没有太多直接依赖，就应该使它们尽可能地小。
微服务架构提供了长期的敏捷性，微服务可以基于多个独立部署的服务来创建应用。
微服务另一个优势在于能够独立地进行横向扩展。而不是一起将本不需要扩展的其他功能区域也进行扩展。难点：如何在多个层级设计并实现安全性：认证、授权、密文密码管理和安全通信等。
微服务的数据自治 A与B子系统都会调用C实体的属性和数据，而它们是隶属于不同上下文边界的。这样的原则在DDD里也是类似的，每个限界上下文、自治的子系统或服务必须拥有自己的领域模型（数据+逻辑+行为）。
中心化数据库：同一张地图满足徒步旅行、长途汽车旅行和学习地理知识的需求；都支持ACID原则和SQL语言。
当业务流程跨越多个微服务时，最终一致性是唯一的办法，这比写一个简单的SQl连接要复杂的多，同理，很多其他关系型数据库功能也不支持跨微服务使用。
基于微服务的应用通常会混合使用SQL和NoSQL数据库，这种做法有时会被称为混合数据持久化。
微服务和限界上下文模式的关系 每个BC必须有自己的模型和数据库。
逻辑架构和物理架构 确定了业务微服务或限界上下文，但不意味这最佳实现方式就是为每个业务微服务创建单独的服务（例如作为一个ASP.NET Web API）或单独的Docker容器。
业务微服务或限界上下文必须自主地进行代码和状态的独立版本控制、部署和扩展。
分布式数据管理的挑战和解决方案 定义微服务边界： 关注应用的逻辑领域模型和相关数据
创建从多个微服务获取数据的查询： 需要一种方式来聚合信息；
API网关、CQRS查询/读取表：此时复杂的查询将变成巨大的挑战，为此可以使用CQRS方案：在不同数据库中创建一个只用作查询的非规范表，这种方式不仅解决了最初的问题（如何跨微服务查询和联接），与复杂的SQL联接语句相比还能进一步提升性能，因为应用所需的数据已经在查询表里了；
中心数据库的“冷数据”：将“热数据”导出为“冷数据”储存到报表专用的大型数据库中。为了同步数据，可以采用事件驱动通信，如果使用事件驱动通信的方式，整合流程将与上文提到的使用CQRS查询表获取数据的方式相似。
然而，在设计上需要不断从多个微服务里进行聚合数据并进行复杂查询，那么通常在遇到此类问题后，我们也许会考虑合并微服务。
在多个微服务之间实现一致性 使用基于异步通信，如集成事件（消息和基于事件的通信）的最终一致性。根据CAP理论，我们需要在可用性和强ACID一致性之间做出选。大多数微服务场景要求高可用性和高扩展性，而非强一致性。开发人员可以使用弱一致性或最终一致性的技术来做到强一致性。这也是大多数基于微服务的架构所采取的方法。
此外，ACID风格或两步式提交事务违背了微服务原则，跨服务和数据库维护数据的一致性非常重要。需要在微服务之间使用事件驱动通信和发布订阅系统来实现最终一致性。
在多个微服务之间通信 在多个微服务间创建了长串的同步HTTP调用，应用最终将会碰到问题：阻塞和性能低下。
因为这可能会产生一种争议：这实际上是一种单体式应用，它的进程间是基于HTTP的，而没有使用进程内通信机制。
为了促进微服务的自治并获得更高的弹性，应该减少使用跨服务的链式请求/响应通信。建议微服务间的通信只使用异步交互，例如使用基于消息或时间的异步通信。
识别微服务的领域模型边界 虽然微服务应该尽可能地趋向于小型化，但识别每个微服务的模型边界不是为了尽可能拆成细粒度，而是根据领域知识来进行最有意义的划分。重点不在于大小，而在于业务需要。另外，如果因为存在庞大复杂的依赖关系而要求应用的某个领域有清晰的一致性的需求，这也就表明该领域应该是一个独立的微服务。
因此，BC会帮助澄清哪里需要特定的领域术语，以及哪里需要把系统拆分成额外的不同领域BC。
然而也有些具有不同形态但却共用相同标识的实体，它们存在于多个微服务所包含的多个领域模型中。例如会议管理微服务中有一个用户实体，该实体所对应的同一个用户，在订单微服务里被称为买家，在支付微服务里名为付款方，而在客户服务微服务里称作客户。这是因为基于每个领域专家使用的通用语言，会对同一个用户有不同视角，甚至包含不同属性。会议管理微服务里的用户实体应该包含最多的个人数据属性，但是同一个用户在支付微服务里的买家标识和客户服务里的客户标识就不需要那么多属性了。
每个领域模型里的用户实体可能有不同的补充细节。因此需要某种方式把一个领域的用户实体映射到另一个领域中。
客户端微服务直连和API网关模式 直连有弊端：如何处理跨界限问题，例如授权、数据传输和动态请求派发：为每个微服务实现安全和界限问题，例如安全性和授权机制，一种可能的方法是把这些服务放进Docker主机或内部集群中，再通过一个中间位置，例如API网关来解决跨界限问题。
有时要从响应中去掉移动端不需要的数据，还要压缩数据，所以这样的场景下，在移动端和微服务之间使用外观模式或API就变得很方便了。
使用API网关：
我们可以使用单一的自定义API网关服务来面对多个不同客户端应用，但这会造成巨大的风险，因为API网关服务会随着客户端应用需求的变化而增长并演化，最终它会因为需求的变化而变得臃肿，在效果上将会等同于单体应用或服务。因此我们极力推荐将API网关拆分成多个服务或者小型的API网关，每个API网关都有自己的形式。
我们应该创建多个API网关，以便为每种客户端需求实现不同外观，略有差异的API，甚至可能基于客户端展现形式或设备来实现特定的适配代码，这些代码在底层调用多个内部的微服务。
通常来说，使用一个API网关将应用中所有内部微服务聚合在一起，这种做法并不明智。因此，API网关应该基于业务边界来拆分，而不是作为整个应用的一个聚合器。
在这单独的一层中，我们也可以过滤内部微服务的API，或者在已发布的API上添加授权。
网关模式的不足之处：如果API网关包含自定义逻辑和数据集成，就会要求额外的开发成本和未来的维护成本。如果API网关只使用了安全性、日志管理和版本管理功能，这些额外的开发工作便不会发生。
微服务之间的通信 通信类型 客户端代码或消息发送者通常不需要等待响应，只要把消息发送给RabbitMQ队列或其他消息代理即可。
例如事件驱动架构里的发布/订阅机制。
异步整合方式增强微服务自治 微服务间的交互越少越好，核心规则是微服务间的交互需要异步，微服务间通过异步传输来通信，但不要依赖于其他内部微服务作为自己HTTP请求/响应的一部分。
每个微服务应以自治以及对客户端可用为目标，即使作为端到端应用一部分的其他服务发生故障或不稳定也应如此。如果需要从一个微服务调用其他微服务（如发起HTTP请求来查询数据）为客户端应用提供响应结果，那么这样的架构在其它微服务发生故障时就变得不稳定。
如果最初的微服务需要原本在别的微服务里拥有的数据，不要依靠同步请求来获取数据。而是通过最终一致性（通常通过集成事件）方式来复制或传输这些数据到最初的微服务的数据库中。
为了获得最终一致性，可以使用任何协议在微服务之间异步地通信来获取数据。重点在于：不要在微服务间创建同步依赖。
异步消息通信 跨越多个微服务以及相关领域模型传送变化时，使用异步消息和事件驱动的通信至关重要。一种解决方案是基于异步消息传递和事件驱动的最终一致性。
尽可能遵循另一个规则：只在内部服务间使用异步消息传递，只在从客户端应用到前端服务（API网关
加上第一级微服务）间使用同步通信。
多接受者消息通信
使用发布/订阅机制；异步事件驱动通信；
创建、改进和控制微服务API的版本和契约 即便初始版本的契约已经考虑的很周全了，随着时间发展，服务的API也可能需要改变。如果发生了变化，尤其是被多个客户端应用调用的公共API，通常无法强制所有客户端升级到新的API契约。通常这需要增量部署服务的新版本，同时也要让老版本和新版本服务契约同时运行。因此，服务的版本策略很重要。
有时我们需要对服务API进行不兼容的大版本更新。因为不能强制客户端应用或服务立刻升级到新版，服务端必须支持老版本继续运行一段时间。如果使用基于HTTP的机制，一种方式是把API的版本号嵌入URL或HTTP头部。然后可以决定是在一个服务里同时实现两个版本的API，或是部署不同的服务来各自处理一个版本的API。此时一种较好的方法是采用中介者模式如MediaR库将不同版本的实现用不同的处理器来处理。Hypermedia是用来进行服务版本化和改进的最佳选择。
微服务的可发现性和服务注册 使用Marathon和Kubernetes和DC/Os处理服务实例的注册和撤销。另一个例子是Service Fabric，它也提供了开箱机用的命名服务来实现服务注册。</description>
        </item>
        <item>
        <title>微服务2020.11.13</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.13/</link>
        <pubDate>Fri, 13 Nov 2020 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A12020.11.13/</guid>
        <description>本周工作情况： 1.Dapper学习及使用（完成） 2.MQTT学习及使用（完成） 3.Dapper&amp;amp;MQTT保证数据一致性Demo（批量增、删、改）（完成） 4.跨服务事务一致性学习（saga)（未完成） 计划下阶段任务： 1.了解oes各个模块业务逻辑，上层：王锐师兄，下层：丽俊师兄，App：子若姐，重点了解流程，不慌搭建微服务 2.继续学习微服务划分原则和示例，根据领域驱动设计（DDD）及师兄师姐的理解划分各模块构建微服务蓝图 3.了解数据池化技术，斟酌数据库选用 Dapper入门及使用 ORM（对象关系映射）轻量级框架：数据库持久化技术，池化技术 EF框架加载树： image-20201113095855356
Dapper加载树： image-20201113092949378
MQTT学习及使用 image-20201113094906752
MQTT&amp;amp;Dapper保证跨数据库的数据一致性 image-20201113091711501
使用EMQ可视化界面作为代理来管理mqTT的客户端及主题、订阅、发布 image-20201113090134383
批量增加 image-20201113090214669
image-20201113090255394
批量修改 image-20201113090947812
image-20201113090956564
image-20201113091105493
批量删除 image-20201113091511010
image-20201113091524415
image-20201113091600481</description>
        </item>
        <item>
        <title>微服务架构学习文档</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 23 Oct 2020 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>微服务架构学习文档 Netflix流媒体播放平台微服务架构：
img
oes目前设想：
image-20201013172440573
image-20201012210849046
微服务架构特性：  单一职责 轻量级通信（通过http、rpc协议下的xml、json格式，无关语言、平台） 独立开发、测试、部署（并行工程）  preview
分布式&amp;ndash;集群&amp;ndash;微服务 分布式：不同服务器部署不同业务（应用）
集群：不同服务器部署同一套业务（应用）
微服务：同一台服务器可能部署多个微应用
preview
问题：  单体应用  优点：便于开发、测试、部署
缺点：维护成本高、交付周期长、扩展性差
 作业平台、移动端、系统平台有功能相同或者重复的代码，相同业务逻辑的代码，修改维护很不方便 数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。 单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。 加入数据分析、深度学习等相关功能后出现性能瓶颈，影响了其他应用。 数据库表结构被多个应用依赖，无法重构和优化。 所有应用都在一个数据库上操作，数据库出现性能瓶颈。 开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。 团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。  紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策。在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。
要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以致于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……
整理了业务逻辑，抽象出公用的业务能力，做成几个公共服务
各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：
img
数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：
  数据库逐渐成为了性能瓶颈
  可能会有一个服务从数据库中读取另一个服务的现象发生
  数据库表结构可能被多个服务依赖，导致很难调整
持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：
img
  数据分析和深度学习可以做数据库持久化层，一些常用的访问可以做memcache缓存机制，大文件非结构化文本可以采用nosql非关系型数据库，例如mongodb、redis
 还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。 数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。</description>
        </item>
        <item>
        <title>微服务架构设计模式学习文档</title>
        <link>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Tue, 13 Oct 2020 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>微服务架构设计模式学习文档 微服务不在于“微”，而在于单一职责。
——引自《微服务架构与实践》王磊 特点：  单一职责 轻量通信（无关平台语言、通过轻量级通信机制互联）  image-20201019111933340
采用xml或json格式达到通用，可以基于http协议或rpc协议达到服务间的轻量级通信
 业务独立（开发、测试、部署）  image-20201019112313900
 进程隔离  image-20201019162622677
 持续交付 技术的可扩展性（接口不依赖于特定语言和平台）  劣势：  网络通信：进程内调用比进程间调用用时短，分布式调用严重依赖网络可靠性与稳定性。 自动化测试条件严苛（测试难度大）  image-20201019161945662
 分区数据库架构（需要使用基于最终一致性的方法） 跨越多服务变更（服务之间可能有依赖关系）  难点：  性能（跨进程、跨网络、跨数据库）：考虑通信成本、网络延迟、带宽、多服务交互的响应时间 可靠性：服务数量节点增多可能带来潜在故障点，防止单点故障 异步：同步通信造成阻塞，异步通信缺增加功能实现的复杂度，出现故障时的链路追踪、定位、调试有难度。  image-20201019164512498
 数据一致性：保持数据一致性需要使用saga或者什么cqrs视图查询什么的 联表查询：  尝试使用微服务架构改造遗留系统： 改造策略/原则：
 最小修改（停止挖掘）  image-20201019165725693
 功能剥离  image-20201019165818362
 数据解耦  image-20201019171523179</description>
        </item>
        <item>
        <title>Redis学习文档</title>
        <link>https://linjianshu.github.io/p/redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
        <pubDate>Sat, 19 Sep 2020 00:33:33 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
        <description>Redis学习文档 nosql讲解
阿里巴巴架构演进
nosql数据模型
nosql四大分类
cap
base
redis入门
redis安装
五大基本数据类型
string
list
set
hash
zset
三种特殊数据类型
geo
hyperloglog
bitmap
Redis配置详解
redis持久化
rdb
aof
redis事务操作
redis实现订阅发布
redis主从复制
redis哨兵模式
缓存穿透及解决方案
缓存击穿及解决方案
缓存雪崩及解决方案
基础api之jedis详解
springboot继承redis操作
redis的实践分析
nosql概述
大数据时代，一般的数据库无法进行分析处理了！
springboot+springcloud
1.单机mysql年代
app=&amp;gt;dal=&amp;gt;mysql
90年代静态网页html 服务器没有太大的压力
1.数据量如果太大，一台机器放不下了
2.数据的索引 300万条就一定要建立索引，那么一个机器的内存放不下
3.访问量，读写混合，一个服务器受不了
2.Memcached（缓存）mysql+垂直拆分（读写分离）
网站80%都在读，如果每次去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力，我们可以使用缓存来保证效率
image-20200923185840123
发展过程：优化数据结构和索引===&amp;gt;文件缓存（IO）===&amp;gt;memchched(当时最热门的技术)===&amp;gt;
3.分库分表+水平拆分+mysql集群
image-20200923190414174
本质：数据库（读写）
早些年mysiam：表锁（影响效率），高并发下出现严重的锁问题
早些年innodb：行锁，慢慢的就开始使用分库分表来解决写的压力！mysql在那个年代推出了表分区，这个并没有多少公司使用！
mysql的集群，很好的满足了那个年代的所有需求！
4.如今最近的年代
技术爆炸：
2000-2010：十年间，变化太快了（热榜、音乐）
mysql等关系型数据库就不够用了！数据量很多，变化很快！
mysql有的使用它来存储一些比较大的文件、播客、图片！数据库表很大，效率就很低了
如果有一种数据库来专门处理这种数据，mysql的压力就会变得十分小，（研究如何处理这些问题）大数据的io压力下，表几乎没法更改，
 目前一个基本互联网项目！
 image-20200923191743309</description>
        </item>
        <item>
        <title>从零搭建微服务框架嗷</title>
        <link>https://linjianshu.github.io/p/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%97%B7/</link>
        <pubDate>Sun, 10 Oct 1999 23:44:44 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%97%B7/</guid>
        <description>从零搭建微服务框架嗷 新建webapi项目
image-20201026181939602
新建student控制器，测试运行
image-20201026182245668
image-20201026182254921
添加新项目控制台应用程序，加入model类
image-20201026182407678
image-20201026182436593
image-20201026182536295
删除program.cs文件，右键属性，修改输出类型为“类库”
image-20201026182552213
继续新建项目，interface，作为服务的接口
image-20201026183008099
删除program.cs文件，继续修改属性为类库
定义完了接口，接下来应该定义实现接口的具体服务了，新建控制台应用程序
编写DBhelper类，原生连接数据库
添加StudentService实现类，继承IStudentService，实现它未实现的方法
image-20201026183509062image-20201026183523894
依然重复上述步骤，右键属性，修改输出类型为类库
测试，以上依然是个单体结构，只不过分层了，现在我们搭了基层结构如图：
image-20201026183657453
分别为，webapi，接口，模型层，接口实现类
接下来修改webapi内student控制层里的方法，尝试调用通过接口调用服务，进而获取数据库中的数据
修改前：
image-20201026183803906
修改后：
先在startup.cs中进行服务类的依赖注入
image-20201026184259317
在这里，我们对controller进行重新构造：
定义一个私有只读IStudentService接口 ；
在构造函数里为它赋值
在GetAllStu方法里进行调用
image-20201026184627518
启动试试，输入url
image-20201026184827682
不错不错
接下来我们要添加服务实例，将原来的单体应用程序，模拟拆分成分布式应用程序
新建项目，新建webapi</description>
        </item>
        <item>
        <title>windows服务开发备忘</title>
        <link>https://linjianshu.github.io/p/windows%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98/</link>
        <pubDate>Fri, 01 Oct 1999 09:17:59 +0800</pubDate>
        
        <guid>https://linjianshu.github.io/p/windows%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98/</guid>
        <description>windows服务开发备忘 先开个窗体来调试试试看
再新增一个service服务进来
修改默认服务名
添加安装程序 修改为本地
image-20210928105412125
记得引入日志 并将config文件复制到输出目录
有时候install.bat命令不行可能是系统没有权限
跑服务的时候记得再program里改成服务,别泡成窗体应用了
服务的onstart里需要写的是异步方法或者新开一个线程,否则会出现无法服务进程无法连接到服务控制器上的错误
image-20210928105853916
image-20210928105911601
接口服务嘛,最好尝试ping一下服务器,服务器畅通才能工作
另外最好对间隔时间做到可配置</description>
        </item>
        
    </channel>
</rss>
