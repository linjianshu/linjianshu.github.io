<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Go语言学习 alt&#43;enter
ctrl&#43;space
ctrl&#43;shift&#43;space
ctrl&#43;alt&#43;L
ctrl&#43;alt&#43;M重构
F2查看错误
alt&#43;6查看问题
ctrl&#43;shift&#43;/
alt&#43;F8 评估表达式
ctrl&#43;F8 切换断点
环境搭建，编译之后生成可执行exe文件，就可以直接使用了
image-20210725102106105
image-20210725102139391
编译
使用 go build
1.在项目目录下执行go build
2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）
3.go build -o hello.exe
go run
像执行脚本文件一样执行go代码
go install
分为两步：
1.先编译得到一个可执行文件
2.将可执行文件拷贝到gopath的bin目录
交叉编译，可以跨平台跑程序
例如在windows平台编译一个能在linux平台上执行的可执行文件
这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!
E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET CGO_ENABLE=0 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOOS=linux E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOARCH=amd64 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;go build image-20210725103733683
go语言的基本结构
package main //导入的包 import &amp;#34;fmt&amp;#34; //程序的入口函数 //函数外部只能放置标识符（变量、常量、函数、类型）的声明 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 变量和常量'><title>GoLearning</title>

<link rel='canonical' href='https://linjianshu.github.io/p/golearning/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='GoLearning'>
<meta property='og:description' content='Go语言学习 alt&#43;enter
ctrl&#43;space
ctrl&#43;shift&#43;space
ctrl&#43;alt&#43;L
ctrl&#43;alt&#43;M重构
F2查看错误
alt&#43;6查看问题
ctrl&#43;shift&#43;/
alt&#43;F8 评估表达式
ctrl&#43;F8 切换断点
环境搭建，编译之后生成可执行exe文件，就可以直接使用了
image-20210725102106105
image-20210725102139391
编译
使用 go build
1.在项目目录下执行go build
2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）
3.go build -o hello.exe
go run
像执行脚本文件一样执行go代码
go install
分为两步：
1.先编译得到一个可执行文件
2.将可执行文件拷贝到gopath的bin目录
交叉编译，可以跨平台跑程序
例如在windows平台编译一个能在linux平台上执行的可执行文件
这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!
E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET CGO_ENABLE=0 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOOS=linux E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOARCH=amd64 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;go build image-20210725103733683
go语言的基本结构
package main //导入的包 import &amp;#34;fmt&amp;#34; //程序的入口函数 //函数外部只能放置标识符（变量、常量、函数、类型）的声明 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 变量和常量'>
<meta property='og:url' content='https://linjianshu.github.io/p/golearning/'>
<meta property='og:site_name' content='think hy how to learn'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2021-09-01T00:17:57&#43;08:00'/><meta property='article:modified_time' content='2021-09-01T00:17:57&#43;08:00'/><meta property='og:image' content='https://linjianshu.github.io/' />
<meta name="twitter:site" content="@ljs56495989">
    <meta name="twitter:creator" content="@ljs56495989"><meta name="twitter:title" content="GoLearning">
<meta name="twitter:description" content="Go语言学习 alt&#43;enter
ctrl&#43;space
ctrl&#43;shift&#43;space
ctrl&#43;alt&#43;L
ctrl&#43;alt&#43;M重构
F2查看错误
alt&#43;6查看问题
ctrl&#43;shift&#43;/
alt&#43;F8 评估表达式
ctrl&#43;F8 切换断点
环境搭建，编译之后生成可执行exe文件，就可以直接使用了
image-20210725102106105
image-20210725102139391
编译
使用 go build
1.在项目目录下执行go build
2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）
3.go build -o hello.exe
go run
像执行脚本文件一样执行go代码
go install
分为两步：
1.先编译得到一个可执行文件
2.将可执行文件拷贝到gopath的bin目录
交叉编译，可以跨平台跑程序
例如在windows平台编译一个能在linux平台上执行的可执行文件
这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!
E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET CGO_ENABLE=0 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOOS=linux E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;SET GOARCH=amd64 E:\project\GOproject\code.oldboyedu.com\day1&amp;gt;go build image-20210725103733683
go语言的基本结构
package main //导入的包 import &amp;#34;fmt&amp;#34; //程序的入口函数 //函数外部只能放置标识符（变量、常量、函数、类型）的声明 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 变量和常量"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://linjianshu.github.io/' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://linjianshu.github.io/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="/p/golearning/">GoLearning</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 01, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 51 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h3 id="go语言学习">Go语言学习</h3>
<p>alt+enter</p>
<p>ctrl+space</p>
<p>ctrl+shift+space</p>
<p>ctrl+alt+L</p>
<p>ctrl+alt+M重构</p>
<p>F2查看错误</p>
<p>alt+6查看问题</p>
<p>ctrl+shift+/</p>
<p>alt+F8 评估表达式</p>
<p>ctrl+F8 切换断点</p>
<p>环境搭建，编译之后生成可执行exe文件，就可以直接使用了</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210725102106105.png" >
		<img src="/GoLearning.assets/image-20210725102106105.png"
			
			
			
			loading="lazy"
			alt="image-20210725102106105">
	</a>
	
	<figcaption>image-20210725102106105</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210725102139391.png" >
		<img src="/GoLearning.assets/image-20210725102139391.png"
			
			
			
			loading="lazy"
			alt="image-20210725102139391">
	</a>
	
	<figcaption>image-20210725102139391</figcaption>
	
</figure></p>
<p>编译</p>
<p>使用 go build</p>
<p>1.在项目目录下执行go build</p>
<p>2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）</p>
<p>3.go build -o hello.exe</p>
<p>go run</p>
<p>像执行脚本文件一样执行go代码</p>
<p>go install</p>
<p>分为两步：</p>
<p>1.先编译得到一个可执行文件</p>
<p>2.将可执行文件拷贝到gopath的bin目录</p>
<p>交叉编译，可以跨平台跑程序</p>
<p>例如在windows平台编译一个能在linux平台上执行的可执行文件</p>
<p><strong>这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">E:<span class="se">\p</span>roject<span class="se">\G</span>Oproject<span class="se">\c</span>ode.oldboyedu.com<span class="se">\d</span>ay1&gt;SET <span class="nv">CGO_ENABLE</span><span class="o">=</span><span class="m">0</span>

E:<span class="se">\p</span>roject<span class="se">\G</span>Oproject<span class="se">\c</span>ode.oldboyedu.com<span class="se">\d</span>ay1&gt;SET <span class="nv">GOOS</span><span class="o">=</span>linux

E:<span class="se">\p</span>roject<span class="se">\G</span>Oproject<span class="se">\c</span>ode.oldboyedu.com<span class="se">\d</span>ay1&gt;SET <span class="nv">GOARCH</span><span class="o">=</span>amd64

E:<span class="se">\p</span>roject<span class="se">\G</span>Oproject<span class="se">\c</span>ode.oldboyedu.com<span class="se">\d</span>ay1&gt;go build


</code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210725103733683.png" >
		<img src="/GoLearning.assets/image-20210725103733683.png"
			
			
			
			loading="lazy"
			alt="image-20210725103733683">
	</a>
	
	<figcaption>image-20210725103733683</figcaption>
	
</figure></p>
<p>go语言的基本结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">//导入的包
</span><span class="c1"></span><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//程序的入口函数
</span><span class="c1">//函数外部只能放置标识符（变量、常量、函数、类型）的声明
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>变量和常量</p>
<p>go语言中的变量必须先声明后使用</p>
<p>var s1 string :声明一个保存字符串数据的变量</p>
<p>var name string</p>
<p>var age int</p>
<p>var isOk bool</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">age</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">isOk</span> <span class="kt">bool</span>

<span class="c1">//批量声明
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">name1</span> <span class="kt">string</span>
	<span class="nx">age1</span> <span class="kt">int</span>
	<span class="nx">isOk1</span> <span class="kt">bool</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">age1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">isOk1</span><span class="p">)</span>

	<span class="nx">name1</span> <span class="p">=</span> <span class="s">&#34;linjianshu&#34;</span>
	<span class="nx">age1</span> <span class="p">=</span> <span class="mi">16</span>
	<span class="nx">isOk1</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">//go语言中推荐使用驼峰命名
</span><span class="c1"></span>	<span class="c1">//go语言中非全局变量声明必须使用，不用就编译不过去
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">age1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">isOk1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name:%s&#34;</span><span class="p">,</span><span class="nx">name1</span><span class="p">)</span>  <span class="c1">//%s占位符，使用name1这个变量去替换这个占位符
</span><span class="c1"></span>
	<span class="c1">//声明变量同时赋值
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">studentName</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;ljs&#34;</span>
	<span class="c1">//类型推导
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">studentName1</span>  <span class="p">=</span> <span class="s">&#34;ljs&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">studentName</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">studentName1</span><span class="p">)</span>
	<span class="c1">//简短变量声明 :=  只能在函数里面使用
</span><span class="c1"></span>	<span class="nx">studentName2</span> <span class="o">:=</span> <span class="s">&#34;jwt&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">studentName2</span><span class="p">)</span>

	<span class="nx">x</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span><span class="nf">foo</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

	<span class="nx">x1</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">x1</span><span class="p">,</span><span class="nx">_</span> <span class="p">=</span><span class="nf">foo</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x1</span><span class="p">)</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">10</span><span class="p">,</span><span class="s">&#34;ljs&#34;</span>
<span class="p">}</span>
</code></pre></div><p>匿名变量 用_来接收，表示我不用这个变量，匿名变量不占用命名空间，不会分配内存，所以匿名变量不存在重复声明</p>
<p>注意：1.函数外的每个语句都必须以关键字开始2.同一个作用域{}中不能重复声明同名的变量</p>
<p>常量</p>
<p>iota</p>
<p>ioto是go语言的常量计数器，只能在常量表达式中使用</p>
<p>iota在const关键字出现的时候被重置为0. const中每新增一行常量声明将使iota计数一次iota可理解为const语句块中的行索引 使用iota能简化定义，在定义枚举时很有用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//常量
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.1415926</span>
<span class="c1">//常量定义了之后不能修改
</span><span class="c1">//在程序运行期间不会改变
</span><span class="c1"></span>
<span class="c1">//批量声明常量时，如果某一行没有赋值，默认就和上一行一致
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">pi1</span> <span class="p">=</span> <span class="nx">pi</span>
	<span class="nx">pi2</span>
	<span class="nx">pi3</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">i1</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i2</span>
	<span class="nx">i3</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">n1</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">n2</span>
	<span class="nx">_</span>
	<span class="nx">n3</span>
<span class="p">)</span>

<span class="c1">//插队
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">k1</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">k2</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">k3</span>
	<span class="nx">k4</span> <span class="p">=</span><span class="kc">iota</span>
	<span class="nx">k5</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">p1</span><span class="p">,</span><span class="nx">p2</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="kc">iota</span><span class="o">+</span><span class="mi">2</span>
	<span class="nx">p3</span><span class="p">,</span><span class="nx">p4</span> <span class="p">=</span> <span class="kc">iota</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="kc">iota</span><span class="o">+</span><span class="mi">2</span>
<span class="p">)</span>

<span class="c1">//定义数量级
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">KB</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
	<span class="nx">MB</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
	<span class="nx">GB</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
	<span class="nx">TB</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 不可以 pi = 12.3
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pi2:&#34;</span><span class="p">,</span><span class="nx">pi2</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;i1:&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;i2:&#34;</span><span class="p">,</span><span class="nx">i2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;i3:&#34;</span><span class="p">,</span><span class="nx">i3</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;n1:&#34;</span><span class="p">,</span><span class="nx">n1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;n2:&#34;</span><span class="p">,</span><span class="nx">n2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;n3:&#34;</span><span class="p">,</span><span class="nx">n3</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;k1:&#34;</span><span class="p">,</span><span class="nx">k1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;k2:&#34;</span><span class="p">,</span><span class="nx">k2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;k3:&#34;</span><span class="p">,</span><span class="nx">k3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;k4:&#34;</span><span class="p">,</span><span class="nx">k4</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;k5:&#34;</span><span class="p">,</span><span class="nx">k5</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;p1:&#34;</span><span class="p">,</span><span class="nx">p1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;p2:&#34;</span><span class="p">,</span><span class="nx">p2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;p3:&#34;</span><span class="p">,</span><span class="nx">p3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;p4:&#34;</span><span class="p">,</span><span class="nx">p4</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;kb:&#34;</span><span class="p">,</span><span class="nx">KB</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;mb:&#34;</span><span class="p">,</span><span class="nx">MB</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;gb:&#34;</span><span class="p">,</span><span class="nx">GB</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;tb:&#34;</span><span class="p">,</span><span class="nx">TB</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>关键字和标识符</p>
<p>go语言有25个关键字</p>
<p>break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var</p>
<p>基本数据类型</p>
<p>整型</p>
<p>整型分为以下两大类：按长度分为：int8 , int16 , int32 ,int64 对应的无符号整型：uint8 , uint16 ,uint32</p>
<p>其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型</p>
<p>特殊整型</p>
<p>uint根据电脑位数来搞</p>
<p>int根据电脑位数来搞</p>
<p>uintptr无符号整数，用于存放一个指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	 <span class="nx">i1</span>  <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%o\n&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>   <span class="c1">//把十进制转成8进制
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%b\n&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>   <span class="c1">//把十进制转成2进制
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x\n&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>   <span class="c1">//把十进制转成16进制
</span><span class="c1"></span>
	 <span class="c1">//八进制
</span><span class="c1"></span>	 <span class="nx">i2</span> <span class="o">:=</span> <span class="mo">077</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span><span class="nx">i2</span><span class="p">)</span>
	 <span class="c1">//十六进制
</span><span class="c1"></span>	 <span class="nx">i3</span><span class="o">:=</span> <span class="mh">0x123</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span><span class="nx">i3</span><span class="p">)</span>

	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span><span class="nx">i1</span><span class="p">)</span>

	 <span class="c1">//声明一个int8类型的 要明确指定类型，都则就是int类型
</span><span class="c1"></span>	 <span class="nx">i4</span><span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>浮点型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//float
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//maxFloat32 := math.MaxFloat32 最大值
</span><span class="c1"></span>	<span class="nx">f1</span><span class="o">:=</span><span class="mf">1.23</span>
	<span class="c1">//默认go语言中的小数都是float64类型
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span><span class="nx">f1</span><span class="p">)</span>

	<span class="c1">//显式声明float32类型
</span><span class="c1"></span>	<span class="nx">f2</span><span class="o">:=</span><span class="nb">float32</span><span class="p">(</span><span class="mf">1.23</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span><span class="nx">f2</span><span class="p">)</span>

	<span class="nx">f1</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">f2</span><span class="p">)</span> <span class="c1">//不能隐式转换
</span><span class="c1"></span>
<span class="p">}</span>
</code></pre></div><p>布尔值</p>
<p>go语言中以bool类型进行声明，只有true和false</p>
<p>注意：</p>
<ol>
<li>布尔类型变量默认为false</li>
<li>go语言中不允许将整型强制转换为布尔型</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//布尔值
</span><span class="c1"></span>	<span class="nx">b</span><span class="o">:=</span><span class="kc">true</span>
	<span class="kd">var</span> <span class="nx">b1</span> <span class="kt">bool</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span><span class="nx">b1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Type:%T,Value:%v&#34;</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>复习</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//fmt占位符 %s %d %x %o %b %T %v
</span><span class="c1"></span>
	<span class="nx">i</span> <span class="o">:=</span><span class="mi">2</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%b\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%o\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x\t&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>

	<span class="nx">s</span><span class="o">:=</span><span class="s">&#34;linjianshu&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\t&#34;</span><span class="p">,</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\t&#34;</span><span class="p">,</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\t&#34;</span><span class="p">,</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="字符串">字符串</h3>
<p>go语言中字符串是用双引号包裹的！</p>
<p>go语言中单引号包裹的是字符！！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//字符串s:=&#34;hello ljs&#34;//单独的字母、汉字、符号表示一个字符c1 := &#39;h&#39;c2 := &#39;1&#39;c3 := &#39;啥&#39;//字节：1字节=8Bit（8个二进制位）//一个字符 &#39;A&#39; = 1个字节//一个utf8编码的汉字‘啥’ = 一般占3个字节
</span></code></pre></div><p>字符串转义符</p>
<p>Go语言的字符串常见转义符包含回车、换行、单双引号、制表符等</p>
<p>\r \n \t ' \&quot;  \\</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//fmt占位符 %s %d %x %o %b %T %v	i :=2	fmt.Printf(&#34;%T\t&#34;,i)	fmt.Printf(&#34;%v\t&#34;,i)	fmt.Printf(&#34;%b\t&#34;,i)	fmt.Printf(&#34;%d\t&#34;,i)	fmt.Printf(&#34;%o\t&#34;,i)	fmt.Printf(&#34;%x\t&#34;,i)	s:=&#34;linjianshu&#34;	fmt.Printf(&#34;%s\t&#34;,s)	fmt.Printf(&#34;%v\t&#34;,s)	fmt.Printf(&#34;%#v\t&#34;,s)}
</span></code></pre></div><p>多行字符串</p>
<p>go语言中要定义一个多行字符串时，就必须使用反引号 字符``</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span><span class="o">:=</span> <span class="s">`	a	b	c`</span>
</code></pre></div><p>字符串的常用操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="nx">求长度</span><span class="o">+</span><span class="nx">或者fmt</span><span class="p">.</span><span class="nx">Strintf</span>  <span class="nx">拼接字符串strings</span><span class="p">.</span><span class="nx">Split</span>  <span class="nx">分割strings</span><span class="p">.</span><span class="nx">contains</span>  <span class="nx">判断是否包含strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">HasSuffx</span>  <span class="nx">前缀</span><span class="err">、</span><span class="nx">后缀判断strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(),</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">LastIndex</span>  <span class="nx">子串出现的位置strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">a</span><span class="p">[]</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span>  <span class="nx">join操作</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="nx">fmt</span> <span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;strings&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">path</span> <span class="o">:=</span> <span class="s">&#34;\&#34;C:\\Users\\Sweetie\\Desktop\\车间级MES\&#34;&#34;</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\t&#34;</span> <span class="p">,</span> <span class="nx">path</span><span class="p">)</span>	<span class="nx">s</span> <span class="o">:=</span> <span class="s">`	世情薄	人情恶	雨送黄昏花易落`</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\r&#34;</span><span class="p">,</span><span class="nx">s</span><span class="p">)</span>	<span class="nx">s3</span><span class="o">:=</span><span class="s">`C:\Users\Sweetie\Desktop\车间级MES`</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span><span class="nx">s3</span><span class="p">)</span>	<span class="c1">//字符串相关操作	fmt.Printf(&#34;%d\n&#34;,len(s3))	//字符串拼接	name := &#34;ljs&#34;	world := &#34;shuaibi&#34;	describtion := name+world	fmt.Printf(&#34;%v\n&#34;,describtion)	describtion1 := fmt.Sprintf(&#34;%s%s&#34;,name,world)	fmt.Printf(&#34;%s\n&#34;,describtion1)	//分割	s1 := strings.Split(s3,&#34;\\&#34;)	fmt.Println(s1)	for i := 0; i &lt; len(s1); i++ {		fmt.Println(s1[i])	}	//包含	fmt.Println(strings.Contains(describtion, name))	fmt.Printf(&#34; &#39;%s&#39; Contains &#39;%s&#39; ? result:%v&#34;,describtion1,name,strings.Contains(describtion, name))	fmt.Println()	//前缀、后缀	fmt.Println(strings.HasPrefix(describtion, &#34;ljs&#34;))	fmt.Println(strings.HasSuffix(describtion, &#34;shuaibi&#34;))	//索引 查找	s4:=&#34;abcdeb&#34;	fmt.Println(strings.Index(s4,&#34;b&#34;))	fmt.Println(strings.LastIndex(s4,&#34;b&#34;))	//拼接	var sJoin = strings.Join(s1,&#34;+&#34;)	fmt.Println(sJoin)}
</span></code></pre></div><p>byte和rune类型</p>
<p>组成每个字符串的元素叫做‘字符’，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号‘ 包裹起来，如：</p>
<p>var a:=&lsquo;中&rsquo;</p>
<p>var b:=&lsquo;x&rsquo;</p>
<p>Go语言的字符有以下两种：</p>
<p>1.uint8类型，或者叫byte型，代表了ascii码的一个字符</p>
<p>2.rune类型，代表一个utf-8字符</p>
<p>当需要处理中文、日文或者其他符合字符时，则需要用到rune类型。rune类型实际是一个int32</p>
<p>Go使用了特殊的rune类型来处理unicode，让基于unicode的文本处理更方便，也可以使用byte型进行默认字符串处理，性能和扩展性都有照顾</p>
<p>因为utf8编码下一个中文汉字由3-4个字节组成，所有我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中的第一行结果</p>
<p>字符串底层是一个byte数据，所以可以和[]byte 类型相互转换，字符串是不能修改的 字符是由byte字节组成，所以字符串的长度是byte字节的长度 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成</p>
<p>修改字符串</p>
<p>要修改字符串，需要先将其转换成[]rune或 []byte ，完成后再转换为string ，都会重新分配内存，并复制字节数组</p>
<p>注:rune是一个别名 实际上是类型int32 所以 &lsquo;中&rsquo;的类型是int32</p>
<p>byte是一个别名 实际上是类型uint8 所以&rsquo;c&rsquo;的类型是uint8</p>
<p>类型转换</p>
<p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<p>T(表达式)</p>
<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p>
<p>比如计算直角三角形的斜边长使用math包的sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型，这个时候就将a和b强制类型转换为float64类型</p>
<p>总结：</p>
<p>go语言的基本类型： int8 int16 int32 int64 uint8 uint16 uint32 uint64 float32 float64 bool string</p>
<p>if语句</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;strings&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//if 条件判断	age:=19	if age&gt;18 {		fmt.Println(&#34;性感荷官在线发牌&#34;)	}else {		fmt.Println(&#34;好好学习，以后赌博&#34;)	}	if age &gt;= 35 &amp;&amp; age &lt; 80 {		fmt.Println(&#34;人到中年，不得不服&#34;)	}else if age &gt; 18 {		fmt.Println(&#34;年轻力壮，不怕困难&#34;)	}else {		fmt.Println(&#34;好好学习，少吃点苦&#34;)	}	if name := &#34;linjianshu&#34;; strings.Contains(name, &#34;lin&#34;) {	fmt.Println(&#34;确实确实&#34;)}else {	fmt.Println(&#34;不敢不敢&#34;)	}	}
</span></code></pre></div><p>for range(键值循环)</p>
<p>go语言中可以使用for range 遍历数据、切片、字符串、map及通道channel 通过for range 遍历返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值</li>
<li>map返回键和值</li>
<li>通道channel 只返回通道内的值</li>
</ol>
<h3 id="内容回顾">内容回顾</h3>
<p>go安装</p>
<p>gopath</p>
<p>go env</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210726100638960.png" >
		<img src="/GoLearning.assets/image-20210726100638960.png"
			
			
			
			loading="lazy"
			alt="image-20210726100638960">
	</a>
	
	<figcaption>image-20210726100638960</figcaption>
	
</figure></p>
<p>gopath/bin 添加到环境变量：go install 命名会把生成的二进制可执行文件拷贝到gopath/bin</p>
<h4 id="go-命令">go 命令</h4>
<p>go build 编译go程序</p>
<p>go build -o &ldquo;xxx.exe&rdquo; 指定名称</p>
<p>go run main.go 像执行脚本一样执行mai.go</p>
<p>go install 先编译后拷贝</p>
<h5 id="go语言文件基础语法">go语言文件基础语法</h5>
<p>存放go源代码的文件后缀名 .go</p>
<p>文件第一行：package main 声明包名</p>
<p>如果要编译可执行文件，必须要有main包和main函数（入口函数）</p>
<p>单行注释和多行注释</p>
<p>go语言函数外的语句必须以关键字开头</p>
<p>函数内部定义的变量必须使用</p>
<h5 id="变量">变量</h5>
<p>3种声明方式：</p>
<ol>
<li>var name string</li>
<li>name:=&ldquo;ljs&rdquo;</li>
<li>var name = &ldquo;ljs&rdquo; 函数内部专属</li>
</ol>
<p>匿名变量（哑元变量）</p>
<p>当有些数据必须用变量接收但是又不使用它时，就可以用<code>_</code> 来接收这个值</p>
<h5 id="常量">常量</h5>
<p><code>const</code> PI = 3.1415926</p>
<p><code>const</code> UserNotExistErr  = 1000</p>
<p><code>iota</code> 实现枚举 实际上就是行索引</p>
<p>三个要点：</p>
<ul>
<li>const关键字出现时重置为0</li>
<li>每新增一行常量声明，iota累加1</li>
</ul>
<h5 id="流程控制">流程控制</h5>
<p>if</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">条件</span> <span class="p">{</span>    <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">条件</span><span class="p">{</span>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>    <span class="p">}</span>
</code></pre></div><p>for循环</p>
<ol>
<li>标准for循环</li>
<li>变种没有i初始</li>
<li>变种没有i限定</li>
<li>变种没有i增量</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>	<span class="p">}</span>	<span class="nx">i</span><span class="o">:=</span><span class="mi">5</span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span><span class="mi">10</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>	<span class="p">}</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>	<span class="kd">var</span> <span class="nx">i1</span> <span class="p">=</span> <span class="mi">3</span>	<span class="k">for</span> <span class="nx">i1</span><span class="p">&lt;</span><span class="mi">10</span>  <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i1</span><span class="p">)</span>		<span class="nx">i1</span><span class="o">++</span>	<span class="p">}</span>	<span class="k">for</span>	<span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>		<span class="k">break</span>	<span class="p">}</span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&#34;hello world&#34;</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;index:%d\t,value:%c\n&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>	<span class="p">}</span>	<span class="nx">s</span><span class="o">:=</span><span class="s">&#34;hello world&#34;</span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;index:%d\t,value:%c\n&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>	<span class="p">}</span>	<span class="c1">//哑元变量，不想用到的都直接给_	for _, v := range s {		fmt.Printf(&#34;%c\n&#34;,v)	}	for i := 1; i &lt;10 ; i++ {		for j := 1; j &lt;=10-i ; j++ {			fmt.Printf(&#34;%d x %d = %d\t&#34; , i , j , i*j)		}		fmt.Println()	}	for i := 1; i &lt; 10; i++ {		for j := i; j &gt;0; j-- {			fmt.Printf(&#34;%d x %d = %d\t&#34; , i,j,i*j)		}		fmt.Println()	}
</span></code></pre></div><h3 id="基本数据类型">基本数据类型</h3>
<p>整型</p>
<p>​	无符号整型：<code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code></p>
<p>​	有符号整型：<code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code></p>
<p>​	<code>uint</code> <code>int</code> 具体是32位还是64位看操作系统</p>
<p>​	<code>uintptr</code> 表示指针</p>
<p>其他进制数</p>
<p>go语言中没办法直接定义二进制数</p>
<p>八进制数 %o</p>
<p>二进制数 %b</p>
<p>十六进制数 %x</p>
<p>浮点型 <code>float32</code> <code>float64</code> 默认64位，转成32需要强制转换</p>
<p>布尔型 true&amp;false 不能和其他的类型做转换</p>
<p>字符串型</p>
<p>常用方法</p>
<p>字符串不能修改</p>
<p>复数</p>
<p>complex128和complex64</p>
<p>byte和rune类型</p>
<p>是类型别名</p>
<h5 id="字符串字符字节都是什么">字符串、字符、字节都是什么</h5>
<p>字符串：双引号包裹的是字符串</p>
<p>字符：单引号包裹的是字符，单个字母、日文、韩文、中文、单个符号</p>
<p>字节： 1byte = 8bit</p>
<p>go语言中字符串都是UTF8编码，UTF8编码中一个常用汉字一般占用3个字节</p>
<h5 id="switch-表达式">switch 表达式</h5>
<p>switch还可以使用表达式，这时候switch语句后买呢不需要再跟判断变量。例如</p>
<p><code>fallthrough</code> 语法可以执行满足条件的case的下一个case，是为了兼容c语言中的case设计的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">score</span><span class="o">:=</span><span class="mi">68</span>	<span class="k">switch</span> <span class="nx">score</span> <span class="p">{</span>	<span class="k">case</span> <span class="mi">68</span><span class="p">:</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;及格&#34;</span><span class="p">)</span>	<span class="k">default</span><span class="p">:</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;未知&#34;</span><span class="p">)</span>	<span class="p">}</span>	<span class="c1">//简化代码 作用域问题	switch  i:=3 ;i{	case 1:		fmt.Println(&#34;wumingzhi&#34;)	case 2:		fmt.Println(&#34;zhongzhi&#34;)	case 3:		fmt.Println(&#34;damuzhi&#34;)	}	//同时声明几种情况	switch i:=10;i{	case 1, 3, 5, 7, 9:		fmt.Println(&#34;this is 奇数&#34;)	case 2, 4, 6, 8, 10:		fmt.Println(&#34;this is 偶数&#34;)	}	score1:=68	switch  {	case score1&gt;60&amp;&amp;score1&lt;=100:		fmt.Println(&#34;及格&#34;)	case score1&lt;60:		fmt.Println(&#34;挂了呀&#34;)	}}
</span></code></pre></div><h5 id="goto表达式">goto表达式</h5>
<p>break只能退出当前for语句的循环</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">flag</span><span class="o">:=</span><span class="kc">false</span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>			<span class="k">if</span> <span class="nx">j</span><span class="o">==</span><span class="mi">2</span> <span class="p">{</span>				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>				<span class="k">break</span>			<span class="p">}</span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d-%d\n&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">)</span>		<span class="p">}</span>		<span class="k">if</span> <span class="nx">flag</span> <span class="p">{</span>			<span class="k">break</span>		<span class="p">}</span>	<span class="p">}</span>	<span class="c1">//for i := 0; i &lt; 10; i++ {	//	for j := 0; j &lt; 10; j++ {	//		if j == 2 {	//			goto breakTag	//		}	//		fmt.Printf(&#34;%v-%v\n&#34;,i,j)	//	}	//}	//return	//breakTag:	//	fmt.Println(&#34;结束for循环&#34;)}
</span></code></pre></div><h5 id="运算符">运算符</h5>
<p>go语言内置的运算符有：</p>
<ol>
<li>算术运算符+ - * / %</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h5 id="关系运算符">关系运算符</h5>
<p>==、！= 、&gt; 、 &gt;= 、&lt; 、 &lt;=</p>
<h5 id="逻辑运算符">逻辑运算符</h5>
<p>&amp;&amp; || !</p>
<h5 id="位运算">位运算</h5>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<p>&amp; 参与运算的两数各对应的二进制位相与</p>
<p>| 参与运算的两位各对应的二进制位相或</p>
<p>^ 参与运算的两数各对应的二进制位相异或，当两对应的二进制位相异时，结果为1</p>
<p>&laquo; 左移n位就是乘以2的n次方  高位丢弃，低位补0</p>
<p>》》右移n位就是除以2的n次方 a&raquo;b就是a右移b位</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//运算符	var(		a=5		b=2	)	//算术运算符	fmt.Println(a+b)	fmt.Println(a-b)	fmt.Println(a*b)	fmt.Println(a/b)	fmt.Println(a%b)	a++ //单独的语句，不能放在=的右边赋值	b++	//关系运算符	fmt.Println(a==b) //go语言是强类型，相同类型的变量才能比较	fmt.Println(a!=b)	fmt.Println(a&gt;b)	fmt.Println(a&lt;b)	age:=22	if age &gt; 18 &amp;&amp; age &lt; 60 {		fmt.Println(&#34;上班族&#34;)	}else {		fmt.Println(&#34;不用上班&#34;)	}	if age &gt; 60 || age &lt; 18 {		fmt.Println(&#34;不用上班&#34;)	}else  {		fmt.Println(&#34;上班族&#34;)	}	//not取反	b2:=true	fmt.Println(!b2)	//位运算：针对的是二进制数	//5的二进制表示 101	//2的二进制表示 010	//按位与	fmt.Println(101&amp;010)	fmt.Println(5&amp;2)	//按位或	fmt.Println(101|10)	fmt.Println(5|2)	//^按位异或	fmt.Println(101^010)  //这个有点奇怪 这个是109答案？？？	fmt.Println(5^2)	//左移右移运算 *2 和 \2	fmt.Println(5&lt;&lt;2)  //101=&gt;10100	fmt.Println(1&lt;&lt;10)	fmt.Println(5&gt;&gt;1) //101=&gt;10	//注意别溢出了	m:=int8(1)	fmt.Println(m&lt;&lt;10)	fmt.Println(1&lt;&lt;2+1)	//192.168.1.1	//权限 文件操作会将位运算实际的应用	//0644	//赋值运算符，用来给变量赋值的	var x int	x = 10	fmt.Println(x)	x+=1	fmt.Println(x)	x-=1	fmt.Println(x)	x*=2	fmt.Println(x)	x/=2	fmt.Println(x)	x&lt;&lt;=2	fmt.Println(x)	x&gt;&gt;=2	fmt.Println(x)	fmt.Printf(&#34;%b&#34;,x)	fmt.Println()	x&amp;=2	fmt.Println(x)	fmt.Printf(&#34;%b&#34;,x)	x|=2	x&lt;&lt;=2	x&gt;&gt;=2	x^=2}
</span></code></pre></div><h5 id="数组">数组</h5>
<p>array数组</p>
<p>数组是同一种数据类型元素的集合。在go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。基本语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//数组	//存放元素的容器	//必须指定存放的元素的类型和容量（长度）	//数组的长度是数组类型的一部分 也就是尽管类型一致但是长度不一致也不是同一个数组类型	var a1 [3]bool	var a2 [4]bool	fmt.Printf(&#34;a1:type%T, a2:type%T&#34;,a1,a2)	fmt.Println()	//数组的初始化	//如果不初始化：默认元素都是零值(布尔值就是false，整型和浮点型都是0，字符串就是“”)	fmt.Println(a1,a2)	//1.初始化方式1	b1 :=[3]bool{true,true,true}	fmt.Println(b1)	//2.初始化方式2 根据初始值自动推断数组的长度是多少	b2 :=[...]int{1,3,4,2,6,2,73,12}	fmt.Println(b2)	fmt.Println(len(b2))	//3.初始化方式3 根据索引初始化	b3:=[5]int{1,2}	fmt.Println(b3)	b3=[5]int{0:1,4:2}	fmt.Println(b3)	//数组的遍历	citys :=[...]string{&#34;北京&#34;,&#34;上海&#34;,&#34;深圳&#34;}	//1.for range	for _, v := range citys {		fmt.Println(v)	}	for i, _ := range citys {		fmt.Println(citys[i])	}	//2.根据索引遍历	for i := 0; i &lt; len(citys); i++ {		fmt.Println(citys[i])	}	//多维数组	c1:=[3][2]int{0:[2]int{2,3},1:[2]int{4,5}}	fmt.Println(c1)	c2:=[3][2]int {{1,2},{3,4}}	fmt.Println(c2)	//多维数组的遍历	//var b11:=[2][3]string{{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;},{&#34;d&#34;,&#34;e&#34;,&#34;f&#34;}}	//可以这么记 go语言中 实际数组展示使用空格来区分的，但是声明的时候需要用逗号隔开	for _, v := range c1 {		fmt.Println(v)		for _, v1 := range v {			fmt.Printf(&#34;%d &#34;,v1)		}		fmt.Println()	}	for i := 0; i &lt; len(c2); i++ {		fmt.Println(c2[i])		for j := 0; j &lt; len(c2[j]); j++ {			fmt.Printf(&#34;%d &#34;,c2[i][j])		}		fmt.Println()	}	//数组是值类型	d1:=[...]int{1,2,3}	d2:=d1	d2[0]=100	fmt.Println(d1)	fmt.Println(d2)	//练习	e:=[...]int{1,3,5,7,8}	sum:=0	for _, v := range e {		sum+=v	}	fmt.Println(sum)	for i, _ := range e {		for j := i+1; j &lt; len(e); j++ {			if e[i]+e[j] == 8 {				fmt.Printf(&#34;(%d %d)&#34;,i,j)				break			}		}		fmt.Println()	}}
</span></code></pre></div><p>数组定义 var 数组变量名 [元素数量]T</p>
<p>[5]int 和 [10]int 是不同的类型</p>
<h5 id="切片">切片</h5>
<p>切片slice是一个拥有相同类型元素的可变长度的序列。他是基于数组类型做的一层封装。他非常灵活，支持自动扩容。切片是一个引用类型，他的内部结构包含<code>地址</code> 、 <code>长度</code> 和 <code>容量</code> 。切片一般用于快速地操作一块数据集合。</p>
<p>切片的定义</p>
<p>声明切片类型的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">name</span> <span class="p">[]</span><span class="nx">T</span> 
</code></pre></div><p>其中，name是变量名字， T是元素类型</p>
<h5 id="切片的容量和长度">切片的容量和长度</h5>
<p>切片拥有自己的长度和容量，我们可以通过使用内置的len函数求长度，使用内置的cap函数求切片的容量</p>
<h5 id="基于数组定义切片">基于数组定义切片</h5>
<p>由于切片的底层就是一个数组，所以我们可以基于数组定义切片</p>
<p>还支持如下方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//切片的定义	var s1 []int //定义一个存放int类型元素的切片	var s2 []string	fmt.Println(s1,s2)	fmt.Println(s1==nil)	fmt.Println(s2==nil)	//初始化	s1 = []int{1,2,3}	s2 = []string{&#34;沙河&#34;,&#34;张江&#34;,&#34;平山村&#34;}	fmt.Println(s1,s2)	fmt.Println(s1==nil)	fmt.Println(s2==nil)	//长度和容量	fmt.Printf(&#34;len:%d,cap:%d\n&#34;, len(s1), cap(s1))	fmt.Printf(&#34;len:%d,cap:%d\n&#34;, len(s2), cap(s2))	//2.由数组定义切片	a :=[]int{1,3,5,7,9,11,13}	fmt.Println(cap(a))	b :=a[1:4]  //[3 5 7] 左闭右开 基于一个数组进行切割	fmt.Println(b)	b1 :=a[:4]  //0-4	fmt.Println(b1)	b2 :=a[2:]  //	fmt.Println(b2)	b3 :=a[:]	fmt.Println(b3)	//切片的长度就是元素的个数，切片的容量就是底层数组从切片第一个元素到最后一个元素的数量	fmt.Println(len(b),cap(b))	//3.切片再切片	b4:=b[1:2] //[5 7] 但是b的容量已经是6了 这时候切的b从第一位切起 那么容量应该是5	fmt.Println(b4, len(b4), cap(b4))	fmt.Println(b)	a[2] = 10	//这里说明了切片是引用类型，都指向了底层的数组，修改了底层数组，那么上层的切片值肯定会变化	fmt.Println(b)	fmt.Println(b4)}
</span></code></pre></div><p>切片指向了一个底层的数组</p>
<p>切片的长度就是它元素的个数</p>
<p>切片的容量是底层数组从切片的第一个元素到最后一个元素的数量</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210729000908993.png" >
		<img src="/GoLearning.assets/image-20210729000908993.png"
			
			
			
			loading="lazy"
			alt="image-20210729000908993">
	</a>
	
	<figcaption>image-20210729000908993</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210729000949711.png" >
		<img src="/GoLearning.assets/image-20210729000949711.png"
			
			
			
			loading="lazy"
			alt="image-20210729000949711">
	</a>
	
	<figcaption>image-20210729000949711</figcaption>
	
</figure></p>
<h5 id="使用make函数构造切片">使用make函数构造切片</h5>
<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span> <span class="p">,</span> <span class="nx">size</span> <span class="p">,</span><span class="nx">cap</span><span class="p">)</span>
</code></pre></div><p>其中：T：切片的元素类型 size：切片中元素的数量 cap：切片的容量</p>
<p>上面的代码中a的内部存储空间已经分配cap个，但是实际上只是使用了len个，容量并不会影响当前元素的个数，所以len返回使用了几个，cap返回切片的容量</p>
<h5 id="切片的本质">切片的本质</h5>
<p>切片就是一个框，框住了一块连续的内存。属于引用类型，真正的数据都是保存在底层数组里的。</p>
<h5 id="切片不能直接比较">切片不能直接比较</h5>
<p>切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。切片唯一合法的比较操作是和nil比较。一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0.但是我们不能说一个长度和容量都是0的切片一定是nil</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//make函数创造切片	s1:=make([]int,3,10)	fmt.Printf(&#34;s1=%v,len(s1)=%d,cap(s1)=%d,s1==nil?:%v\n&#34;,s1,len(s1),cap(s1),s1==nil)	var s2 []int	fmt.Printf(&#34;s2=%v,len(s2)=%d,cap(s2)=%d,s2==nil?:%v\n&#34;,s2,len(s2),cap(s2),s2==nil)	s3:=[]int{}	fmt.Printf(&#34;s3=%v,len(s3)=%d,cap(s3)=%d,s3==nil?:%v\n&#34;,s3,len(s3),cap(s3),s3==nil)	s4:=make([]int,0)	fmt.Printf(&#34;s4=%v,len(s4)=%d,cap(s4)=%d,s4==nil?:%v\n&#34;,s4,len(s4),cap(s4),s4==nil)	//切片的赋值	s5:=[]int {1,3,5,7}	s6:=s5 //s5 和 s6都指向了同一个底层数组	fmt.Println(s5,s6)	s5[0]=100	fmt.Println(s5,s6)	//切片的遍历	//1.索引遍历	for i := 0; i &lt; len(s5); i++ {		fmt.Printf(&#34;%d &#34;,s5[i])	}	fmt.Println()	//2.forrange遍历	for _, v := range s5 {		fmt.Printf(&#34;%d &#34;,v)	}}
</span></code></pre></div><p>所以要判断一个切片是否是空的，要使用len(s)==0来判断</p>
<h5 id="append方法为切片添加元素">append方法为切片添加元素</h5>
<p>go语言的内置函数append可以为切片动态添加元素，每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行扩容，此时该切片指向的底层数组就会更换。扩容操作往往发生在append函数调用时。</p>
<p>切片的扩容策略就不说了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//append 为切片追加元素	s1:=[]string{&#34;北京&#34;,&#34;上海&#34;,&#34;深圳&#34;}	fmt.Printf(&#34;s1=%v len(s1)=%d cap(s1)=%d\n&#34;,s1,len(s1),cap(s1))	//s1[3] = &#34;广州&#34; //错误的写法 会导致编译错误：索引越界	//调用append函数必须使用原来的切片变量接收返回值	s1= append(s1, &#34;广州&#34;) //append追加元素 原来的底层数组放不下的时候 go底层就会把底层数组换一个	//必须用变量接收append的返回值	fmt.Printf(&#34;s1=%v len(s1)=%d cap(s1)=%d\n&#34;,s1,len(s1),cap(s1))	s1 = append(s1,&#34;杭州&#34;,&#34;成都&#34;)	fmt.Printf(&#34;s1=%v len(s1)=%d cap(s1)=%d\n&#34;,s1, len(s1), cap(s1))	s2:=[]string{&#34;武汉&#34;,&#34;西安&#34;,&#34;苏州&#34;}	s1 = append(s1,s2...) //...表示拆开	fmt.Printf(&#34;s1=%v len(s1)=%d cap(s1)=%d\n&#34;,s1, len(s1), cap(s1))}
</span></code></pre></div><h5 id="使用copy复制切片">使用copy复制切片</h5>
<p>由于切片是引用类型，a和b其实是指向了同一块内存地址，所以如果单纯的赋值的话，修改了b的值的同时a的值也会发生变化</p>
<p>go语言内建的copy函数可以迅速地将一个切片的数据复制到另一个切片空间</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">copy</span> <span class="p">(</span><span class="nx">destSlice</span> <span class="p">,</span> <span class="nx">srcSlice</span><span class="p">[]</span> <span class="nx">T</span><span class="p">)</span>
</code></pre></div><h5 id="从切片中删除元素">从切片中删除元素</h5>
<p>go语言中并没有删除切片元素的专用方法，我们可以使用切片 本身的特性来删除元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">a1</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span>	<span class="nx">a2</span><span class="o">:=</span><span class="nx">a1</span>	<span class="kd">var</span> <span class="nx">a3</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span>  <span class="c1">//这样声明没办法复制进去	var a4 []int	//这样声明也没办法复制进去	var a5=make([]int,len(a1), cap(a1))	copy(a3,a1)	copy(a4,a1)	copy(a5,a1)	fmt.Println(a1,a2,a3,a4,a5)	a1[0] = 100	fmt.Println(a1,a2,a3,a4,a5)	//删除第二个元素	a5 = append(a5[:1],a5[2:]...)	fmt.Println(a5)	fmt.Println(cap(a5))	//验证	//1.切片不保存具体的值	//2.切片对应一个底层数组	//3.底层数组都是占用一块连续的内存	x1:=[...]int{1,3,5}  //数组	x2:=x1[:]   //切片 切片指向底层数组	fmt.Println(x2,len(x2),cap(x2))	fmt.Printf(&#34;%p\n&#34;,&amp;x1[0])	x2 = append(x1[:1],x1[2:]...) //切片截取底层数组 重新定义了底层数组的索引的值	fmt.Printf(&#34;%p\n&#34;,&amp;x2[0]) //说明指向的底层数组地址没变 变了的是地址里的值	fmt.Println(x2)  //切片的索引的值	fmt.Println(x1)  //被修改后的底层数组的索引和值}
</span></code></pre></div><p>练习</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">a1</span><span class="o">:=</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">17</span><span class="p">}</span>	<span class="nx">a2</span><span class="o">:=</span><span class="nx">a1</span><span class="p">[:]</span>	<span class="nx">a2</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">a1</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span><span class="nx">a1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a2</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a1</span><span class="p">)}</span>
</code></pre></div><h4 id="指针">指针</h4>
<p>go语言中不存在指针操作，只需要记住两个符号</p>
<ol>
<li><code>&amp;</code> 取地址</li>
<li><code>*</code> 根据地址取值</li>
</ol>
<p>go语言中的指针不能进行偏移和运算，是安全指针。</p>
<p>要搞明白go语言中的指针需要先知道3个概念，指针地址，指针类型和指针取值</p>
<p>go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算。go语言中的指针操作非常简单，只需要记住两个符号：&amp; 取地址 *根据地址取值</p>
<h5 id="指针地址和指针类型">指针地址和指针类型</h5>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。go语言中使用&amp;字符放在变量前面对变量进行取地址操作。go语言中的值类型int / float / bool / string / array / struct 都有对应的指针类型 *int / *int64 / *string</p>
<p>总结：取地址操作符&amp; 和取值操作符*是一对互补操作，&amp;取出地址， *根据地址取出地址指向的值，变量、指针地址、指针变量、取地址、取值的相互关系如下</p>
<ul>
<li>对变量进行取地址&amp;操作，可以获得这个变量的指针变量</li>
<li>指针变量的值是指针地址</li>
<li>对指针变量进行取值*操作，可以获得指针变量指向的原变量的值</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//1.&amp;取地址   //2.*根据地址取值   n:=18   fmt.Println(&amp;n)   p:=&amp;n   fmt.Printf(&#34;%T\n&#34;,p)  //*int表示int类型的指针   m:=*p   fmt.Printf(&#34;%v\n&#34;,m)   fmt.Printf(&#34;%T\n&#34;,m)   var a *int   fmt.Println(a)  //nil 赋值会报错 空指针异常   var a1 = new(int)  //使用new关键字会分配内存块 不会造成空指针   fmt.Println(a1)   fmt.Println(*a1)   *a1 = 100   fmt.Println(*a1)}
</span></code></pre></div><h5 id="make">make</h5>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是她们的指针类型，因为这三种类型就是引用类型，没有必要返回她们的指针了。make函数的函数签名</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">make</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Type</span><span class="p">,</span><span class="nx">size</span> <span class="o">...</span> <span class="nx">IntergerType</span><span class="p">)</span> <span class="nx">Type</span>
</code></pre></div><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对她们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节中详细说明</p>
<h5 id="make和new的区别">make和new的区别</h5>
<ol>
<li>make和new都是用来申请内存的</li>
<li>new很少用，一般用来给基本数据类型申请内存，string / int 返回的是对应类型的指针，例如*string . *int。</li>
<li>make是用来给slice  、 map 、 chan申请内存的，make函数返回的是对应的这三个类型本身</li>
</ol>
<h4 id="map">map</h4>
<p>go语言中提供的映射关系容器为map，其内部使用散列表hash实现</p>
<p>map是一种无序的基于key-value的数据结构，go语言中的map是引用类型，必须初始化才能使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="nx">KeyType</span><span class="p">]</span><span class="nx">valueType</span>
</code></pre></div><p>map类型的变量默认初始值为nil，需要使用make函数来分配内存</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">keyType</span><span class="p">]</span> <span class="nx">valueType</span><span class="p">,[</span><span class="nx">cap</span><span class="p">])</span>
</code></pre></div><h5 id="判断某个键是否存在">判断某个键是否存在</h5>
<p>特殊写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="kd">map</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> 
</code></pre></div><p>遍历map 使用for range即可</p>
<h5 id="使用delete函数删除键值对">使用delete函数删除键值对</h5>
<p>类型为map的切片</p>
<p>值的类型为切片的map</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//map和slice的组合	a:=[]map[string]int{}	//元素类型为map的切片	var a1 = make([]map[string]int,10,10)	//没有对内部的map做初始化	a1[0] = make(map[string]int,10)	a1[0][&#34;ljs&#34;] = 9	a1[0][&#34;jwt&#34;] = 8	fmt.Println(a)	fmt.Println(a1)	//值为切片类型的map	var a2 = make(map[string][]string,10)	a2[&#34;ljs&#34;] = make([]string,10,10)	a2[&#34;ljs&#34;] = []string{&#34;giegie&#34;}	fmt.Println(a2)	a2[&#34;ljs&#34;] = append(a2[&#34;ljs&#34;],[]string{&#34;jiejie&#34;,&#34;didi&#34;}...)	fmt.Println(a2)}
</span></code></pre></div><h4 id="内容回顾-1">内容回顾</h4>
<h5 id="运算符-1">运算符</h5>
<p>算术运算符</p>
<p>逻辑运算符</p>
<p>赋值运算符+= -= *= /= &amp;= |= ^=</p>
<p>位运算符 &raquo; &laquo; | &amp; ^</p>
<p>比较运算符</p>
<h5 id="数组array">数组array</h5>
<p>[&hellip;]int{3,5} 数组包含元素的类型和元素的个数 数组的长度属于数组类型的一部分</p>
<p>数组是值类型</p>
<p>多维数组</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>	<span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;ljs&#34;</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>	<span class="kd">var</span> <span class="nx">ages</span> <span class="p">[</span><span class="mi">30</span><span class="p">]</span><span class="kt">int</span>	<span class="nx">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>	<span class="nx">ages</span> <span class="p">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>	<span class="nx">ages1</span><span class="o">:=</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">}</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages1</span><span class="p">)</span>	<span class="nx">ages2</span><span class="o">:=</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">99</span><span class="p">:</span><span class="mi">99</span><span class="p">}</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages2</span><span class="p">)</span>	<span class="c1">//二维数组	a:=[3][2]string{}	a[0][1] = &#34;ljs&#34;	a[0][0] = &#34;jwt&#34;	fmt.Println(a)	//多维数组是值类型	a1:=[3][2]string{{&#34;ljs&#34;,&#34;jwt&#34;},{&#34;fyz&#34;,&#34;lje&#34;}}	fmt.Println(a1)	var a2 =[3][2]int{[2]int{1,2},[2]int{3,4}}	fmt.Println(a2)	//数组是值类型	a3:=[3]int{1,2,3}	fmt.Println(a3)	f1(a3)	fmt.Println(a3)	a4:=[]int{1,2,3}	fmt.Println(a4)	f2(a4)	fmt.Println(a4)}func f1(a [3]int)  {	//go语言中函数传递的都是值 ctrl+c ctrl+v 	a[1] = 100}func f2(a []int) {	a[1] =100}
</span></code></pre></div><h5 id="切片-1">切片</h5>
<p>切片不存值，像一个框，在底层的数组里取值</p>
<p>切片的定义：指针、长度、容量</p>
<p>var name []T</p>
<p>切片的扩容策略</p>
<ol>
<li>如果申请的容量大于原来的2倍，那就直接扩容至新申请的容量</li>
<li>如果小于1024，那么就直接两倍</li>
<li>如果大于1024，就按照1.25倍去扩容</li>
<li>具体存储的值类型不同，扩容策略也有一定的不同</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="nx">a4</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a4</span><span class="p">)</span>	<span class="nf">f2</span><span class="p">(</span><span class="nx">a4</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a4</span><span class="p">)</span>	<span class="c1">//切片	a5:=[]int{}	fmt.Println(a5)	fmt.Println(a5==nil)	//没有分配内存 零切片声明 nil	var a6 []int	fmt.Println(a6)	fmt.Println(a6==nil)	//make初始化 分配内存	a7 := make([]int, 5, 5)	fmt.Println(a7)	fmt.Println(a7==nil)	s1 :=[]int{1,2,3}	s2:=s1	fmt.Println(s1)	s2[1] = 100	fmt.Println(s2)	fmt.Println(s1) //切片不存值 指向同一个数组	var s3 []int	//append将自动初始化分配内存+扩容	s3 = append(s3,1)	fmt.Println(s3)	var s4 []int	s4 = make([]int,1,1)	copy(s4,s3) //copy函数必须先将dest切片声明好并且初始化好分配好内存和长度	fmt.Println(s4)
</span></code></pre></div><h5 id="指针-1">指针</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="c1">//指针	//go里面的指针只能读不能修改	addr:=&#34;沙河&#34;	addrpointer:=&amp;addr	fmt.Println(addrpointer)	fmt.Printf(&#34;%T\n&#34;,addrpointer)	fmt.Printf(*addrpointer)
</span></code></pre></div><h5 id="map-1">map</h5>
<p>map存储的是键值对的数据。他也是需要申请内存的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//map	var m map[string]int	m = make(map[string]int,5)	m[&#34;ljs&#34;] = 99	m[&#34;jwt&#34;] = 98	fmt.Println(m)	fmt.Println(m[&#34;jiwuming&#34;]) //如果不存在key ，返回的将是value类型的默认值	score,ok:=m[&#34;jiwuming&#34;]	if ok {		println(score)	}else{		println(&#34;查无此人&#34;)	}	delete(m,&#34;lalala&#34;)  //如果没有的话，什么都不干，不报错	delete(m, &#34;jwt&#34;)	fmt.Println(m)
</span></code></pre></div><h5 id="复习">复习</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;strings&#34;</span>	<span class="s">&#34;unicode&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">s1</span><span class="o">:=</span><span class="s">&#34;hello沙河&#34;</span>	<span class="nx">sum</span><span class="o">:=</span><span class="mi">0</span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s1</span> <span class="p">{</span>		<span class="c1">//if v &gt;= 128 {		//	sum++		//}		if unicode.In(v, unicode.Han) {			sum++		}	}	fmt.Println(sum)	s2:=&#34;how do you do&#34;	s3:= strings.Split(s2,&#34; &#34;)	fmt.Println(s3)	m:= make(map[string]int, 5)	for _, v := range s3 {		//if m[v] == 0 {		//	m[v] =1		//}	else {		//	m[v] ++		//}		if _,ok := m[v];!ok{			m[v]=1		}else {			m[v]++		}	}	fmt.Println(m)	//回文判断	//字符串从左往右读和从右往左读是一样的，就是回文	//黄山落叶松叶落山黄	s4:=&#34;黄山落叶松叶落山黄&#34;	s5:= make([]string, len(s4))	for i, v:= range s4 {		s5[len(s4)-i-1]=string(v)		//fmt.Println(i, string(v))		fmt.Println(s5)	}	var s6 string	s6 = strings.Join(s5,&#34;&#34;)	fmt.Println(s6)	fmt.Println(s6==s4)	runes:= make([]rune, 0, len(s4))	for _, rune := range s4 {		runes =append(runes, rune)	}	fmt.Println(&#34;rune[] :&#34;,runes)	for i := 0; i &lt; len(runes)/2; i++ {		if runes[i]!=runes[len(runes)-i-1] {			return		}	}	println(&#34;回文&#34;)}
</span></code></pre></div><h5 id="函数func">函数func</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nb">println</span><span class="p">(</span><span class="nf">f4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))}</span><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello 沙河&#34;</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">f2</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="nx">name</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">f3</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>   <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>  <span class="c1">//y是一个可变长度的切片类型}func f4(x int, y ...int) int {   sum:=x   for _, v := range y {      sum+=v   }   return sum}func f5(x, y int) (sum int) {   sum = x+y   return }func f6(x, y int) (x1, y1 int) {   x1=x   y1=y   return}
</span></code></pre></div><h5 id="defer语句">defer语句</h5>
<p>go语言中的defer语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，将延迟处理的语句按照defer定义的逆序进行执行，也就是说先被defer的语句最后被执行，后被defer的语句最先被执行</p>
<h5 id="defer执行时机">defer执行时机</h5>
<p>在go语言的函数中，return语句在底层并不是原子性操作，他分为给返回值赋值和ret指令两步。而defer语句执行的实际就是在返回值赋值操作后，ret指令执行前，具体如图</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210731151015069.png" >
		<img src="/GoLearning.assets/image-20210731151015069.png"
			
			
			
			loading="lazy"
			alt="image-20210731151015069">
	</a>
	
	<figcaption>image-20210731151015069</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//go语言中的函数的return不是原子操作，在底层是分为两步来执行//第一步：返回值赋值//第二步：真正的return返回//函数中如果存在defer，那么defer执行的时机是在第一步和第二步之间func main() {	fmt.Println(f1())  //5	fmt.Println(f2())  //6	fmt.Println(f3())  //5	fmt.Println(f3_1())  //[100 2]}func f1() int {	x :=5	defer func() {		x++  //修改的是x不是返回值	}()	return x}func f2() (x int) {	defer func() {		x++	}()	return 5  //返回值是x x又++了 所以返回6}func f3() (y int) {	x:=5	defer func() {		x++  //是因为int是值类型 所以y是拷贝值而不是拷贝地址的原因吗	}()	return x}func f3_1() (y []int) {	x:=[]int{1,2}	defer func() {		x[0]=100   //因为[]int 切片是引用类型 所以y拷贝的是地址而不是值	}()	return x}func f4() (x int) {	defer func(x int) {		x++  //改变的是函数的副本	}(x)  //(x)代表的是传入参数	return 5}
</span></code></pre></div><h3 id="变量-1">变量</h3>
<h5 id="全局变量">全局变量</h5>
<h5 id="局部变量">局部变量</h5>
<p>局部变量又分为两种，函数内定义的变量无法在该函数外使用</p>
<p>如果局部变量和全局变量重名，优先访问局部变量</p>
<h5 id="语句块作用域">语句块作用域</h5>
<h4 id="函数类型和变量">函数类型和变量</h4>
<p>我们可以使用type关键字来定义一个函数类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">calculation</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><p>定义了一个函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T \n&#34;</span><span class="p">,</span><span class="nx">f1</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T \n&#34;</span><span class="p">,</span><span class="nx">f2</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T \n&#34;</span><span class="p">,</span><span class="nx">f3</span><span class="p">)</span>	<span class="nf">f3</span><span class="p">(</span><span class="nx">f2</span><span class="p">)</span>	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">f4</span><span class="p">(</span><span class="nx">f2</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span><span class="nx">a</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello 沙河&#34;</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">f2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>	<span class="k">return</span> <span class="mi">5</span><span class="p">}</span><span class="c1">//函数也可以作为参数的类型func f3(x func() int) {	fmt.Println(x())}//函数还可以作为返回值的类型func f4(x func() int)  func(int,int) int {	return f5}func f5(x, y int) int {	return x+y}
</span></code></pre></div><h3 id="今日内容">今日内容</h3>
<h4 id="函数">函数</h4>
<h5 id="函数的定义">函数的定义</h5>
<h5 id="基本格式">基本格式</h5>
<p>参数的格式</p>
<p>有参数的函数</p>
<p>参数类型简写</p>
<p>可变参数</p>
<h5 id="返回值的格式">返回值的格式</h5>
<p>有返回值</p>
<p>无返回值</p>
<p>命名返回值</p>
<h5 id="变量的作用域">变量的作用域</h5>
<ol>
<li>全局作用域</li>
<li>函数作用域
<ol>
<li>先在函数内部找变量，找不到往外层找</li>
<li>函数内部的变量，外部访问不到</li>
</ol>
</li>
<li>代码块作用域</li>
</ol>
<h5 id="高阶函数">高阶函数</h5>
<p>函数也是一种类型，它可以作为一种参数，也可以作为返回值</p>
<h5 id="匿名函数">匿名函数</h5>
<p>没有名字的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nb">println</span><span class="p">(</span><span class="nf">a</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>   <span class="c1">//但是通常匿名函数不是这么用的 通常是由于函数内部不允许定义函数，所以使用匿名函数现写现用   a:= func(x,y int) int {      return x+y   }   println(a(10, 20))   //如果只是调用一次的函数，还可以简写成立即执行函数   i := func(x, y int) int {      return x * y   }(10, 20)   fmt.Println(i)}var a = func (x int) int {   return x}
</span></code></pre></div><h5 id="闭包">闭包</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nf">f1</span><span class="p">(</span><span class="nf">f3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>	<span class="nf">f1</span><span class="p">(</span><span class="nf">f4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>	<span class="nf">f1</span><span class="p">(</span><span class="nf">f5</span><span class="p">(</span><span class="nx">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))}</span><span class="kd">func</span> <span class="nf">f1</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is f1&#34;</span><span class="p">)</span>	<span class="nf">f</span><span class="p">()}</span><span class="kd">func</span> <span class="nf">f2</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;this is f2&#34;</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)}</span><span class="c1">//如何让f1调用的时候执行f2 也就是两个同事写的代码相互兼容//由于f1的形参是一个无形参无返回值的函数类型，因此需要构造一个函数，让其返回值是无形参无返回值的函数类型f3//当然为了兼容f2，f3的形参需要和f2的形参相匹配，这样一来在执行f3的时候，内部调用了f2，并且返回类型满足f1所需func f3(x,y int) func() {	 func(x,y int)  {		 f2(x,y)	}(x,y)	return func() {	}}func f4(x, y int) func() {	return func() {		f2(x,y)	}}func f5(f func(int, int), x, y int) func() {	//把原来需要传递两个int类型的参数包装成一个不需要传参的函数	return func() {		f(x,y)	}}
</span></code></pre></div><p>闭包=函数 + 外部变量的引用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//闭包是什么	//闭包是一个函数，这个函数包含了他外部作用域的一个变量	//底层	//1.函数可以作为返回值	//2.函数内部查找变量的顺序，先在自己内部找，找不到往外层找	ret := adder(100)	i:= ret(200)	fmt.Println(i)}func adder(x int) func(int) int {	return func(y int) int {		x +=y		return x	}}
</span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;strings&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">suffixFunc</span><span class="o">:=</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="s">&#34;.jpg&#34;</span><span class="p">)</span>	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="s">&#34;.txt&#34;</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">suffixFunc</span><span class="p">(</span><span class="s">&#34;text&#34;</span><span class="p">))</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="s">&#34;text&#34;</span><span class="p">))}</span><span class="kd">func</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="nx">suffix</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">string2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span><span class="p">{</span>	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>		<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">suffix</span><span class="p">)</span> <span class="p">{</span>			<span class="k">return</span> <span class="nx">name</span><span class="o">+</span><span class="nx">suffix</span>		<span class="p">}</span>		<span class="k">return</span> <span class="nx">name</span>	<span class="p">}}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">f</span><span class="p">,</span> <span class="nx">f2</span> <span class="o">:=</span> <span class="nf">calc</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nf">f2</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>   <span class="c1">//11 9	fmt.Println(f(3),f2(4))	  //12 8	fmt.Println(f(5),f2(6))	  //13 7}func calc(base int) (func(int)int ,func(int)int) {	add :=func(i int)int{		base+=i		return base	}	sub := func(i int)int{		base-=i		return base	}	return add,sub}
</span></code></pre></div><h5 id="defer进阶">defer进阶</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">a</span><span class="o">:=</span><span class="mi">1</span>	<span class="nx">b</span><span class="o">:=</span><span class="mi">2</span>	<span class="k">defer</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span><span class="nf">calc</span><span class="p">(</span><span class="s">&#34;10&#34;</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">))</span>	<span class="nx">a</span><span class="p">=</span><span class="mi">0</span>	<span class="k">defer</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;2&#34;</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span><span class="nf">calc</span><span class="p">(</span><span class="s">&#34;20&#34;</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">))</span>	<span class="nx">b</span><span class="p">=</span><span class="mi">1</span>	<span class="c1">//defer会先把预定的值先算出来等着最后执行函数	//defer calc(&#34;1&#34;,1,calc(&#34;10&#34;,1,2))	//输出 &#34;10&#34; 1 2 3	//defer calc(&#34;1&#34;,1,3)	//a=0	//defer calc(&#34;2&#34;,1,calc(&#34;20&#34;,0,2))	//输出 &#34;20&#34; 0 2 2	//defer calc(&#34;2&#34;,0,2)	//b=1	//程序退出	//执行 defer calc(&#34;2&#34;,0,2)	//输出 &#34;2&#34; 0 2 2	//执行 defer calc(&#34;1&#34;,1,3)	//输出 &#34;1&#34; 1 3 4}func calc(index string, a, b int) int {	ret :=a+b	fmt.Println(index,a,b,ret)	return ret}
</span></code></pre></div><h5 id="内置函数介绍">内置函数介绍</h5>
<p>close 主要用来关闭channel</p>
<p>len 用来求长度 string array slice map channel</p>
<p>new 用来分配内存，主要用来分配值类型，比如int struct 返回的是指针</p>
<p>make 用来分配内存，主要用来分配引用类型，比如chan map slice</p>
<p>append 用来追加元素到数组 slice中</p>
<p>panic和recover 用来做错误处理</p>
<h5 id="panicrecover">panic/recover</h5>
<p>go语言中目前是没有异常机制的，但是使用panic/recover模式来处理错误。panic可以在任何地方引发，但recover只有在defer调用的函数中有效。</p>
<p>程序运行期间funcB如果引发了panic导致的程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nf">A</span><span class="p">()</span>	<span class="nf">B</span><span class="p">()</span>	<span class="nf">C</span><span class="p">()}</span><span class="kd">func</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//假设此时打开了个数据库连接	defer func() {		error := recover()		fmt.Println(error)		fmt.Println(&#34;要尝试在出错的时候释放数据库连接...&#34;)	}()	panic(&#34;fatal error!&#34;)  //程序奔溃退出	fmt.Println(&#34;B&#34;)}func C() {	fmt.Println(&#34;C&#34;)}
</span></code></pre></div><p>注意：</p>
<ol>
<li>recover必须搭配defer使用</li>
<li>defer一定要在可能引发panic的语句之前定义</li>
</ol>
<h4 id="go语言fmtprintf使用指南">go语言fmt.printf使用指南</h4>
<h5 id="fmt">fmt</h5>
<p>fmt包实现了类似C语言printf和scanf的格式化I/O 主要分为向外输出内容和获取输入内容两大部分</p>
<h5 id="向外输出">向外输出</h5>
<p>print 直接输出</p>
<p>println输出带换行符</p>
<p>printf格式化输出</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%v</td>
<td>值的默认格式</td>
</tr>
<tr>
<td>%+v</td>
<td>类似%v,但输出结构体时会添加字段名</td>
</tr>
<tr>
<td>%#v</td>
<td>值的go语法表示</td>
</tr>
<tr>
<td>%T</td>
<td>打印值的类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
<tr>
<td>%t</td>
<td>布尔值</td>
</tr>
<tr>
<td>%b</td>
<td>对于整型而言，是二进制数，对于浮点数而言，是二进制指数的科学计数法</td>
</tr>
<tr>
<td>%c</td>
<td></td>
</tr>
<tr>
<td>%d</td>
<td></td>
</tr>
<tr>
<td>%o</td>
<td></td>
</tr>
<tr>
<td>%x</td>
<td></td>
</tr>
<tr>
<td>%X</td>
<td></td>
</tr>
<tr>
<td>%U</td>
<td></td>
</tr>
<tr>
<td>%q</td>
<td></td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法</td>
</tr>
<tr>
<td>%f</td>
<td></td>
</tr>
<tr>
<td>%F</td>
<td></td>
</tr>
<tr>
<td>%g</td>
<td>根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td>
</tr>
<tr>
<td>%G</td>
<td></td>
</tr>
<tr>
<td>%s</td>
<td></td>
</tr>
<tr>
<td>%q</td>
<td></td>
</tr>
<tr>
<td>%x</td>
<td>每个字节用两字符十六进制数表示</td>
</tr>
<tr>
<td>%9f</td>
<td>宽度9，默认精度</td>
</tr>
<tr>
<td>%9.2f</td>
<td>宽度9，精度2</td>
</tr>
<tr>
<td>%5.2s</td>
<td>一共5个 保留2个</td>
</tr>
<tr>
<td>%-5s</td>
<td>有空格补在前面</td>
</tr>
</tbody>
</table>
<h5 id="获取输入">获取输入</h5>
<p>fmt.scan fmt.scanf fmt.scanln</p>
<ul>
<li>scan从标准输入扫描文本，读取由空白符分割的值保存到传递给本函数的参数中，换行符视为空白符</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误，如果读取的数据个数比提供的参数少，会返回一个错误报告原因</li>
</ul>
<p>sprint</p>
<p>sprint系列函数会把传入的数据生成并返回一个字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p&#34;</span><span class="p">,</span><span class="s">&#34;helloworld&#34;</span><span class="p">)</span>	<span class="c1">//%d 十进制	//%v 值	//%o 八进制	//%x 十六进制	//%T 类型	//%s 字符串	//%p 指针	//%b 二进制	//%c 字符s	//%f 浮点数	//%t 布尔值	fmt.Println()	var m map[string]int	m= make(map[string]int)	m[&#34;ljs&#34;]=98	fmt.Printf(&#34;%v\n&#34;,m)	fmt.Printf(&#34;%#v\n&#34;,m)	fmt.Printf(&#34;%q\n&#34;,65)	printfPersentage(98)	fmt.Printf(&#34;%b\n&#34;,5.6)	n:=12.34	fmt.Printf(&#34;%f\n&#34;,n)	fmt.Printf(&#34;%9f\n&#34;,n)	fmt.Printf(&#34;%.2f\n&#34;,n)	fmt.Printf(&#34;%9.2f\n&#34;,n)	fmt.Printf(&#34;%9.f\n&#34;,n)	s:=&#34;小王子&#34;	fmt.Printf(&#34;%s\n&#34;,s)	fmt.Printf(&#34;%5s\n&#34;,s)	fmt.Printf(&#34;%-5s\n&#34;,s)	fmt.Printf(&#34;%5.7s\n&#34;,s)	fmt.Printf(&#34;%-5.7s\n&#34;,s)	//一共5个 只留2个	fmt.Printf(&#34;%5.2s\n&#34;,s)	fmt.Printf(&#34;%05s\n&#34;,s)	var s1 string	fmt.Scan(&amp;s1)	fmt.Println(s1)	var (		name string		age int		class string	)	//fmt.Scanf(&#34;%s %d %s\n&#34;,&amp;name,&amp;age,&amp;class)	fmt.Printf(&#34;%s %d %s\n&#34;,name,age,class)	fmt.Scanln(&amp;name,&amp;age,&amp;class)	fmt.Printf(&#34;%s %d %s\n&#34;,name,age,class)}func printfPersentage(a int) {	fmt.Printf(&#34;%d%%\n&#34;,a)}
</span></code></pre></div><h5 id="今日难点">今日难点</h5>
<ol>
<li>函数的定义</li>
<li>高阶函数</li>
<li>函数类型</li>
<li>闭包</li>
<li>defer</li>
<li>panic/recover</li>
</ol>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210802002337782.png" >
		<img src="/GoLearning.assets/image-20210802002337782.png"
			
			
			
			loading="lazy"
			alt="image-20210802002337782">
	</a>
	
	<figcaption>image-20210802002337782</figcaption>
	
</figure></p>
<h4 id="结构体-struct">结构体 struct</h4>
<p>方法</p>
<p>实际上类似于类</p>
<h4 id="内容回顾-2">内容回顾</h4>
<p>函数的定义</p>
<p>func name () 返回值 {}</p>
<p>函数进阶</p>
<ul>
<li>
<p>​	高阶函数：函数可以作为参数，也可以作为返回值</p>
</li>
<li>
<p>​	闭包：函数和其外部变量的引用</p>
</li>
<li>
<p>​	defer：延迟调用 多用于处理资源释放</p>
</li>
<li>
<p>​	内置函数：</p>
<ul>
<li>​		panic/recover</li>
</ul>
</li>
</ul>
<h5 id="递归">递归</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//递归:自己调用自己	//递归适合处理那种问题相同但是规模越来越小的场景	//递归一定要有一个明确的退出条件	println(Factorial(7))	fmt.Println(taijie(4))}func Factorial(n int) (result int) {	if n == 1 {		return 1	} else{		result =n * Factorial(n-1)		return	}}//上台阶面试题//n个台阶 一次可以走1步 一次可以走2步 有多少种走法func taijie(n int) (result int) {	if n == 1 {		result =1  //如果只有1个台阶就一种走法		return	}else if n == 2 {		return 2	}	return taijie(n-1)+taijie(n-2)}
</span></code></pre></div><h5 id="自定义类型和类型别名">自定义类型和类型别名</h5>
<p>在go语言中有一些基本的数据类型，如string bool int float等数据类型，go语言中可以使用type关键字来定义自定义类型</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义</p>
<p>类型别名规定typealias只是type的别名，本质上是一个类型，这些名字都指向一个类型</p>
<p>区别 ： 自定义类型编译后类型是自定义的 类型别名只会在代码中存在，编译完成只会有原类型</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210806225811170.png" >
		<img src="/GoLearning.assets/image-20210806225811170.png"
			
			
			
			loading="lazy"
			alt="image-20210806225811170">
	</a>
	
	<figcaption>image-20210806225811170</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//type后面跟的是类型type myInt int //自定义类型type yourInt = int //类型别名func main() {	//自定义类型和类型别名	var n myInt	n = 100	fmt.Println(n)	fmt.Printf(&#34;%T\n&#34;,n)	var m yourInt	m = 100	fmt.Println(m)	fmt.Printf(&#34;%T\n&#34;,m)	var r rune	r = &#39;中&#39;	fmt.Printf(&#34;%c\n&#34;,r)	fmt.Printf(&#34;%T\n&#34;,r)}
</span></code></pre></div><h4 id="结构体">结构体</h4>
<p>go语言中没有类的概念，也不支持类的继承等面向对象的概念。go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>go语言中的基础数据类型可以表示一些事务的基本属性，但是当我们想表达一个事务的全部或者部分属性时，这时候再用一些基本数据类型明显就无法满足需求了，go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct 也就是我们可以通过struct来定义自己的类型</p>
<p>go语言中通过struct来实现面向对象</p>
<h5 id="结构体的定义">结构体的定义</h5>
<p>使用type和struct关键字来定义结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//结构体type person struct {	name string	age int	hobby []string	gender string}func main() {	//声明一个person类型的变量	var f person	//通过字段赋值	f.gender = &#34;男&#34;	f.hobby = make([]string,10)	f.hobby[0] =&#34;football&#34;	f.hobby[1] =&#34;basketball&#34;	f.age = 18	f.name = &#34;ljs&#34;	fmt.Println(f)	fmt.Printf(&#34;%T\n&#34;,f)	fmt.Println(f.hobby)	var f1 person	f1.name = &#34;jwt&#34;	fmt.Println(f1)}	//匿名结构体  多用于临时场景	s := struct {		name string		age  int	}{age: 18,name: &#34;fyz&#34;}	fmt.Println(s)	var s1 = struct {		name string		sex  int	}{sex : 1,name:&#34;lje&#34;}	fmt.Println(s1)
</span></code></pre></div><p>结构体是值类型</p>
<h5 id="在go语言中只存在值传递要么是该值的副本要么是指针的副本不存在引用传递之所以对于引用类型的传递可以修改原内容数据是因为在底层默认使用该引用类型的指针进行传递但是也是使用指针的副本依旧是值传递">在Go语言中只存在值传递（要么是该值的副本，要么是指针的副本），不存在引用传递。之所以对于引用类型的传递可以修改原内容数据，是因为在底层默认使用该引用类型的指针进行传递，但是也是使用指针的副本，依旧是值传递。</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210807001149451.png" >
		<img src="/GoLearning.assets/image-20210807001149451.png"
			
			
			
			loading="lazy"
			alt="image-20210807001149451">
	</a>
	
	<figcaption>image-20210807001149451</figcaption>
	
</figure></p>
<ul>
<li>创建指针类型结构体</li>
<li>取结构体地址实例化</li>
<li>结构体初始化
<ul>
<li>使用键值对初始化</li>
<li>使用值的列表初始化</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">name</span> <span class="kt">string</span>	<span class="nx">sex</span> <span class="kt">string</span><span class="p">}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//结构体是值类型	p :=person{		name: &#34;ljs&#34;,		sex: &#34;男&#34;,	}	fmt.Println(p)	var p1 person	p1.name =&#34;lje&#34;	p1.sex = &#34;nan&#34;	var p2 person	p2 = p1	p2.name =&#34;fyz&#34;	fmt.Println(p2)	fmt.Println(p1)	func(x person){			x.sex = &#34;女&#34;  //传的是值	}(p2)	fmt.Println(p2)	func(x *person){		(*x).sex = &#34;nv&#34;  //传的是地址		//x.sex = &#34;nv&#34;  //语法糖 一样的同上	}(&amp;p2)	fmt.Println(p2)	//创建一个指针类型的person	var p3 = new (person)   //new 返回的是指针地址 这个类型	p3.sex = &#34;nan&#34;	(*p3).name = &#34;www&#34;  //语法糖 一样的同上	fmt.Println(p3)	fmt.Printf(&#34;%T\n&#34;,p3)	fmt.Printf(&#34;%p\n&#34;,p3)  //返回的是这个指针的值 p3保存的值就是一个内存地址	fmt.Printf(&#34;%v\n&#34;,p3)	fmt.Printf(&#34;%T\n&#34;,&amp;p3)	fmt.Printf(&#34;%p\n&#34;,&amp;p3)  //返回的是这个指针类型的值的地址	//key value 初始化	var p4 =&amp;person{		name: &#34;lll&#34;,	}	fmt.Println(p4)	//使用值 列表的形式初始化 顺序保持一致	p5:=person{		 &#34;nv&#34;,		 &#34;slkdjf&#34;,	}	fmt.Println(p5)}
</span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>	<span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>	<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">a</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T %p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T %p\n&#34;</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span>  <span class="c1">//b的值	fmt.Printf(&#34;%T %v\n&#34;,b,b)  //b的值	fmt.Printf(&#34;%T %p\n&#34;,&amp;b,&amp;b)  //b的内存地址}
</span></code></pre></div><h5 id="结构体的内存布局">结构体的内存布局</h5>
<p>占用连续内存</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">type</span> <span class="nx">x</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">a</span> <span class="p">,</span><span class="nx">b</span> <span class="p">,</span><span class="nx">c</span> <span class="kt">int8</span><span class="p">}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//结构体占用一块连续的内存空间	x :=x{		a: 10,		b: 20,		c: 30,	}	fmt.Printf(&#34;%p\n&#34;,&amp;(x.a))	fmt.Printf(&#34;%p\n&#34;,&amp;(x.b))	fmt.Printf(&#34;%p\n&#34;,&amp;(x.c))}
</span></code></pre></div><p>结构体是值类型 赋值的时候是拷贝</p>
<p>构造函数：返回一个结构体变量的函数</p>
<p>构造函数和方法</p>
<h5 id="方法和接收者">方法和接收者</h5>
<p>go语言中的方法method是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者receiver 接收者的概念就类似于其他语言中的this或者self</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">接收者变量</span> <span class="nx">接收者类型</span><span class="p">)</span> <span class="nx">方法名</span><span class="p">(</span><span class="nx">参数列表</span><span class="p">)</span> <span class="p">(</span><span class="nx">返回参数</span><span class="p">){</span>    <span class="nx">函数体</span><span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//标识符：变量名、函数名、类型名、方法铭//go语言中如果标识符首字母是大写的，就表示对外部包可见（暴露的，公有的）//Dog 这是一个狗的结构体注释type Dog struct {	name string}func newDog(name string) Dog {	return Dog{		name: name,	}}type person struct {	name string	age int}func newPerson(name string, age int) person {	return person{		name: name,		age: age,	}}//方法是作用于特定类型的函数//接受者表示的是调用该方法的具体类型变量，多用类型变量首字母小写表示func (d Dog) wangwang() {	fmt.Println(d.name+&#34;汪汪汪&#34;)}//使用值接收者：传拷贝进去func (p person) guonian() {	p.age++}//操作指针 指针接收者：传地址进去func (p *person) guonian1() {	(*p).age++}func main() {	newDog(&#34;jwt&#34;).wangwang()	p := newPerson(&#34;ljs&#34;, 18)	fmt.Println(p.age)	p.guonian()	fmt.Println(p.age)	p1:=newPerson(&#34;jwt&#34;,19)	fmt.Println(p1.age)	p1.guonian1()	fmt.Println(p1.age)}
</span></code></pre></div><h5 id="什么时候应该使用指针类型接收者">什么时候应该使用指针类型接收者</h5>
<ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者</li>
</ol>
<h5 id="任意类型添加方法">任意类型添加方法</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//给自定义类型添加方法//不能给别的包里面的类型添加方法，只能给自己的包里的类型添加方法type myInt  intfunc (i myInt) hello()  {	fmt.Println(&#34;this is a int&#34;+(string(i)))}func main() {	var i myInt	i= 10	i.hello()}
</span></code></pre></div><h5 id="结构体的匿名字段">结构体的匿名字段</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//匿名字段type person struct {	string	int}func main() {	a:=person{		&#34;ljs&#34;,		10,	}	fmt.Println(a.string)	fmt.Println(a.int)}
</span></code></pre></div><h5 id="结构体嵌套">结构体嵌套</h5>
<p>实际上就是包含关系或者继承嘛感觉</p>
<h5 id="匿名嵌套结构体">匿名嵌套结构体</h5>
<p>匿名嵌套结构体的字段冲突</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">name</span> <span class="kt">string</span>   <span class="nx">age</span> <span class="kt">int</span>   <span class="nx">addr</span> <span class="nx">address</span><span class="p">}</span><span class="kd">type</span> <span class="nx">company</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">name</span> <span class="kt">string</span>   <span class="nx">address</span>  <span class="c1">//匿名嵌套结构体 可以直接拿到匿名结构体里面的字段}type address struct {   province string   city string}func main() {   p1:=person{      name: &#34;ljs&#34;,      age: 18,      addr: address{city: &#34;fuzhou&#34;,province: &#34;fujian&#34;},   }   fmt.Println(p1.addr.province)   c1:=company{      name:    &#34;alibaba&#34;,      address: address{province: &#34;zhejiang&#34;,city: &#34;hangzhou&#34;},   }   fmt.Println(c1.city) //先在自己结构体找这个字段 找不到就去匿名嵌套的结构体中查找该字段}
</span></code></pre></div><h5 id="结构体的继承">结构体的“继承”</h5>
<p>go语言中使用结构体也可以实现其他编程语言中面向对象的继承</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">type</span> <span class="nx">animal</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">name</span> <span class="kt">string</span><span class="p">}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">animal</span><span class="p">)</span> <span class="nf">move</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;会动&#34;</span><span class="p">)}</span><span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">feet</span> <span class="kt">byte</span>	<span class="nx">animal</span><span class="p">}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">dog</span><span class="p">)</span> <span class="nf">wang</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s">&#34;wangwangwang&#34;</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">newDog</span><span class="p">(</span><span class="nx">a</span> <span class="nx">animal</span><span class="p">,</span> <span class="nx">feet</span> <span class="kt">byte</span><span class="p">)</span> <span class="nx">dog</span> <span class="p">{</span>	<span class="k">return</span> <span class="nx">dog</span><span class="p">{</span>		<span class="nx">feet</span><span class="p">,</span><span class="nx">a</span><span class="p">,</span>	<span class="p">}}</span><span class="kd">func</span> <span class="nf">newAnimal</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">animal</span> <span class="p">{</span>	<span class="k">return</span> <span class="nx">animal</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span><span class="nx">name</span><span class="p">}}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//结构体模拟实现其他语言中的继承	newDog(newAnimal(&#34;jwt&#34;),4).wang()	d1:=dog{		 4, animal{name: &#34;ljs&#34;},	}	d1.move()  //只能匿名嵌套结构体才能实现类似于继承的效果 如果有名字好像就调用不了}
</span></code></pre></div><h5 id="结构体与json">结构体与json</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;encoding/json&#34;</span>   <span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//结构体与json   //1.序列化 把go语言中的结构体变量 --&gt; json格式的字符串   //2.反序列化 把json格式的字符串  --&gt; go语言中能够识别的结构体变量   p1:=person{      Name: &#34;ljs&#34;,      Age: 18,   }   //序列化   v,err:=json.Marshal(p1)   if err != nil {      fmt.Println(&#34;marshal fail &#34;)      fmt.Println(err)      fmt.Printf(&#34;%v  %T\n&#34;,err,err)      return   }   fmt.Println(v)   fmt.Printf(&#34;%v  %T\n&#34;,string(v),v)   //反序列化  传指针进去   var v1 person   err1 := json.Unmarshal(v, &amp;v1)   if err1 != nil {      fmt.Println(err1)      return   }   fmt.Println(v1)   fmt.Println(v1.Age)   fmt.Println(v1.Name)   s:=`{&#34;name&#34;:&#34;ljs&#34;,&#34;age&#34;:18}`   var v2 person    //传指针进去   json.Unmarshal([]byte(s),&amp;v2)   fmt.Printf(&#34;%#v\n&#34;,v2)}type person struct {   Name string `json:&#34;name&#34; db:&#34;dbname&#34;`   Age int `json:&#34;age&#34;`}
</span></code></pre></div><h4 id="day05内容回顾">day05内容回顾</h4>
<h5 id="自定义类型和类型别名-1">自定义类型和类型别名</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myInt</span> <span class="kt">int</span> <span class="nx">自定义类型</span> <span class="kd">type</span> <span class="nx">myInt1</span> <span class="p">=</span> <span class="kt">int</span> <span class="nx">类型别名</span> <span class="nx">在编译过程中</span>
</code></pre></div><p>类型别名只在代码编写过程中有效，编译完之后就不存在，内置的byte和rune都属于类型别名</p>
<h5 id="结构体-1">结构体</h5>
<p>基本数据类型 ：表示现实中的物体有局限性</p>
<p>结构体是一种数据类型，一种我们可以自己造的可以保存多个维度的类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span><span class="p">{</span>    <span class="nx">name</span> <span class="kt">string</span>     <span class="nx">age</span> <span class="kt">int</span>     <span class="nx">addr</span> <span class="nx">address</span><span class="p">}</span>
</code></pre></div><h5 id="匿名结构体">匿名结构体</h5>
<p>多用于了临时场景</p>
<h5 id="结构体的初始化">结构体的初始化</h5>
<h5 id="构造函数">构造函数</h5>
<h5 id="方法和接收者-1">方法和接收者</h5>
<p>方法是有接收者的函数，接收者指的是哪个类型的变量可以调用这个函数</p>
<h5 id="接收者可以是指针">接收者可以是指针</h5>
<p>结构体是值类型</p>
<h5 id="结构体的嵌套">结构体的嵌套</h5>
<h5 id="结构体的匿名字段-1">结构体的匿名字段</h5>
<h5 id="json序列化与反序列化">JSON序列化与反序列化</h5>
<p>经常出现的问题</p>
<ol>
<li>结构体内部的字段要大写 不然别人是访问不到的</li>
<li>反序列化时要传递指针</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;encoding/json&#34;</span>   <span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="kd">type</span> <span class="nx">temp</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">X</span> <span class="kt">int</span> <span class="s">`json:&#34;x&#34;`</span>   <span class="nx">Y</span> <span class="kt">int</span> <span class="s">`json:&#34;y&#34;`</span><span class="p">}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>      <span class="nx">x</span> <span class="kt">int</span>      <span class="nx">y</span> <span class="kt">int</span>   <span class="p">}{</span><span class="nx">x</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nx">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>   <span class="kd">var</span> <span class="nx">a1</span> <span class="nx">temp</span>   <span class="nx">a1</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">1</span>   <span class="nx">a1</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">2</span>   <span class="nx">a2</span><span class="o">:=</span><span class="nx">temp</span><span class="p">{</span>      <span class="nx">X</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>      <span class="nx">Y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>   <span class="p">}</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a2</span><span class="p">)</span>   <span class="c1">//调用构造函数   a3:=newTemp(1,2)   fmt.Println(a3)   a3.dream()   a3.exchange()   fmt.Println(a3)   marshal, err := json.Marshal(a3)   if err != nil {      fmt.Println(err)   }   fmt.Println(string(marshal))   s1:=`{&#34;x&#34;:2,&#34;y&#34;:4}`   var a4 temp   err1 := json.Unmarshal([]byte(s1), &amp;a4)   if err1 != nil {      fmt.Println(err1)   }   fmt.Println(a4)}//构造函数 返回值是对应的结构体类型func newTemp(x, y int) temp {   return temp{      X: x,      Y: y,   }}//接收者是用对应类型的首字母小写//指定接收者之后 只有该类型的变量才有资格调用func (t temp) dream() {   fmt.Println(&#34;temp也有梦想&#34;)   fmt.Println(t.X+t.Y)}//指针接收者//1.需要修改结构体变量的值时需要使用指针接收者//2.结构体本身比较大，拷贝的内存开销比较大时也要使用指针接收者//3.保持一致性：如果有一个方法使用了指针接收者，其他的方法为了统一也要使用指针接收者func (t *temp) exchange() {   temp:=t.X   t.X = t.Y   t.Y = temp}type addr struct {   city , province string}type student struct {   name string    addr  //匿名嵌套结构体，就是用类型名字作为名称}
</span></code></pre></div><h5 id="接口interface">接口interface</h5>
<p>接口是一种类型，是一种特殊的类型，他规定了变量有哪些方法</p>
<p>在编程中会遇到一下场景</p>
<p>我不关心一个变量是什么类型，我只关心能调用他的什么方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//引出接口的实例type cat struct {}type dog struct {}func (c cat) speak() {   fmt.Println(&#34;miaomiaomiao~&#34;)}func (d dog) speak() {   fmt.Println(&#34;wangwangwang~&#34;)}type speaker interface {   speak()  //只要实现了speak方法的变量都是speaker类型}func fuck(a speaker) {   a.speak()}func main() {   c:=cat{}   d:=dog{}   fuck(c)   fuck(d)   var ss1 speaker  //定义一个接口类型 ：speaker的变量   ss1=d   ss1.speak()   ss:=speaker(c)   ss.speak()}
</span></code></pre></div><h5 id="接口的定义">接口的定义</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">name</span> <span class="kd">interface</span><span class="p">{</span>    <span class="nf">methodname</span><span class="p">(</span><span class="nx">参数1</span><span class="err">，</span><span class="nx">参数2</span><span class="p">)</span> <span class="p">(</span><span class="nx">返回值1</span><span class="err">，</span><span class="nx">返回值2</span><span class="p">)</span>    <span class="o">...</span><span class="p">}</span>
</code></pre></div><p>用来给变量/参数/返回值 等设置类型</p>
<h5 id="接口的实现">接口的实现</h5>
<p>一个变量如果实现了接口中规定的所有的方法，那么这个变量就实现了这个接口，可以理解称为接口类型的变量。</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210808151410287.png" >
		<img src="/GoLearning.assets/image-20210808151410287.png"
			
			
			
			loading="lazy"
			alt="image-20210808151410287">
	</a>
	
	<figcaption>image-20210808151410287</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210808151514714.png" >
		<img src="/GoLearning.assets/image-20210808151514714.png"
			
			
			
			loading="lazy"
			alt="image-20210808151514714">
	</a>
	
	<figcaption>image-20210808151514714</figcaption>
	
</figure></p>
<h5 id="接口类型的变量">接口类型的变量</h5>
<p>接口类型变量能够存储所有实现了该接口的实例</p>
<h5 id="值接收者和指针接收者实现接口的区别">值接收者和指针接收者实现接口的区别</h5>
<p>前者可以传值，也可以传指针</p>
<p>后者只能传指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="c1">//使用值接收者和指针接收者的区别type animal interface {   move()   eat(string)}type cat struct {   name string   feet int}////使用值接收者实现了接口的所有方法//func (c cat) move() {// fmt.Println(&#34;走猫步&#34;)//}////func (c cat) eat(a string) {// fmt.Println(&#34;猫吃&#34;+a)//}//使用指针接收者实现了接口的所有方法func (c *cat) move() {   fmt.Println(&#34;走猫步&#34;)}func (c *cat) eat(a string) {   fmt.Println(&#34;猫吃&#34;+a)}func main() {   var a1 animal   c1:=cat{      name: &#34;tom&#34;,      feet: 4,   }   c2:=&amp;cat{      name: &#34;假老练&#34;,      feet: 4,   }   a1=&amp;c1   fmt.Println(a1)   a1.eat(&#34;bianbian&#34;)   a1=c2   fmt.Println(a1)   a1.eat(&#34;大便便&#34;)}
</span></code></pre></div><h5 id="类型与接口的关系">类型与接口的关系</h5>
<p>多个类型可以实现同一个接口</p>
<p>一个类型可以实现多个接口</p>
<p>接口可以嵌套接口</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//接口还可以嵌套type animal interface {   mover   eater}//同一个结构体可以实现多个接口type mover interface {   move()}type eater interface {   eat(string)}type cat struct {   name string   feet byte}//一个结构体可以实现多个接口func (c *cat) move() {   fmt.Println(c.name+&#34; is moving&#34;)}func (c *cat) eat(something string) {   fmt.Println(c.name+&#34; is eating &#34;+something)}func main() {   c1:=cat{      name: &#34;tom&#34;,      feet: 4,   }   mover.move(&amp;c1)   eater.eat(&amp;c1,&#34;猫粮&#34;)}
</span></code></pre></div><h5 id="空接口">空接口</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">xxx</span> <span class="kd">interface</span><span class="p">{</span>    <span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">interface</span><span class="p">{}</span>  <span class="c1">//既然是空接口 那就不需要名字了
</span></code></pre></div><p>所有的类型都实现了空接口这种类型，也就是任意类型的变量都能保存到空接口中。</p>
<p>空接口的应用</p>
<ul>
<li>作为函数的参数</li>
<li>作为map的值</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="c1">//空接口func main() {   m1 := make(map[interface{}]interface{},10)   m1[1]=&#34;hello world&#34;   m1[&#34;hello world&#34;] = 1   m1[false] =[...]string{&#34;1&#34;,&#34;2&#34;,&#34;3&#34;}   m1[[...]int{1,2}]=[]bool{true,false}   fmt.Println(m1)   show(m1)}func show(a interface{}) {   fmt.Printf(&#34;%T  %v\n&#34;,a,a)}
</span></code></pre></div><h5 id="类型断言">类型断言</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span><span class="p">)</span><span class="c1">//类型断言func main() {   assert(&#34;100&#34;)   assert(float32(32.1))}func assert(a interface{}) {   fmt.Printf(&#34;%T %v\n&#34;,a,a)   s,ok := a.(string)  //类型断言   if !ok {      fmt.Println(&#34;error &#34;)      return   }   fmt.Println(s)   switch i:=a.(type) {   case string:      fmt.Printf(&#34;this is a string %T %v\n&#34;,i,i)   case int:      fmt.Printf(&#34;this is a int %T %v\n&#34;,i,i)   case bool:      fmt.Printf(&#34;this is a bool %T %v\n&#34;,i,i)   case float64,float32:      fmt.Printf(&#34;this is a float %T %v\n&#34;,i,i)   }}
</span></code></pre></div><h5 id="接口的注意事项">接口的注意事项</h5>
<p>只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时消耗</p>
<h5 id="包package">包package</h5>
<p>包是多个go源码的集合，是一种高级的代码复用方案，go语言为我们提供了很多内置包，如fmt、os、io等</p>
<p>定义包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">包名</span>
</code></pre></div><p>注意：</p>
<ul>
<li>一个文件夹下只能有一个包，同样一个包的文件不能在多个文件夹下</li>
<li>包名可以不和文件夹的名字一样，包名不能包含符号 -</li>
<li>包名为main的包为程序的入口包，编译时不包含main包的源代码是不会得到可执行文件的</li>
</ul>
<h5 id="包的导入">包的导入</h5>
<ul>
<li>import导入语句通常放在文件开头包声明语句的下面</li>
<li>导入的包名需要使用双引号包裹起来</li>
<li>包名是从 $gopath/src/后开始计算的 ， 使用 / 路径进行分割</li>
<li>go语言禁止循环导入包</li>
</ul>
<p>单行导入 、 多行导入、自定义导入、匿名导入包 _</p>
<h5 id="init初始化函数">init()初始化函数</h5>
<p>在go语言程序执行时导入包语句会自动触发包内部init（）函数的调用</p>
<p>init()函数没有参数也咩有返回值 init()函数在程序运行时自动被调用执行 不能在代码中主动调用它</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210808175802083.png" >
		<img src="/GoLearning.assets/image-20210808175802083.png"
			
			
			
			loading="lazy"
			alt="image-20210808175802083">
	</a>
	
	<figcaption>image-20210808175802083</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210808175917585.png" >
		<img src="/GoLearning.assets/image-20210808175917585.png"
			
			
			
			loading="lazy"
			alt="image-20210808175917585">
	</a>
	
	<figcaption>image-20210808175917585</figcaption>
	
</figure></p>
<h5 id="文件操作">文件操作</h5>
<p>自己写一个日志库</p>
<p>接口：用处？日志可以输出到终端，可以输出到文件，输出到卡夫卡</p>
<p>文件操作</p>
<h5 id="打开和关闭文件">打开和关闭文件</h5>
<p>os.Open函数能够打开一个文件 返回一个*File 和一个err ，对得到的文件实例调用close()方法能够关闭文件</p>
<p>为了防止文件忘记关闭 我们通常使用defer注册文件关闭语句</p>
<h5 id="fileread">file.Read()</h5>
<h5 id="bufio读取文件">bufio读取文件</h5>
<h5 id="ioutil读取整个文件">ioutil读取整个文件</h5>
<h5 id="文件写入操作">文件写入操作</h5>
<p>os.openfile()函数能够以指定模式打开文件，从而实现文件写入相关功能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">OpenFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span> <span class="p">,</span> <span class="nx">perm</span> <span class="nx">FileMode</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">File</span><span class="p">,</span><span class="kt">error</span><span class="p">){</span>    <span class="p">}</span>
</code></pre></div><p>flag是文件打开的模式</p>
<ul>
<li>os.O_WRONLY</li>
<li>os.O_CREATE</li>
<li>os.O_RDONLY</li>
<li>os.O_RDWR</li>
<li>os.O_TURNC</li>
<li>os.O_APPEND</li>
</ul>
<p>perm：文件权限，一个八进制数。r读 o4 w写 o2 x执行 o1</p>
<p>file.write</p>
<p>file.writestring</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">writer</span><span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</code></pre></div><pre><code>ioutil.WriteFile
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;bufio&#34;</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;io&#34;</span>	<span class="s">&#34;io/ioutil&#34;</span>	<span class="s">&#34;os&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">readFromFile1</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fileObj</span><span class="p">,</span><span class="nx">err</span><span class="o">:=</span><span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;./main.go&#34;</span><span class="p">)</span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;open file failed...&#34;</span><span class="p">)</span>		<span class="k">return</span>	<span class="p">}</span>	<span class="c1">//记得关闭文件	defer fileObj.Close()	var b =make([]byte,128)	for {		n,err:=fileObj.Read(b)		if err == io.EOF {			fmt.Println(&#34;读完了&#34;)			return		}		if err != nil {			fmt.Println(&#34;read from file failed , error&#34;)			return		}		fmt.Println(n)		fmt.Println(string(b))		if n &lt;128 {			return		}	}}//利用bufio这个包读取文件func readFromFileByBufio()  {	fileObjFile,err :=os.Open(&#34;./main.go&#34;)	if err != nil {		fmt.Printf(&#34;err, %v&#34;,err)		return	}	defer fileObjFile.Close()	reader:=bufio.NewReader(fileObjFile)	for {		string,err:=reader.ReadString(&#39;\n&#39;)		if err==io.EOF {			return		}		if err != nil {			fmt.Printf(&#34;read line failed , err : %v&#34;,err)			return		}		fmt.Print(string)	}}func readFromFileByIoutil() {	file, err := ioutil.ReadFile(&#34;./main.go&#34;)	if err != nil {		fmt.Printf(&#34;err , cause: %v\n&#34;,err)	}	fmt.Println(string(file))}//打开文件func main() {	//readFromFile1()	//readFromFileByBufio()	readFromFileByIoutil()}
</span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;bufio&#34;</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;io/ioutil&#34;</span>	<span class="s">&#34;os&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">write</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">fileObj</span> <span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span><span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;./xx.txt&#34;</span><span class="p">,</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_TRUNC</span><span class="p">,</span><span class="mo">0644</span><span class="p">)</span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err cause: %v\n&#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>		<span class="k">return</span>	<span class="p">}</span>	<span class="c1">//write	fileObj.Write([]byte{97,98,99})	fileObj.Write([]byte(&#34;this is a b c &#34;))	fileObj.WriteString(&#34;hello world!&#34;)	defer fileObj.Close()}func writeByBufIo() {	file, err := os.OpenFile(&#34;./xx.txt&#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)	if err != nil {		fmt.Printf(&#34;err cause : %v\n&#34;,err)		return	}	writer:= bufio.NewWriter(file)	writer.WriteString(&#34;comeon baby!&#34;)   //bufio是做了一个缓存	writer.Flush()	defer file.Close()}func writeByIoutil()  {	str:=&#34;hello 北京&#34;	err := ioutil.WriteFile(&#34;./xx.txt&#34;, []byte(str), 0666)	if err != nil {		fmt.Printf(&#34;error cause : %v\n&#34;,err)		return	}}func main() {	//write()	//writeByBufIo()	writeByIoutil()	}
</span></code></pre></div><p>拷贝文件 可以借助io.copy()实现一个拷贝文件函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;io/ioutil&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nf">copyFile</span><span class="p">(</span><span class="s">&#34;./xxcopy.txt&#34;</span><span class="p">,</span><span class="s">&#34;./xx.txt&#34;</span><span class="p">)}</span><span class="kd">func</span> <span class="nf">copyFile</span><span class="p">(</span><span class="nx">dstName</span><span class="p">,</span><span class="nx">srcName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">//以读的方式打开文件	//file, err := os.OpenFile(srcName, os.O_RDONLY, 0644)	//if err != nil {	//	return 0, err	//}	//reader:= bufio.NewReader(file)	readFile, err := ioutil.ReadFile(srcName)	if err != nil {		return 0, err	}	err1 := ioutil.WriteFile(dstName, readFile, 0644)	if err1 != nil {		return 0, err1	}	return 1,nil}
</span></code></pre></div><p>通过文件操作获取终端输入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;bufio&#34;</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;os&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//useScan()	ioscan()}func useScan() {	fmt.Println(&#34;请输入内容！&#34;)	var s string	fmt.Scanln(&amp;s)	fmt.Printf(&#34;你输入的内容是 %v\n&#34;,s)}func ioscan() {	fmt.Println(&#34;请输入内容！&#34;)	var s string	reader := bufio.NewReader(os.Stdin)	s,_=reader.ReadString(&#39;\n&#39;)	fmt.Println(s)}
</span></code></pre></div><h5 id="日志库作业">日志库作业</h5>
<p>需求：</p>
<ol>
<li>可以往不同的输出位置记录日志</li>
<li>日志可以分为五种级别</li>
</ol>
<h4 id="内容回顾-3">内容回顾</h4>
<h5 id="包">包</h5>
<p>包的定义 package，包名通常是和目录名一致，不能包含-</p>
<ul>
<li>一个文件夹就是一个包</li>
<li>文件夹里面放的都是.go文件</li>
</ul>
<p>包的导入 import</p>
<ul>
<li>​	单行导入 和 多行导入</li>
<li>​    包导入路径是从gopath\src后面的路径开始写起</li>
<li>​    给导入的包起别名</li>
<li>匿名导入 &mdash;&gt; sql包导入时会讲</li>
<li>不支持循环导入</li>
</ul>
<p>包中标识符(变量名、函数名、结构体、接口、常量&hellip;) 可见性 标识符首字母大写</p>
<p><code>init()</code></p>
<ul>
<li>包导入的时候会自动执行</li>
<li>一个包里只有一个init()</li>
<li>init()没有参数也没有返回值也不能调用他</li>
<li>多个包的init执行顺序</li>
<li>一般用于初始化操作&hellip;</li>
</ul>
<h5 id="接口">接口</h5>
<p>接口是一种类型，一种抽象的类型</p>
<p>接口就是你要实现的方法的清单</p>
<h5 id="接口的定义-1">接口的定义</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mover</span> <span class="kd">interface</span><span class="p">{</span>    <span class="nx">方法签名</span><span class="p">(</span><span class="nx">参数</span><span class="p">)(</span><span class="nx">返回值</span><span class="p">)}</span>
</code></pre></div><h5 id="接口的实现-1">接口的实现</h5>
<p>实现了接口的所有方法就实现了这个接口</p>
<p>实现了接口就可以当成这个接口类型的变量</p>
<h5 id="接口的变量">接口的变量</h5>
<p>实现了一个变量，可以保存所有实现了我这个接口类型的值</p>
<p>通常作为函数的参数出现</p>
<h5 id="空接口-1">空接口</h5>
<p>接口中没有定义任何方法，也就是所任意类型都实现了空接口==&gt;任何类型的变量都可以存到这个空接口变量中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">interface</span> <span class="p">{}</span>
</code></pre></div><p>作为函数参数fmt.println()</p>
<p>map[string]interface{}</p>
<h5 id="接口底层">接口底层</h5>
<ul>
<li>动态类型</li>
<li>动态值</li>
</ul>
<h5 id="类型断言-1">类型断言</h5>
<p>做类型断言的前提是 一定要是一个接口类型的变量</p>
<p>x.(T)</p>
<p>使用switch来做类型断言</p>
<h5 id="文件操作-1">文件操作</h5>
<h5 id="打开文件和关闭文件">打开文件和关闭文件</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210810185410507.png" >
		<img src="/GoLearning.assets/image-20210810185410507.png"
			
			
			
			loading="lazy"
			alt="image-20210810185410507">
	</a>
	
	<figcaption>image-20210810185410507</figcaption>
	
</figure></p>
<p>缓冲区</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210810185806983.png" >
		<img src="/GoLearning.assets/image-20210810185806983.png"
			
			
			
			loading="lazy"
			alt="image-20210810185806983">
	</a>
	
	<figcaption>image-20210810185806983</figcaption>
	
</figure></p>
<p>read</p>
<p>bufio</p>
<p>ioutil</p>
<h5 id="写文件">写文件</h5>
<p>os.openfile()</p>
<p>write 和 writestring</p>
<p>bufio.newwriter</p>
<p>ioutil</p>
<p>在文件中插入东东</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;os&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="c1">//OpenFile()	InsertFile()}func InsertFile() {	//打开文件	file, err := os.OpenFile(&#34;./sb.txt&#34;, os.O_RDWR, 0644)	if err != nil {		fmt.Printf(&#34;err cause : %v\n&#34;,file)		return	}	defer file.Close()	//读首两个字节	var b = [2]byte{}	n, _ := file.Read(b[:])	//创建文件 写首两个字节	openFile, _ := os.OpenFile(&#34;./sbinsert.txt&#34;, os.O_CREATE|os.O_WRONLY, 0644)	openFile.Write(b[:n])	defer openFile.Close()	//尝试移动光标	_, err1 := file.Seek(2, 0)  //光标移动	if err1 != nil {		return	}	//尝试写要插入的数据	openFile.Write([]byte{&#39;c&#39;})	//尝试读光标下一个字节的数据	var a [128]byte	read, err2 := file.Read(a[:])	if err2 != nil {		return	}	fmt.Println(string(a[:read]))	openFile.Write(a[:read])	os.Rename(&#34;./sbinsert.txt&#34;,&#34;./sb.txt&#34;)	//writer := bufio.NewWriter(file)	//writer.WriteString(&#34;c&#34;)	//writer.Flush()}func OpenFile() {	open, err := os.Open(&#34;./xx.txt&#34;)	if err != nil {		fmt.Printf(&#34;err cause: %v\n&#34;,open)		return	}	defer open.Close()	var b [128]byte	for {		read, err1 := open.Read(b[:])		if err1 != nil {			fmt.Printf(&#34;read err cause: %v\n&#34;,err1)			return		}		fmt.Println(string(b[:]))		if read &lt;128 {			return		}	}}
</span></code></pre></div><h4 id="今日内容-1">今日内容</h4>
<h5 id="time标准库">time标准库</h5>
<p>时间类型</p>
<p>time.time类型表示时间 我们可以通过time.now() 函数获取当前的时间对象 然后获取时间对象的年月日时分秒等信息。示例代码如下：</p>
<h5 id="时间戳">时间戳</h5>
<h5 id="时间间隔">时间间隔</h5>
<h5 id="add">add</h5>
<h5 id="sub">sub</h5>
<h5 id="equal">equal</h5>
<h5 id="before">before</h5>
<h5 id="after">after</h5>
<h5 id="定时器timetick">定时器time.tick</h5>
<h5 id="时间格式化">时间格式化</h5>
<p>时间类型有一个自带的方法Format进行格式化，需要注意的是go语言中格式化时间模版不是常见的y-m-d h:/m:/s 而是使用go诞生的时间2006 1 2 3 4</p>
<p>补充：如果想要格式化为12小时方式，需要指定PM</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nf">f2</span><span class="p">()}</span><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">)</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Year</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Month</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Day</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Hour</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Minute</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v \n&#34;</span><span class="p">,</span><span class="nx">now</span><span class="p">.</span><span class="nf">Second</span><span class="p">())</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nf">Date</span><span class="p">())</span>   <span class="c1">//时间戳   fmt.Println(now.Unix())   fmt.Println(now.UnixNano())   //time.Unix()   unix:= time.Unix(now.Unix(), 0)   fmt.Println(unix)   //时间间隔   fmt.Println(time.Second)   //now +24 hours   fmt.Println(time.Now().Add(time.Hour*24))   //定时器   //tick := time.Tick(time.Second)   //for  i := range tick {   // fmt.Println(i)   //}   //格式化时间 把语言中时间对象 转换成字符串类型的时间   //2021/08/10   fmt.Println(time.Now().Format(&#34;2006/01/02&#34;))   fmt.Println(time.Now().Format(&#34;2006-1-2 15:04:05&#34;))   fmt.Println(time.Now().Format(&#34;2006-1-2 03:04:05&#34;))   fmt.Println(time.Now().Format(&#34;2006-1-2 15:04:05 PM&#34;))   fmt.Println(time.Now().Format(&#34;2006:01:02 15:04:05.000 PM&#34;))   //按照对应的格式 解析字符串类型的时间   value, err := time.Parse(&#34;2006-01-02&#34;, &#34;2019-05-20&#34;)   if err != nil {      fmt.Println( &#34; err &#34;,err)      return   }   fmt.Println(value)   fmt.Println(time.Now().Sub(time.Now().Add(-time.Hour)))   fmt.Println(&#34;beginning&#34;)   //sleep   time.Sleep(time.Second*2)   fmt.Println(&#34;ending...&#34;)}func f2() {   now:= time.Now()   //获取的是当前时区的时间   fmt.Println(now)   //按照东八区的时区和格式解析一个字符串格式的时间   time.Parse(&#34;2006-01-02 15:04:05&#34;, &#34;2021-08-11 21:33:05&#34;)   //根据字符加载时区   location, err := time.LoadLocation(&#34;Asia/Shanghai&#34;)   if err!=nil {      fmt.Printf(&#34;load loc failed , err :%v\n&#34;,err)      return   }   //按照指定时区解析时间   parseInLocation, err := time.ParseInLocation(&#34;2006-01-02 15:05:05&#34;, &#34;2021-08-11 21:33:05&#34;, location)   fmt.Println(time.Now().Sub(parseInLocation))}
</span></code></pre></div><h5 id="日志库">日志库</h5>
<p>需求分析</p>
<ol>
<li>
<p>支持往不同的地方输出日志</p>
</li>
<li>
<p>分级别输出</p>
<ol>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
<li>fatal</li>
</ol>
</li>
<li>
<p>日志要支持开关控制，比如说开发的时候什么级别的日志都能输出，但是上线之后只有INFO级别往下才能输出</p>
</li>
<li>
<p>完整的日志记录要包含日志要有时间、行号、文件名、日志级别、日志信息</p>
</li>
<li>
<p>日志文件要切割</p>
<ol>
<li>按文件大小切割
<ol>
<li>每次记录日志之前都判断一下当前写的这个文件的文件大小</li>
</ol>
</li>
<li>按日期切割
<ol>
<li>在日志结构体中设置一个字段记录上一次切割的小时数</li>
<li>在写日志之前检查一下当前时间的小时数和之前保存的是否一致，不一致就要切割</li>
</ol>
</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;os&#34;</span>	<span class="s">&#34;path&#34;</span>	<span class="s">&#34;runtime&#34;</span>	<span class="s">&#34;strconv&#34;</span>	<span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>	<span class="nx">consoleLogger</span> <span class="o">:=</span> <span class="nf">NewConsoleLogger</span><span class="p">(</span><span class="nx">ERROR</span><span class="p">)</span>	<span class="nx">Logger</span><span class="p">.</span><span class="nf">Debug</span><span class="p">(</span><span class="nx">consoleLogger</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">Logger</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">consoleLogger</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">Logger</span><span class="p">.</span><span class="nf">Warning</span><span class="p">(</span><span class="nx">consoleLogger</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">Logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">consoleLogger</span><span class="p">,</span><span class="s">&#34;hello world%d&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">consoleLogger</span><span class="p">,</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>	<span class="nx">fileLogger</span> <span class="o">:=</span> <span class="nf">NewFileLogger</span><span class="p">(</span><span class="nx">ERROR</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="s">&#34;logdemo.txt&#34;</span><span class="p">,</span> <span class="s">&#34;logdemoerr.txt&#34;</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>	<span class="nf">Logger</span><span class="p">(</span><span class="nx">fileLogger</span><span class="p">).</span><span class="nf">Debug</span><span class="p">(</span><span class="s">&#34;hello world %d&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>	<span class="nf">Logger</span><span class="p">(</span><span class="nx">fileLogger</span><span class="p">).</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;fatal error %v&#34;</span><span class="p">,</span><span class="s">&#34;某树被榨干了...&#34;</span><span class="p">)}</span><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>	<span class="nf">Debug</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="nf">Info</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="nf">Warning</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="nf">Error</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>	<span class="nf">Fatal</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})}</span><span class="kd">type</span> <span class="nx">ConsoleLogger</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">LogLevel</span> <span class="nx">MODE</span><span class="p">}</span><span class="kd">type</span> <span class="nx">MODE</span> <span class="p">=</span> <span class="nf">intconst</span> <span class="p">(</span>	<span class="nx">DEBUG</span> <span class="nx">MODE</span> <span class="p">=</span><span class="kc">iota</span>	<span class="nx">INFO</span>	<span class="nx">WARNING</span>	<span class="nx">ERROR</span>	<span class="nx">FATAL</span><span class="p">)</span><span class="kd">func</span> <span class="nf">NewConsoleLogger</span><span class="p">(</span><span class="nx">logLevel</span> <span class="nx">MODE</span><span class="p">)</span> <span class="nx">ConsoleLogger</span> <span class="p">{</span>	<span class="k">return</span> <span class="nx">ConsoleLogger</span><span class="p">{</span>		<span class="nx">LogLevel</span><span class="p">:</span> <span class="nx">logLevel</span><span class="p">,</span>	<span class="p">}}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Debug</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">a</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogLevel</span><span class="o">&gt;=</span><span class="nx">DEBUG</span> <span class="p">{</span>		<span class="kd">var</span> <span class="nx">msg</span> <span class="kt">string</span>		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">s</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span>		<span class="p">}</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v] [DEBUG] this is a debug log, value :%v\n&#34;</span><span class="p">,</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15-04-05&#34;</span><span class="p">),</span><span class="nx">msg</span><span class="p">)</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>	<span class="p">}}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Info</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogLevel</span><span class="o">&gt;=</span><span class="nx">INFO</span> <span class="p">{</span>		<span class="kd">var</span> <span class="nx">msg</span> <span class="kt">string</span>		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">s</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span>		<span class="p">}</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v] [INFO] this is a info log, value :%v\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15-04-05&#34;</span><span class="p">),</span> <span class="nx">msg</span><span class="p">)</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>	<span class="p">}}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Warning</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span> <span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogLevel</span><span class="o">&gt;=</span><span class="nx">WARNING</span> <span class="p">{</span>		<span class="kd">var</span> <span class="nx">msg</span> <span class="kt">string</span>		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">s</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span>		<span class="p">}</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v] [WARNING] this is a warning log, value :%v\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15-04-05&#34;</span><span class="p">),</span> <span class="nx">msg</span><span class="p">)</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>	<span class="p">}}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Error</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogLevel</span><span class="o">&gt;=</span><span class="nx">ERROR</span> <span class="p">{</span>		<span class="kd">var</span> <span class="nx">msg</span> <span class="kt">string</span>		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">s</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span>		<span class="p">}</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v] [ERROR] this is a error log, value :%v \n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15-04-05&#34;</span><span class="p">),</span> <span class="nx">msg</span><span class="p">)</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>	<span class="p">}}</span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Fatal</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">a</span><span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogLevel</span><span class="o">&gt;=</span><span class="nx">FATAL</span> <span class="p">{</span>		<span class="kd">var</span> <span class="nx">msg</span> <span class="kt">string</span>		<span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">s</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="nx">msg</span><span class="p">=</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">a</span><span class="p">)</span>		<span class="p">}</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[%v] [FATAL] this is a fatal log, value :%v\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15-04-05&#34;</span><span class="p">),</span> <span class="nx">msg</span><span class="p">)</span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">getInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>	<span class="p">}}</span><span class="kd">func</span> <span class="nf">getInfo</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>	<span class="nx">caller</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>		<span class="k">return</span> <span class="s">&#34;error&#34;</span>	<span class="p">}</span>	<span class="nx">name</span><span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">FuncForPC</span><span class="p">(</span><span class="nx">caller</span><span class="p">).</span><span class="nf">Name</span><span class="p">()</span>	<span class="k">return</span> <span class="s">&#34;fileLocation: &#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;, method: &#34;</span><span class="o">+</span><span class="nx">name</span><span class="o">+</span><span class="s">&#34;, line: &#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">line</span><span class="p">)}</span><span class="kd">type</span> <span class="nx">FileLogger</span> <span class="kd">struct</span> <span class="p">{</span>	<span class="nx">LogLevel</span> <span class="nx">MODE</span>	<span class="nx">fileName</span> <span class="kt">string</span>  <span class="c1">//日志文件的名称	filePath string	 //日志文件的路径	errFileName string 	//错误日志单独记录	maxFileSize int64	fileObj *os.File	errFileObj *os.File}func NewFileLogger(logLevel MODE,filePath, fileName , errFileName string , maxFileSize int64)*FileLogger  {	file, err := os.OpenFile(path.Join(filePath,fileName), os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)	if err != nil {		fmt.Println(err)		return nil	}	errfile, err := os.OpenFile(path.Join(filePath,errFileName),os.O_CREATE|os.O_APPEND|os.O_WRONLY,0644)	if err != nil {		return nil	}	return &amp;FileLogger{		LogLevel: logLevel,		fileName:    fileName,		filePath:    filePath,		errFileName: errFileName,		maxFileSize: maxFileSize,		fileObj: file,		errFileObj: errfile ,	}}func (f *FileLogger) Close()  {	f.fileObj.Close()	f.errFileObj.Close()}func (f *FileLogger) checkSize(fileObj *os.File) bool {	stat, err := fileObj.Stat()	if err != nil {		return false	}	if stat.Size() &gt; f.maxFileSize {		return true	}else{		return false	}}func (f *FileLogger)SplitLogFile() {	//需要切割文件	//1.关闭当前文件	f.fileObj.Close()	//2.rename 备份一下 xx.log -&gt; xx.log.bak201908031709	nowStr:=time.Now().Format(&#34;20060102150405000&#34;)	bakFilePath := path.Join(f.filePath, f.fileName)+&#34;.bak&#34;+nowStr	err := os.Rename(path.Join(f.filePath, f.fileName), bakFilePath)	if err != nil {		return	}	//3.打开一个新的日志文件	newFile, err := os.OpenFile(path.Join(f.filePath, f.fileName), os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)	if err != nil {		return	}	//4.将打开的新日志文件对象赋值给 f.fileObj	f.fileObj = newFile}func (f *FileLogger) Debug(s string, a ...interface{}) {	if f.LogLevel&gt;=DEBUG {		if f.checkSize(f.fileObj) {			f.SplitLogFile()		}		msg := fmt.Sprintf(s, a)		msg = fmt.Sprintf(&#34;[%v] [DEBUG] this is a debug log, value :%v&#34;, time.Now().Format(&#34;2006-01-02 15-04-05&#34;), msg)		fmt.Fprintln(f.fileObj)		fmt.Fprintln(f.fileObj,msg)		fmt.Fprintln(f.fileObj,getInfo(2))		f.Close()	}}func (f *FileLogger) Info(s string, a ...interface{}) {	if f.LogLevel&gt;=INFO {		msg := fmt.Sprintf(s, a)		msg = fmt.Sprintf(&#34;[%v] [INFO] this is a info log, value :%v&#34;, time.Now().Format(&#34;2006-01-02 15-04-05&#34;), msg)		fmt.Fprintln(f.fileObj)		fmt.Fprintln(f.fileObj,msg)		fmt.Fprintln(f.fileObj,getInfo(2))		f.Close()	}}func (f *FileLogger) Warning(s string, a ...interface{}) {	if f.LogLevel&gt;=WARNING {		msg := fmt.Sprintf(s, a)		msg = fmt.Sprintf(&#34;[%v] [WARNING] this is a warning log, value :%v&#34;, time.Now().Format(&#34;2006-01-02 15-04-05&#34;), msg)		fmt.Fprintln(f.fileObj)		fmt.Fprintln(f.fileObj,msg)		fmt.Fprintln(f.fileObj,getInfo(2))		f.Close()	}}func (f *FileLogger) Error(s string, a ...interface{}) {	if f.LogLevel&gt;=ERROR {		msg := fmt.Sprintf(s, a)		msg = fmt.Sprintf(&#34;[%v] [ERROR] this is a error log, value :%v&#34;, time.Now().Format(&#34;2006-01-02 15-04-05&#34;), msg)		fmt.Fprintln(f.fileObj)		fmt.Fprintln(f.fileObj,msg)		fmt.Fprintln(f.fileObj,getInfo(2))		fmt.Fprintln(f.errFileObj)		fmt.Fprintln(f.errFileObj,msg)		fmt.Fprintln(f.errFileObj,getInfo(2))		f.Close()	}}func (f *FileLogger) Fatal(s string, a ...interface{}) {	if f.LogLevel&gt;=FATAL {		msg := fmt.Sprintf(s, a)		msg = fmt.Sprintf(&#34;[%v] [FATAL] this is a Fatal log, value :%v&#34;, time.Now().Format(&#34;2006-01-02 15-04-05&#34;), msg)		fmt.Fprintln(f.fileObj)		fmt.Fprintln(f.fileObj,msg)		fmt.Fprintln(f.fileObj,getInfo(2))		fmt.Fprintln(f.errFileObj)		fmt.Fprintln(f.errFileObj,msg)		fmt.Fprintln(f.errFileObj,getInfo(2))		f.Close()	}}
</span></code></pre></div><h5 id="反射">反射</h5>
<p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型名称、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改她们。</p>
<p>go程序在运行期使用reflect包访问程序的反射信息。</p>
<p>空接口可以存储任意类型的变量，那么我们如何知道空接口保存的数据是什么呢？反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>
<h5 id="reflect包">reflect包</h5>
<p>在go语言的反射机制中，任何接口值都是由一个具体类型和具体类型的值两部分组成的。在go语言中反射的相关功能有内置的reflect包提供，任意接口值在反射中都可以理解为有reflect.Type 和 reflect.Value 两部分组成，并且reflect包提供了reflect.TypeOf 和 reflect.ValueOf两个函数来获取任意对象的value和type</p>
<p>typeof</p>
<p>valueof</p>
<h5 id="type-name-和-type-kind">type name 和 type kind</h5>
<p>在反射中关于类型还划分为两种：类型type和种类kind 在go语言中我们可以使用type关键字构造很多种自定义类I型那个，而种类kind就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类kind</p>
<h5 id="valueof">valueof</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;reflect&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nf">reflectType</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>   <span class="nf">reflectType</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>   <span class="nf">reflectType</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>   <span class="nf">reflectType</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kd">interface</span><span class="p">{}{</span><span class="mi">1</span><span class="p">:</span><span class="s">&#34;hello&#34;</span> <span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">:[]</span><span class="kt">bool</span><span class="p">{</span><span class="kc">true</span><span class="p">}})</span>   <span class="nf">reflectType</span><span class="p">(</span><span class="nx">cat</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;tomcat&#34;</span><span class="p">})</span>   <span class="nf">reflectValue</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>   <span class="nx">b</span><span class="o">:=</span><span class="nb">int64</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>   <span class="c1">//reflectSetValue1(b)  //这样不行会引发panic错误   reflectSetValue2(&amp;b)   fmt.Println(b)   var a *int   fmt.Println(reflect.ValueOf(a).IsNil())   fmt.Println(reflect.ValueOf(a).IsValid())   c := cat{name: &#34;tomcat&#34;}   fmt.Println(reflect.ValueOf(c).FieldByName(&#34;name&#34;))   fmt.Println(reflect.ValueOf(c).MethodByName(&#34;name&#34;).IsValid())   m:=map[string]int{&#34;娜扎&#34;:1}   fmt.Println(reflect.ValueOf(m).MapIndex(reflect.ValueOf(&#34;娜扎&#34;)).IsValid())}func reflectType(a interface{}) {   v := reflect.TypeOf(a)   fmt.Printf(&#34;%T %v\n&#34;,v,v)   fmt.Printf(&#34;type %v  kind %v \n&#34;,v.Name(),v.Kind())}func reflectValue(a interface{})  {   v:=reflect.ValueOf(a)   kind := v.Kind()   switch kind {   case reflect.Int64:      fmt.Printf(&#34;type is int64,value is %d\n&#34;,int64(v.Int()))   case reflect.Float32:      fmt.Printf(&#34;type is float32, value is %f\n&#34;,float32(v.Float()))   }}func reflectSetValue1(x interface{}) {   value := reflect.ValueOf(x)   if value.Kind() == reflect.Int64 {      value.SetInt(200)  //修改的是副本 reflect包会引发panic   }}func reflectSetValue2(x interface{}) {   value :=reflect.ValueOf(x)   if value.Elem().Kind() == reflect.Int64 {      value.Elem().SetInt(200)   }}type cat struct {   name string}
</span></code></pre></div><h5 id="通过反射设置变量的值">通过反射设置变量的值</h5>
<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的elem()方法来获取指针对应的值</p>
<h5 id="isnil和isvalid">isNil和isValid</h5>
<p>报告持有的值是否为nil，持有的值的分类必须是通道、函数、接口、映射、指针、切片之一，否则会导致panic</p>
<p>isvalid返回v是否持有一个值，如果v是value的零值就会返回假，如果v除了isvalid、string、kind之外的方法都会导致panic</p>
<h5 id="区别">区别</h5>
<p>isnil常被用于判断指针是否为空，isvalid常被用于判定返回值是否有效</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="nx">json2</span> <span class="s">&#34;encoding/json&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;reflect&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">s</span><span class="o">:=</span><span class="nx">student</span><span class="p">{</span>      <span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;xwz&#34;</span><span class="p">,</span>      <span class="nx">Score</span><span class="p">:</span> <span class="s">&#34;90&#34;</span><span class="p">,</span>   <span class="p">}</span><span class="c1">//最终要得到 {&#34;name&#34;:&#34;xwz&#34;,&#34;score&#34;:90}   typeof := reflect.TypeOf(s)   json:=`{`   for i := 0; i &lt; typeof.NumField(); i++ {      fmt.Println(typeof.FieldByIndex([]int{i}).Name)      //fmt.Println(typeof.Field(i).Name)      fmt.Println(typeof.FieldByIndex([]int{i}).Tag.Get(&#34;json&#34;))      json+=&#34;\&#34;&#34;+typeof.Field(i).Tag.Get(&#34;json&#34;)+&#34;\&#34;&#34;+&#34;:&#34;      structField, b := typeof.FieldByName(typeof.Field(i).Name)      fmt.Println(structField.Name)      fmt.Println(structField.Type)      fmt.Println(structField.Index)      valueof:= reflect.ValueOf(s)      fmt.Println(valueof.Field(i))      sprint := fmt.Sprint(valueof.Field(i))      if b {         json+=&#34;\&#34;&#34;+sprint+&#34;\&#34;&#34;+&#34;,&#34;      }   }   s2 := json[:len(json)-1]   json = s2   json+=&#34;}&#34;   fmt.Println(json)   var s1 student   json2.Unmarshal([]byte(json),&amp;s1)   fmt.Println(s1)   //反序列化实例}type student struct {   Name string `json:&#34;name&#34;`   Score string `json:&#34;score&#34;`}
</span></code></pre></div><h5 id="内容回顾-4">内容回顾</h5>
<h5 id="time">time</h5>
<h5 id="时间类型">时间类型</h5>
<ul>
<li>time.Time : Time.Now()</li>
<li>时间戳:
<ul>
<li>time.Now().Unix()</li>
<li>time.Now().UnixNano():1971.1.1到现在的纳秒数</li>
</ul>
</li>
</ul>
<h5 id="时间间隔类型">时间间隔类型</h5>
<ul>
<li>time.Duration ：时间间隔类型
<ul>
<li>time.Second</li>
<li>time.Hour</li>
<li>time.Minute</li>
</ul>
</li>
</ul>
<h5 id="时间操作">时间操作</h5>
<p>时间对象+-一个时间间隔对象</p>
<p>after 、 before</p>
<h5 id="时间格式化-1">时间格式化</h5>
<p>format</p>
<h5 id="定时器">定时器</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//定时器//tick := time.Tick(time.Second)//for  i := range tick {// fmt.Println(i)//}
</span></code></pre></div><h5 id="解析字符串格式的时间时区">解析字符串格式的时间（时区）</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">now</span><span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span><span class="c1">//获取的是当前时区的时间fmt.Println(now)//按照东八区的时区和格式解析一个字符串格式的时间time.Parse(&#34;2006-01-02 15:04:05&#34;, &#34;2021-08-11 21:33:05&#34;)//根据字符加载时区location, err := time.LoadLocation(&#34;Asia/Shanghai&#34;)if err!=nil {   fmt.Printf(&#34;load loc failed , err :%v\n&#34;,err)   return}//按照指定时区解析时间parseInLocation, err := time.ParseInLocation(&#34;2006-01-02 15:05:05&#34;, &#34;2021-08-11 21:33:05&#34;, location)fmt.Println(time.Now().Sub(parseInLocation))
</span></code></pre></div><h5 id="日志库-1">日志库</h5>
<p>time</p>
<p>文件操作</p>
<p>runtime.caller()</p>
<h5 id="反射-1">反射</h5>
<p>接口类型的变量分为两部分，动态类型和动态值。</p>
<p>反射的应用：json等数据解析 ORM等工具&hellip;</p>
<h5 id="反射的两个方法">反射的两个方法：</h5>
<ul>
<li>reflect.Typeof()</li>
<li>reflect.Valueof()</li>
</ul>
<h4 id="今日内容-2">今日内容</h4>
<h5 id="strconv标准库介绍">strconv标准库介绍</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;strconv&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">str</span><span class="o">:=</span><span class="s">&#34;1000&#34;</span>   <span class="nx">parseInt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="c1">//10进制 int64   if err != nil {      return   }   fmt.Printf(&#34;%T %v\n&#34;,parseInt,parseInt)   parseInt1, err := strconv.ParseInt(str,10,0)   if err != nil {      return   }   fmt.Printf(&#34;%T %v\n&#34;,parseInt1,parseInt1)   atoi,_:=strconv.Atoi(&#34;1000&#34;)//go语言继承c语言而来的 a是array 因为string底层实际上是array的byte数组 i是int   fmt.Println(atoi)   i :=97   fmt.Println(string(i))  //a   sprint := fmt.Sprint(i) //97   //字符串中解析出bool值   s2:=&#34;true&#34;   parseBool, _ := strconv.ParseBool(s2)   fmt.Println(parseBool)   fmt.Println(strconv.ParseFloat(&#34;2.14&#34;,32))   fmt.Println(sprint)}
</span></code></pre></div><h5 id="并发">并发</h5>
<p>并发是编程里面一个非常重要的概念，go语言在语言层面天生支持并发，这也是go语言流行的一个很重要的原因。</p>
<h5 id="go语言的并发编程">go语言的并发编程</h5>
<h5 id="并发与并行">并发与并行</h5>
<p>并发：同一时间段内执行多个任务</p>
<p>并行：同一时刻执行多个任务</p>
<p>go语言的并发通过goroutine实现。goroutine类似于线程，属于用户态的线程.我们可以根据需要创建成千上万个goroutine个并发工作。goroutine由go语言的运行时runtime调度完成，而线程是由操作系统调度完成的。</p>
<p>go语言还提供channel在多个goroutine间进行通信。goroutine和channel是go语言秉承CSP communication sequential  process 并发模式的重要实现基础.</p>
<h5 id="goutine">goutine</h5>
<p>在java和c++中我们要实现并发编程的时候,我们通常要自己维护一个线程池,并且需要自己去包装一个又一个任务,同时需要自己去调度线程执行任务并维护上下文切换,这一切通常会耗费程序员大量的心智.那么能不能有一种机制,程序员只需要定义很多个任务,让系统去帮助我们吧这些任务分配到CPU上实现并发执行呢?</p>
<p>go语言中的goroutine就是这样一种机制,goroutine的概念类似于线程,但goroutine是由go的运行时runtime调度和管理的.go程序会智能地将goroutine中的任务合理的分配给每个cpu.go语言之所以被成为现代化的编程语言,就是因为他在语言层面已经内置了调度和上下文切换的机制.</p>
<p>在go语言变成中你不需要自己去写进线程/线程/协程,你的技能包里只有一个技能 &mdash;- goroutine,当你需要让某个任务并发执行的时候,你只需要把这个任务包装成一个函数,开启一个goroutine去执行这个函数就可以了,就是这么简单粗暴.</p>
<h5 id="使用goroutine">使用goroutine</h5>
<p>go语言中使用goroutine非常简单,只需要在调用函数的时候在前面加上go关键字,就可以为一个函数创建一个goroutine</p>
<p>一个goroutine必定对应一个函数,可以创建多个goroutine去执行相同的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="c1">//程序启动之后会创建一个主goroutine去执行func main() {   for i := 0; i &lt; 10; i++ {      //go hello(i)  //开启一个单独的goroutine去执行hello函数（任务）      //匿名      //go func() {      // fmt.Println(i)      //}()  //闭包 会出现i外层是1 内部输出1 外部这时候已经跑到10了 那么这时候内部就输出10      //      go func(i int) {         fmt.Println(i)  //用的是函数参数的那个i ， 不再是外面的那个i了      }(i)   }   fmt.Println(&#34;main&#34;)   //main函数结束了 由main函数启动的goroutine也都结束了   time.Sleep(time.Second)}func hello(i int)  {   fmt.Println(&#34;hello&#34;,i)}
</span></code></pre></div><h5 id="goroutine什么时候结束">goroutine什么时候结束</h5>
<p>goroutine对应的函数执行结束 goroutine就结束了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;math/rand&#34;</span>   <span class="s">&#34;sync&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//waitGroup   //f1()   for i := 0; i &lt;10 ; i++ {      wg.Add(1)      go f2(i)   }   //如何知道这10个goroutine都结束了   wg.Wait()  //等待wg的计数器减为0}var wg sync.WaitGroupfunc f1() {   rand.Seed(time.Now().UnixNano())   for i := 0; i &lt; 5; i++ {      i1 := rand.Int()      i2 := rand.Intn(10)  //左开右闭      fmt.Println(i1,i2)   }}func f2(i int) {   time.Sleep(time.Millisecond*time.Duration(rand.Intn(300)))   fmt.Println(i)   defer wg.Done()}
</span></code></pre></div><h5 id="rand">rand</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="nx">i1</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span>      <span class="nx">i2</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1">//左开右闭      fmt.Println(i1,i2)   }}
</span></code></pre></div><h4 id="goroutine与线程">goroutine与线程</h4>
<h5 id="可增长的栈">可增长的栈</h5>
<p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB），一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和减小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大，所以在go语言中一次创建10w左右的goroutine也是可以的。</p>
<h5 id="goroutine调度">goroutine调度</h5>
<p>GMP是go语言运行时runtime层面的实现，是go语言自己实现的一套调度系统。区别与操作系统调度OS线程。</p>
<ul>
<li>G很好理解，就是个goroutine的，里面除了存放goroutine信息外 还有与所在P的绑定等信息</li>
<li>M machine是Go运行时runtine对操作系统内核线程的虚拟，M与内核线程一般是一一映射的关系，一个goroutine最终是要放到M上执行的</li>
<li>P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针、堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
</ul>
<p>P与M一般也是一一对应的。她们关系是：P管理着一组G挂载在M上运行。当一个G长久的阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时，回收掉旧的M</p>
<p>P的个数是通过runtime.GOMAXPROCS设定的，最大为256 go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话会得不偿失</p>
<p>单从线程调度讲，Go语言相比起来其他语言的优势在于OS线程是有OS内核来调度的。goroutine则是由Go运行时 runtime自己的调度器调度的。这个调度器使用一个成为m：n调度技术（复用/调度m个goroutine到n个OS线程）其一大特点是goroutine的调度是在用户态下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放都是在用户态维护着一大块的内存池，不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。另一方面充分利用了多核的硬件资源，近似的吧若干goroutine均分在物理线程上，再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h5 id="gomaxprocs">GOMAXPROCS</h5>
<p>go运行时的调度使用gomaxprocs参数来确定需要使用多少个OS线程来同时执行go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把go代码同时调度到8个OS线程上(GOMAXPROCS是m：n调度中的n)</p>
<p>go语言中可以通过runtime.gomaxprocs()函数来设定当前程序并发时占用的CPU逻辑核心数</p>
<p>go1.5版本之前，默认使用的是单核心执行。go1.5版本之后，默认使用全部的CPU逻辑核心数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;runtime&#34;</span>   <span class="s">&#34;sync&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroupfunc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1">//默认CPU的逻辑核心数，默认跑满整个CPU   fmt.Println(runtime.NumCPU())   wg.Add(2)   go a()   go b()   wg.Wait()}func a() {   for i := 0; i &lt; 10; i++ {      fmt.Printf(&#34;A:%d\n&#34;,i)   }   defer wg.Done()}func b() {   for i := 0; i &lt; 10; i++ {      fmt.Printf(&#34;B:%d\n&#34;,i)   }   defer wg.Done()}
</span></code></pre></div><h5 id="go语言中的操作系统线程和goroutine的关系">go语言中的操作系统线程和goroutine的关系</h5>
<ol>
<li>一个操作系统线程对应用户态多个goroutine</li>
<li>go程序可以同时使用多个操作系统线程</li>
<li>goroutine和OS线程是多对多的关系，即m:n</li>
</ol>
<h5 id="goroutine调度模型">goroutine调度模型</h5>
<p>GMP</p>
<p>m：n</p>
<p>goroutine初始栈的大小是2k</p>
<h5 id="channel">channel</h5>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行的意义</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，但这种做法势必造成性能问题。</p>
<p>go语言的并发模型是CSP communication sequential processes 提倡通过通信共享内存而不是通过共享内存而实现通信</p>
<p>如果说goroutine是go程序并发的执行体，channel就是他们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制</p>
<p>go语言中的通道channel是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出fifo的规则，保证收发数据的顺序。每一个通道都是具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h5 id="channel类型">channel类型</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">变量</span> <span class="kd">chan</span> <span class="nx">元素类型</span>
</code></pre></div><p>通道必须使用make函数初始化才能使用</p>
<h5 id="发送">发送</h5>
<p>将一个值发送到通道中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span> <span class="c1">//把10发送到ch
</span></code></pre></div><h5 id="接收">接收</h5>
<p>从一个通道接收值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span>  <span class="c1">//从ch中接收值并赋值&lt;- ch //从ch中接收值，忽略结果
</span></code></pre></div><h5 id="关闭">关闭</h5>
<p>我们通过调用内置的close函数来关闭通道</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</code></pre></div><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，他和关闭文件不一样，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic</li>
<li>对一个关闭的通道进行接收就会一直获取直到通道为空</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值</li>
<li>关闭一个已经关闭的通道会导致panic</li>
</ol>
<h5 id="无缓冲通道">无缓冲通道</h5>
<p>无缓冲的通道又称为阻塞的通道。无缓冲的通道只在有人接收值的时候才能发送值。无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这个值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被成为同步通道</p>
<h5 id="有缓冲通道">有缓冲通道</h5>
<p>在使用make初始化的时候为其指定通道的容量</p>
<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。</p>
<p>我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量</p>
<h5 id="如何优雅的从通道循环取值">如何优雅的从通道循环取值</h5>
<p>当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型的零值。那么如何判断一个通道是否被关闭了呢？</p>
<h5 id="单向通道">单向通道</h5>
<p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如只能发送或只能接收。go语言中提供了单向通道来处理这种情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ch1</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="c1">//只能取值var ch2 chan&lt;- //只能存值
</span></code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210813220847452.png" >
		<img src="/GoLearning.assets/image-20210813220847452.png"
			
			
			
			loading="lazy"
			alt="image-20210813220847452">
	</a>
	
	<figcaption>image-20210813220847452</figcaption>
	
</figure></p>
<h5 id="worker-pool-goroutine池">worker pool （goroutine池）</h5>
<p>编写代码实现一个计算随机数的每个位置数字之和的程序。要求使用goroutine和channel构建生产者和消费者模式，可以指定启动的goroutine数量-worker pool模式</p>
<p>在工作中我们通常会用worker pool模式，控制goroutine数量，防止goroutine泄漏和暴涨</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">jobs</span> <span class="kd">chan</span> <span class="nx">intvar</span> <span class="nx">results</span> <span class="kd">chan</span> <span class="nx">intfunc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">jobs</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">,</span> <span class="mi">100</span><span class="p">)</span>   <span class="nx">results</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">,</span> <span class="mi">100</span><span class="p">)</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">jobs</span><span class="p">,</span><span class="nx">results</span><span class="p">)</span>   <span class="p">}</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="nx">jobs</span><span class="o">&lt;-</span><span class="nx">i</span>   <span class="p">}</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="o">&lt;-</span><span class="nx">results</span>   <span class="p">}</span>   <span class="c1">//for result := range results {   // fmt.Println(result)   //}}func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {   for j := range jobs {      fmt.Println(&#34;worker &#34;,id,&#34; start job &#34;,j)      time.Sleep(time.Second)      results&lt;-2*j      fmt.Println(&#34;worker &#34;,id,&#34; end job&#34; , j)   }}
</span></code></pre></div><h5 id="练习">练习</h5>
<h5 id="select多路复用">select多路复用</h5>
<p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210813232439809.png" >
		<img src="/GoLearning.assets/image-20210813232439809.png"
			
			
			
			loading="lazy"
			alt="image-20210813232439809">
	</a>
	
	<figcaption>image-20210813232439809</figcaption>
	
</figure></p>
<p>这种方式虽然可以实现从多个通道接收值的要求，但是运行性能会差很多。为了应对这种场景，go内置了select关键字，可以同时响应多个通道的操作。select的使用类似于switch语句，他有一些case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210813232707904.png" >
		<img src="/GoLearning.assets/image-20210813232707904.png"
			
			
			
			loading="lazy"
			alt="image-20210813232707904">
	</a>
	
	<figcaption>image-20210813232707904</figcaption>
	
</figure></p>
<p>使用select语句能提高可读性</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作</li>
<li>如果有多个case同时满足，select会随机选择一个</li>
<li>对于没有case的select{}会一直等待，可用于阻塞main函数</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">mainimport</span> <span class="s">&#34;fmt&#34;</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">ch</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="k">select</span> <span class="p">{</span>      <span class="k">case</span> <span class="nx">x</span><span class="o">:=&lt;-</span><span class="nx">ch</span><span class="p">:</span>         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>      <span class="k">case</span> <span class="nx">ch</span><span class="o">&lt;-</span><span class="nx">i</span><span class="p">:</span>      <span class="k">default</span><span class="p">:</span>         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hiahiahia&#34;</span><span class="p">)</span>      <span class="p">}</span>   <span class="p">}}</span>
</code></pre></div><h5 id="并发安全和锁">并发安全和锁</h5>
<h5 id="作业">作业</h5>
<ol>
<li>日志库中channel怎么用</li>
<li>什么时候起后台的goroutine去写日志到文件中</li>
</ol>
<h4 id="day08">day08</h4>
<h5 id="今日内容-3">今日内容</h5>
<h5 id="并发のgoroutine">并发のgoroutine</h5>
<p>并发和并行的区别</p>
<p>goroutine的启动  <code>go</code></p>
<p>将并发执行的任务包装成一个函数，调用函数的时候前面加上go关键字，就能够开启一个goroutine去执行该函数</p>
<p>goroutine对应的函数执行完，该goroutine就结束了</p>
<p>程序启动的时候会自动的创建一个goroutine去执行main函数，main函数结束了那么程序就结束了所有开启的goroutine也都结束了</p>
<p>sync.waitGroup 等待组</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">waitGroupwg</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="nx">计数器</span><span class="o">+</span><span class="mi">1</span><span class="nx">wg</span><span class="p">.</span><span class="nf">done</span><span class="p">()</span><span class="err">：</span><span class="nx">计数器</span><span class="o">-</span><span class="mi">1</span><span class="nx">wg</span><span class="p">.</span><span class="nf">wait</span><span class="p">()</span><span class="err">：</span><span class="nx">等待</span>
</code></pre></div><h5 id="goroutine的本质">goroutine的本质</h5>
<p>goroutine的调度模型GMP</p>
<p>m：n 把m个goroutine分配给n个操作系统的线程</p>
<h5 id="goroutine与操作系统线程os的区别">goroutine与操作系统线程（OS）的区别</h5>
<p>goroutine是用户态的线程，比内核态的线程更轻量级一点，初始值2Kb</p>
<h5 id="runtimegomaxprocs">runtime.GOMAXPROCS()</h5>
<p>go1.5之后模式就是操作系统的逻辑核心数,默认跑满cpu</p>
<p>runtime.GOMAXPROCS(1)只占用一个核心</p>
<h5 id="work-pool-模式">work pool 模式</h5>
<p>开启一定数据的goroutine去干活。</p>
<h5 id="channel为什么需要">channel为什么需要</h5>
<p>想通过channel实现多个goroutine的通信</p>
<p>CSP ：通过通信来共享内存</p>
<p>channel是一种类型，一种引用类型。make函数初始化才能使用（slice  / map /channel）</p>
<p>channel的声明 var ch chan int</p>
<p>channel的初始化 make(chan 元素类型，[缓冲区大小])</p>
<p>channel的操作：</p>
<ul>
<li>
<p>发送&lt;-</p>
</li>
<li>
<p>接收&lt;-</p>
</li>
<li>
<p>关闭close</p>
</li>
</ul>
<p>带缓冲区的通道和无缓冲区的通道</p>
<h5 id="单向通道-1">单向通道</h5>
<p>通常是用做函数的参数，只读和只写</p>
<h5 id="select">select</h5>
<p>同一时刻有多个通道要操作的场景，使用select</p>
<h4 id="sync包">sync包</h4>
<h5 id="互斥锁">互斥锁</h5>
<p>互斥锁是一种常用的控制共享资源访问的方法，他能够保证同时只有一个goroutine可以访问资源，go语言中使用sync包的mutex类型来实现互斥锁。使用互斥锁来修复上面的代码</p>
<p>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁，当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的</p>
<h5 id="读写互斥锁">读写互斥锁</h5>
<p>互斥锁是完全互斥的，但是很多实际场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在go语言中使用sync包中的rwmutex类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获取锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p>
<h5 id="syncwaitgroup">sync.waitgroup</h5>
<p>在代码中生硬的使用time.sleep肯定是不合适的，go语言中可以使用sync.waitgroup来实现并发任务的同步</p>
<p>wg.add</p>
<p>wg.done</p>
<p>wg.wait</p>
<p>sync.waitgroup内部维护着一个计数器，计数器的值可以增加和减少。当我们启动了n个并发任务，就将计数器增加n，每个任务完成时通过调用done方法将计数器减一，通过调用wait来等待并发任务执行完，当计数器为0时，表示所有并发任务已经完成。</p>
<h5 id="synconce">sync.once</h5>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等</p>
<p>go语言中的sync包中提供了一个针对只执行一次场景的解决方案&ndash;sync.once</p>
<p>sync.once只有一个do方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span> <span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{}</span>
</code></pre></div><p>备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用</p>
<h5 id="syncmap">sync.map</h5>
<p>map并发多了之后执行就会报fatal error: concurrent map writes 错误</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，go语言的sunc包中提供了一个开箱即用的并发安全版map&mdash;-sync.map 开箱即用表示不用向内置map一样使用make函数初始化就能直接使用。同时sync.map内置了诸如store 、 load 、 loadorstore 、 delete 、 range等操作方案</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;strconv&#34;</span>   <span class="s">&#34;sync&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">wg</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span><span class="p">{}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>         <span class="nx">key</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>         <span class="nf">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>    <span class="c1">//必须使用sync.map内置的store方法设置键值对         fmt.Printf(&#34;k=%v v=%v\n&#34;,key,get(key)) //必须使用sync.map内置的load方法根据key取值         wg.Done()      }(i)   }   wg.Wait()}func set(key string , value int) {   m.Store(key,value)}func get(key string) interface{} {    value,_:=m.Load(key)    return value}
</span></code></pre></div><h5 id="atomic包">atomic包</h5>
<p>func loadint32</p>
<p>func storeint32</p>
<p>func addint32</p>
<p>func swapint32</p>
<p>func compareandswapint32</p>
<h4 id="网络编程">网络编程</h4>
<p>如何才能让我们的程序通过网络互相通信呢？本文只是演示了如何使用net包进行tcp和udp通信。</p>
<h5 id="互联网协议介绍">互联网协议介绍</h5>
<p>互联网的核心是一系列协议，总称为互联网协议internet protocol suite ， 正是这些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过复杂和庞大，只能介绍日常开发中接触较多的几个协议</p>
<h5 id="互联网分层模型">互联网分层模型</h5>
<p>互联网的逻辑实现被分为好几层。每一层都有自己的功能。互联网按照不同的模型划分会有不同的分层，但是不论是按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠经硬件。在软件开发中我们使用最多的是将互联网划分为五个分层的模型。</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210815154839385.png" >
		<img src="/GoLearning.assets/image-20210815154839385.png"
			
			
			
			loading="lazy"
			alt="image-20210815154839385">
	</a>
	
	<figcaption>image-20210815154839385</figcaption>
	
</figure></p>
<h5 id="物理层">物理层</h5>
<p>我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、 无线电波等方式。这就叫做“实物理层”，他就是把电脑连接起来的物理手段。他主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>
<h5 id="数据链路层">数据链路层</h5>
<p>单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：多少个电信号算一组？每个信号为有何意义？这就是数据链路层的功能，他在物理层的上方，确定了物理层传输0和1的分组方式及代表的意义。早起的时候，每家公司都有自己的电信号分组方式。逐渐的，一种叫做以太网ethernet的协议占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做帧frame。每一帧分为两部分：标头head和数据data。其中表头包含数据包的一些说明项，比如发送者、接收者、数据类型等等。数据则是数据包的具体内容。标头的长度固定为18字节。数据的长度最短为46字节，最长为1600字节。因此，整个帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<p>那么，发送者和接收者是如何标识的呢？以太网规定，连入网络的所有设备都必须具有网卡接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数来表示。前6个十六进制是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<p>我们会通过ARP协议来获取接收方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？ 其实这里以太网采用了一种很原始的方式，他不是把数据准确的送到接收方，而是向本网络内所有的计算机都发送，让每台计算机读取这个包的标头，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做广播broadcast</p>
<h5 id="网络层">网络层</h5>
<p>按照以太网协议的规则我们可以依靠MAC 地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在师姐另一个儿角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一包，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。</p>
<p>因此，必须找到一种方法区分那些MAC地址属于同一个子网络，那些不是。如果是同一个子网络，就采用广播方式发送，否则就采用路由方式发送。这就导致了网络层的诞生。他的作用是引进一套新的地址，使得我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址，简称网址</p>
<p>网络层出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包发送到该子网络中的目标网卡上。因此，从逻辑上可以推断，必定是先处理网络地址，然后在处理MAC地址。</p>
<p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4.IPv4这个版本规定，网络地址由32个二进制为组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255</p>
<p>根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为标头和数据两个部分：标头部分主要包括版本、长度、IP地址等信息，数据部分则是IP数据包的具体内容，IP数据包的标头部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p>
<h5 id="传输层">传输层</h5>
<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做端口port，他其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>端口是0到65535之间的整数，正好是16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。 有了IP和端口我们就能实现唯一确定互联网上的一个程序，进而实现网络间的程序通信。</p>
<p>我们必须在数据包中加入端口信息，这就是需要新的协议。最简单的实现叫做UDP协议，他的格式几乎就是在数据的前面，加上端口号。UDP数据包，也就是由标头和数据两部分组成：标头部分主要定义了发出端口和接收端口，数据部分就是具体的内容。UDP数据包非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据包。</p>
<p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这种问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。他的缺点是过程复杂、实现困难、消耗较多的资源、TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<h5 id="应用层">应用层</h5>
<p>应用程序收到传输层的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。应用层的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。</p>
<p>如图，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。<figure 
	>
	<a href="/GoLearning.assets/image-20210815163841064.png" >
		<img src="/GoLearning.assets/image-20210815163841064.png"
			
			
			
			loading="lazy"
			alt="image-20210815163841064">
	</a>
	
	<figcaption>image-20210815163841064</figcaption>
	
</figure></p>
<h4 id="socket编程">socket编程</h4>
<p>socket是BSD UNIX的进程通信机制，通常也称为套接字，用于描述IP地址和端口，是一个通信链的句柄。socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过套接字向网络发出请求或者应答网络的请求。</p>
<h5 id="socket图解">socket图解</h5>
<p>socket是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，socket其实就是一个门面模式，他把复杂的TCP/IP协议族隐藏在socket后面，对用户来说只需要调用socket规定的相关函数，让socket去组织符合指定的协议数据然后进行通信。</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210815165946914.png" >
		<img src="/GoLearning.assets/image-20210815165946914.png"
			
			
			
			loading="lazy"
			alt="image-20210815165946914">
	</a>
	
	<figcaption>image-20210815165946914</figcaption>
	
</figure></p>
<h4 id="go语言实现tcp通信">go语言实现TCP通信</h4>
<h5 id="tcp协议">TCP协议</h5>
<p>TCP/IP transmission control protocol 、 internet protocol即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据就像水流一样传输，会存在粘包问题。</p>
<h5 id="tcp服务端">TCP服务端</h5>
<p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p>
<p>TCP服务端程序的处理流程：</p>
<ol>
<li>监听端口</li>
<li>接收客户端请求建立链接</li>
<li>创建goroutine处理连接</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span><span class="p">)</span><span class="c1">//tcp server端func main() {   //1.本地端口启动服务   listen, err := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:20000&#34;)   if err != nil {      fmt.Println(&#34;start server on 127.0.0.1:20000 failed , err : &#34;,err)      return   }   for {      //2.等待别人来跟我连接      accept, err := listen.Accept()      if err != nil {         fmt.Println(&#34;build connect failed , err : &#34;,err)         return      }      go func(conn net.Conn) {         for {            //3.与客户端通信            var temp [128]byte            read, err := conn.Read(temp[:])            if err != nil {               fmt.Println(&#34;attemp read failed , err : &#34;,err)               return            }            fmt.Println(string(temp[:read]))         }      }(accept)   }}
</span></code></pre></div><p>client</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;bufio&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span>   <span class="s">&#34;os&#34;</span><span class="p">)</span><span class="c1">//tcp clientfunc main() {   //1.与server建立连接   dial, err := net.Dial(&#34;tcp&#34;, &#34;127.0.0.1:20000&#34;)   if err != nil {      fmt.Println(&#34;dial 127.0.0.1:20000 failed , err : &#34;,err)      return   }   //2.发送数据   //var write1 = make([]byte,100)   //if len(os.Args)&lt;2 {   // write1 = []byte(&#34;hello world&#34;)   //}else {   // write1 = []byte(os.Args[1])   //}   for {      reader := bufio.NewReader(os.Stdin)      //dial.Write(write1)      line, _ := reader.ReadString(&#39;\n&#39;)      if string(line)==&#34;exit&#34; {         break      }      dial.Write([]byte(line))   }   dial.Close()}
</span></code></pre></div><h5 id="tcp黏包">TCP黏包</h5>
<p>黏包可发生在发送端也可发生在接收端：</p>
<ol>
<li>由Nagle算法造成的发送端的黏包：nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，如有会一次把这两段数据发送出去。</li>
<li>接收端接收不及时造成的接收端黏包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 <figure 
	>
	<a href="/GoLearning.assets/image-20210816200320281.png" >
		<img src="/GoLearning.assets/image-20210816200320281.png"
			
			
			
			loading="lazy"
			alt="image-20210816200320281">
	</a>
	
	<figcaption>image-20210816200320281</figcaption>
	
</figure></li>
</ol>
<p>server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">dial</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:30000&#34;</span><span class="p">)</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial failed , error : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="k">defer</span> <span class="nx">dial</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="nx">dial</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;how are you , hello !&#34;</span><span class="p">))</span>   <span class="p">}}</span>
</code></pre></div><p>server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;io&#34;</span>   <span class="s">&#34;net&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">listen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:30000&#34;</span><span class="p">)</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen port failed , err : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="k">defer</span> <span class="nx">listen</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>   <span class="k">for</span> <span class="p">{</span>      <span class="nx">accept</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listen</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;connect accept failed , err :&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>         <span class="k">return</span>      <span class="p">}</span>      <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>         <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>         <span class="k">for</span>  <span class="p">{</span>            <span class="kd">var</span> <span class="nx">b</span>  <span class="p">[</span><span class="mi">1024</span><span class="p">]</span><span class="kt">byte</span>            <span class="nx">read</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">[:])</span>            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>               <span class="k">break</span>            <span class="p">}</span>            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>               <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;try to read failed , err : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>               <span class="k">return</span>            <span class="p">}</span>            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received data : &#34;</span><span class="p">,</span><span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">[:</span><span class="nx">read</span><span class="p">]))</span>         <span class="p">}</span>      <span class="p">}(</span><span class="nx">accept</span><span class="p">)</span>   <span class="p">}}</span>
</code></pre></div><h5 id="解决方法">解决方法</h5>
<p>出现黏包的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p>
<p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了（过滤非法包时封包会加入”包尾“内容）。包头部分的长度是固定的，并且他存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p>
<p>我们可以自己定义一个协议，比如数据包的前四个字节为包头，里面存储的是发送的数据的长度。</p>
<p>大端小端模式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span>   <span class="s">&#34;src/code.oldboyedu.com/day8/11nianbao_jiejue/protocol&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">dial</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:30000&#34;</span><span class="p">)</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;dial failed , error : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="k">defer</span> <span class="nx">dial</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>      <span class="nx">encode</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">protocol</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="s">&#34;how are you , hello!&#34;</span><span class="p">)</span>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>         <span class="k">return</span>      <span class="p">}</span>      <span class="nx">dial</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">encode</span><span class="p">)</span>      <span class="c1">//dial.Write([]byte(&#34;how are you , hello !&#34;))   }}
</span></code></pre></div><p>protocol</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">protocolimport</span> <span class="p">(</span>   <span class="s">&#34;bufio&#34;</span>   <span class="s">&#34;bytes&#34;</span>   <span class="s">&#34;encoding/binary&#34;</span><span class="p">)</span><span class="c1">//Encode 将消息编码func Encode(message string )([]byte,error) {   //读取消息的长度，转换为int32   length := int32(len(message))   pkg := new(bytes.Buffer)   //写入消息头   err := binary.Write(pkg, binary.LittleEndian, length)   if err != nil {      return nil, err   }   //写入消息体   err1 := binary.Write(pkg, binary.LittleEndian, []byte(message))   if err1 != nil {      return nil, err1   }   return pkg.Bytes(),err}//Decode 解码消息func Decode(reader *bufio.Reader) (string, error) {   //读取消息的长度   peek, err := reader.Peek(4)   if err != nil {      return &#34;&#34;, err   } //读取前四个字节的数据   buffer := bytes.NewBuffer(peek)   var length int32   err1 := binary.Read(buffer, binary.LittleEndian, &amp;length)   if err1 != nil {      return &#34;&#34;, err1   }   //Buffered 返回缓冲区中现有的可读取的字节数   if int32(reader.Buffered()) &lt; length+4 {      return &#34;&#34; , err   }   //读取真正的消息数据   pack:=make([]byte,int(4+length))   _,err2:=reader.Read(pack)   if err2!=nil {      return &#34;&#34;,err2   }   return string(pack[4:]),nil}
</span></code></pre></div><p>server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;bufio&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span>   <span class="s">&#34;src/code.oldboyedu.com/day8/11nianbao_jiejue/protocol&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">listen</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:30000&#34;</span><span class="p">)</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen port failed , err : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="k">defer</span> <span class="nx">listen</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>   <span class="k">for</span> <span class="p">{</span>      <span class="nx">accept</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listen</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;connect accept failed , err :&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>         <span class="k">return</span>      <span class="p">}</span>      <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>         <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>         <span class="k">for</span>  <span class="p">{</span>            <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>            <span class="nx">decode</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">protocol</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">reader</span><span class="p">)</span>            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>               <span class="k">return</span>            <span class="p">}</span>            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received data : &#34;</span><span class="p">,</span><span class="nx">decode</span><span class="p">)</span>         <span class="p">}</span>      <span class="p">}(</span><span class="nx">accept</span><span class="p">)</span>   <span class="p">}}</span>
</code></pre></div><h5 id="udp协议">UDP协议</h5>
<p>UDP协议 user datagram protocol中文名称是用户数据报协议，是OSI open system interconnection ， 开放式系统互联，参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的，没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域</p>
<h5 id="udp服务端">UDP服务端</h5>
<p>server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span>   <span class="s">&#34;strings&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">udp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenUDP</span><span class="p">(</span><span class="s">&#34;udp&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">UDPAddr</span><span class="p">{</span>      <span class="nx">IP</span><span class="p">:</span>   <span class="nx">net</span><span class="p">.</span><span class="nf">IPv4</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>      <span class="nx">Port</span><span class="p">:</span> <span class="mi">40000</span><span class="p">,</span>   <span class="p">})</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen failed , error : &#34;</span><span class="p">,</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>    <span class="p">}</span>   <span class="c1">//不需要建立链接，直接收发数据   var b [1024]byte   defer udp.Close()   for  {      n, addr, err := udp.ReadFromUDP(b[:])      if err != nil {         fmt.Println(&#34;read from udp failed , err: &#34; , err)         return      }      fmt.Println(b[:n])      reply:=strings.ToUpper(string(b[:n]))      //发送数据      udp.WriteToUDP([]byte(reply),addr)   }}
</span></code></pre></div><p>client</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;bufio&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;net&#34;</span>   <span class="s">&#34;os&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//UDP client   socket, err := net.DialUDP(&#34;udp&#34;,nil,&amp;net.UDPAddr{      IP:   net.IPv4(127, 0, 0, 1),      Port: 40000,   })   if err != nil {      fmt.Println(&#34;dial failed , error : &#34;,err)      return   }   defer  socket.Close()   reader := bufio.NewReader(os.Stdin)   var reply [1024]byte   for {      readString, err := reader.ReadString(&#39;\n&#39;)      if err != nil {         return      }      socket.Write([]byte(readString))      //收回复的数据      n, adder, err := socket.ReadFromUDP(reply[:])      if err != nil {         return      }      fmt.Println(&#34;received data: ,addr :    &#34;,string(reply[:n]),adder)   }}
</span></code></pre></div><h4 id="day09">day09</h4>
<p>日志收集项目</p>
<p>gin框架和微服务</p>
<p>docker和k8s</p>
<h4 id="今日分享">今日分享</h4>
<p>注释/日志/单元测试</p>
<h4 id="今日内容-4">今日内容</h4>
<p>context</p>
<p>单元测试</p>
<p>pprof调试工具</p>
<h4 id="内容回顾-5">内容回顾</h4>
<h5 id="互斥锁-1">互斥锁</h5>
<p>sync.mutex</p>
<p>是一个结构体 是值类型 。给函数传参数的时候要传指针</p>
<p>lock 和 unlock</p>
<h5 id="为什么要用锁">为什么要用锁</h5>
<p>防止同一时刻多个goroutine操作同一资源</p>
<h5 id="读写互斥锁-1">读写互斥锁</h5>
<p>适用于读多写少的场景下,才能提高程序的执行效率</p>
<p>特点:</p>
<ol>
<li>如果是读的人来获取的是读锁,后续的goroutine能读不能写</li>
<li>如果是写的goroutine来了,获取的是写锁,后续的goroutine不管是读还是写,都要等待获取锁</li>
</ol>
<p>rwlock.rlock()</p>
<p>rwlock.wlock()</p>
<p>rwlock.lock()</p>
<p>rwlock.unlock()</p>
<h5 id="等待组">等待组</h5>
<p>sync.waitgroup</p>
<p>用来等goroutine执行完再继续</p>
<p>是一个结构体,是值类型,给函数传参数的时候要传指针</p>
<p>wg.add()</p>
<p>wg.done()</p>
<p>wg.wait()</p>
<h5 id="synconce-1">sync.Once</h5>
<p>使用场景</p>
<p>某些函数只需要执行一次的时候，就可以使用sync.once</p>
<p>once.Do(func ( ) )</p>
<p>接收无参数无返回值的函数参数</p>
<h5 id="syncmap-1">sync.Map</h5>
<p>使用场景</p>
<p>并发操作一个map的时候，内置的map不是并发安全的</p>
<p>使用，是一个开箱即用的(不需要make）并发安全的map</p>
<p>var map sync.Map</p>
<p>load()</p>
<p>store()</p>
<p>loadorstore()</p>
<p>delete()</p>
<p>range()</p>
<h5 id="原子操作">原子操作</h5>
<p>go语言内置了一些针对内置的基本数据类型的一些并发安全的操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int64</span> <span class="p">=</span><span class="mi">10</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">addint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><h5 id="网络编程-1">网络编程</h5>
<h5 id="互联网协议">互联网协议</h5>
<p>OIS七层模型</p>
<p>应用层 表示层  会话层 传输层 网络层 数据链路层 物理层</p>
<h4 id="http客户端和服务端">HTTP客户端和服务端</h4>
<p>go语言内置的net/http包提供了http客户端和服务端的实现</p>
<h5 id="http协议">HTTP协议</h5>
<p>超文本传输协议HTTP hypertext transfer protocol 是互联网上应用最为广泛的一种网络传输协议，所有www文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<h5 id="http客户端">HTTP客户端</h5>
<p>使用net / http 包编写一个简单的发送HTTP请求的client端</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210817000221229.png" >
		<img src="/GoLearning.assets/image-20210817000221229.png"
			
			
			
			loading="lazy"
			alt="image-20210817000221229">
	</a>
	
	<figcaption>image-20210817000221229</figcaption>
	
</figure></p>
<p>HTTP：超文本传输协议</p>
<p>规定了：浏览器和网站服务器之间通信的规则</p>
<p>HTML：超文本标记语言</p>
<p>学的就是标记的符号、标签</p>
<p>CSS：层叠样式表</p>
<p>规定了HTML中标签的具体样式（颜色、背景、大小、位置、浮动&hellip;）</p>
<p>JS：一种跑在浏览器上的编程语言</p>
<p>http_server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>	<span class="s">&#34;fmt&#34;</span>	<span class="s">&#34;io/ioutil&#34;</span>	<span class="s">&#34;net/http&#34;</span><span class="p">)</span><span class="c1">//net / http serverfunc main() {	http.HandleFunc(&#34;/posts/go/15_socket/&#34;,f1)	http.HandleFunc(&#34;/xxx/&#34;,f2)	http.ListenAndServe(&#34;127.0.0.1:9090&#34;,nil)}func f2(writer http.ResponseWriter, request *http.Request) {	//对于get请求 参数都放在URL上 （query param）请求体中是没有数据的	fmt.Println(request.URL)	fmt.Println(request.Method)	fmt.Println(ioutil.ReadAll(request.Body))	writer.Write([]byte(&#34;ok!&#34;))	queryParam :=request.URL.Query()	fmt.Println(queryParam)	name:=queryParam.Get(&#34;name&#34;)	fmt.Println(name)	age:=queryParam.Get(&#34;age&#34;)	fmt.Println(age)}func f1(w http.ResponseWriter, r *http.Request) {	file, err := ioutil.ReadFile(&#34;./xx.txt&#34;)	if err != nil {		w.Write([]byte(fmt.Sprintf(&#34;%v&#34;,err)))		return	}	w.Write(file)}
</span></code></pre></div><p>http_client</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;io/ioutil&#34;</span>   <span class="s">&#34;net/http&#34;</span>   <span class="s">&#34;net/url&#34;</span><span class="p">)</span><span class="c1">//net/http clientfunc main() {   f1()   f2()   f3()}//构造一个clientvar client= http.Client{ Transport: &amp;http.Transport{            DisableKeepAlives:false}}func f3() {   //构造参数   urlparams := url.Values{}   urlparams.Add(&#34;name&#34;,&#34;ljs&#34;)   urlparams.Add(&#34;score&#34;,&#34;100&#34;)   //构造头部   urlParse, _ := url.ParseRequestURI(&#34;http://127.0.0.1:9090/xxx&#34;)   //拼接url   urlParse.RawQuery = urlparams.Encode()   //构造一个请求 request   request, _ := http.NewRequest(&#34;get&#34;, urlParse.String(), nil)   response, _ := client.Do(request)   defer response.Body.Close()   ioutil.ReadAll(response.Body)}func f2() {   //构造请求   uri, _ := url.ParseRequestURI(&#34;http://127.0.0.1:9090/xxx&#34;)   data:=url.Values{}   data.Set(&#34;name&#34;,&#34;林の树&#34;)   data.Set(&#34;age&#34;,&#34;18&#34;)   urlStr := data.Encode()   fmt.Println(urlStr)   uri.RawQuery=urlStr   fmt.Println(uri)   request, err := http.NewRequest(&#34;Get&#34;, uri.String(), nil)   if err != nil {      fmt.Println(&#34;request failed ,error : &#34;,err)      return   }   //发请求   response, err := http.DefaultClient.Do(request)   if err != nil {      return   }   defer response.Body.Close()  //一定要记得关闭resp.body   all, err := ioutil.ReadAll(response.Body)   if err != nil {      return   }   fmt.Println(string(all))}func f1() {   response, err := http.Get(&#34;http://127.0.0.1:9090/xxx?name=ljs&amp;age=18&#34;)   if err != nil {      fmt.Println(&#34;get failed , error : &#34;,err)      return   }   //从response中吧服务端返回的数据读出来   read, err := ioutil.ReadAll(response.Body)   if err != nil {      fmt.Println(&#34;read failed , error : &#34;,err )      return   }   fmt.Println(string(read))}
</span></code></pre></div><p>http.get</p>
<p>http.post</p>
<p>http.postform</p>
<h5 id="单元测试">单元测试</h5>
<p>开发自己给自己的代码写测试</p>
<p>go语言中的测试依赖go test命令。编写测试代码和编写普通的go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>
<p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build 编译到最终的可执行文件中。</p>
<p>在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>测试函数</td>
<td>函数名前缀为test</td>
<td>测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td>基准函数</td>
<td>函数名前缀为benchmark</td>
<td>测试函数的性能</td>
</tr>
<tr>
<td>示例函数</td>
<td>函数名前缀为example</td>
<td>为文档提供实力文档</td>
</tr>
</tbody>
</table>
<p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件</p>
<h5 id="测试函数">测试函数</h5>
<p>测试函数的格式 每个测试函数必须导入testing包，基本格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestName</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>    <span class="p">}</span><span class="c1">//testing.T拥有的方法如下ErrorErrorfFailFailNowFailedFatalFatalfLogLogfNameParallelRunSkipSkipNowSkipfSkipped
</span></code></pre></div><h5 id="测试用例和测试组和子测试">测试用例和测试组和子测试</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;strings&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="c1">//Split 切割字符串 a b c =&gt; [a c]func Split(str ,sep string) []string {      i:=0      judge(str,sep,i)      return m}func judge(s string,sep string,i int)  {   if !strings.Contains(s,sep){      return   }   index:=strings.Index(s,sep)   if s[:index] != &#34;&#34; {      m[i] = s[:index]   }else {      m[i]=s[index+1:]   }   if s[index+1:]!=&#34;&#34; {      m[i+1] = s[index+1:]   }   judge(m[i+1],sep,i+1)}func main() {   got:=Split(&#34;abcb&#34;,&#34;b&#34;)   fmt.Println(got)}
</span></code></pre></div><p>测试用例写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;reflect&#34;</span>   <span class="s">&#34;testing&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>   <span class="nx">got</span><span class="o">:=</span><span class="nf">Split</span><span class="p">(</span><span class="s">&#34;abcb&#34;</span><span class="p">,</span><span class="s">&#34;b&#34;</span><span class="p">)</span>   <span class="nx">want</span><span class="o">:=</span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;c&#34;</span><span class="p">,</span><span class="s">&#34; &#34;</span><span class="p">}</span>   <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;测试用例失败&#34;</span><span class="p">)</span>      <span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;want %v but got %v\n&#34;</span><span class="p">,</span><span class="nx">want</span><span class="p">,</span><span class="nx">got</span><span class="p">)</span>   <span class="p">}}</span><span class="kd">func</span> <span class="nf">TestSplit2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>   <span class="nx">got</span><span class="o">:=</span><span class="nf">Split</span><span class="p">(</span><span class="s">&#34;a:b:c&#34;</span><span class="p">,</span><span class="s">&#34;:&#34;</span><span class="p">)</span>   <span class="nx">want</span><span class="o">:=</span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;b&#34;</span><span class="p">,</span><span class="s">&#34;c&#34;</span><span class="p">}</span>   <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;want %v but got %v\n&#34;</span><span class="p">,</span><span class="nx">want</span><span class="p">,</span><span class="nx">got</span><span class="p">)</span>   <span class="p">}}</span><span class="c1">//测试组func TestSplitGroup(t *testing.T) {   type TestCase struct {      str string      sep string      got string      want []string   }   testCase :=[]TestCase{      {         str:  &#34;abcb&#34;,         sep:  &#34;b&#34;,         want: []string{&#34;a&#34;,&#34;c&#34;,&#34;&#34;},      },      {         str:&#34;a:b:c&#34;,         sep: &#34;:&#34;,         want:[]string{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;},      },   }   for _, v := range testCase {      if !reflect.DeepEqual(Split(v.str,v.sep),v.want){         t.Errorf(&#34;want %v but got %v\n&#34;,v.want,Split(v.str,v.sep))      }   }}func TestSingle(t *testing.T) {   type TestCase struct {      str string      sep string      got string      want []string   }   testCase:=map[string]TestCase{      &#34;case1&#34;:{         str:  &#34;abcb&#34;,         sep:  &#34;b&#34;,         want: []string{&#34;a&#34;,&#34;c&#34;,&#34;&#34;},      },      &#34;case2&#34;:{         str:&#34;a:b:c&#34;,         sep: &#34;:&#34;,         want:[]string{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;},      },   }   for name, v := range testCase {      t.Run(name, func(t *testing.T) {         got:=Split(v.str,v.sep)         if !reflect.DeepEqual(got, v.want) {            t.Errorf(&#34;want %v but got %v\n&#34;,v.want,got)         }      })   }}
</span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">尝试新的跨平台 PowerShell https://aka.ms/pscore6PS E:<span class="se">\p</span>roject<span class="se">\G</span>Oproject<span class="se">\s</span>rc<span class="se">\c</span>ode.oldboyedu.com<span class="se">\d</span>ay9<span class="se">\0</span>2splitString&gt; go <span class="nb">test</span> -run<span class="o">=</span>TestSingle/case2--- FAIL: TestSingle <span class="o">(</span>0.00s<span class="o">)</span>    --- FAIL: TestSingle/case2 <span class="o">(</span>0.00s<span class="o">)</span>        split_test.go:77: want <span class="o">[</span>a b c<span class="o">]</span> but got <span class="o">[</span>a b c <span class="o">]</span>FAILexit status 1FAIL    src/code.oldboyedu.com/day9/02splitString       0.240s
</code></pre></div><h5 id="测试覆盖率">测试覆盖率</h5>
<p>go test -cover</p>
<p>函数覆盖率100%</p>
<p>代码覆盖率60%</p>
<h5 id="基准测试">基准测试</h5>
<p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<p>func BenchName(b *testing.B)</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210818211645228.png" >
		<img src="/GoLearning.assets/image-20210818211645228.png"
			
			
			
			loading="lazy"
			alt="image-20210818211645228">
	</a>
	
	<figcaption>image-20210818211645228</figcaption>
	
</figure></p>
<h5 id="性能比较测试">性能比较测试</h5>
<p>默认情况下每个基准测试至少运行1s，如果在benchmark函数 返回时没有到1s，则b.N的值会按1,2,5,50&hellip;增加,并且函数再次运行</p>
<p>可以指定benchtime</p>
<h5 id="重置时间">重置时间</h5>
<p>b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。</p>
<h5 id="并行测试">并行测试</h5>
<p>runparallel会以并行的方式执行给定的基准测试</p>
<p>可以调用setparallelism来确定cpu核数</p>
<h5 id="setup和teardown">setUp和teardown</h5>
<p>测试程序有时需要在测试之前进行额外的设置setup或者在测试之后进行拆卸teardown</p>
<h5 id="示例函数">示例函数</h5>
<p>ExampleName</p>
<h5 id="prof调试工具">prof调试工具</h5>
<p>go语言项目中的性能优化主要有以下几个方面：</p>
<ul>
<li>CPU profile：报告程序的CPU使用情况，按照一定频率去采集应用程序在CPU和寄存器上面的数据</li>
<li>Memory Profile (Heap Profile) :报告程序的内存使用情况</li>
<li>Block Profiling: 报告goroutines不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li>
<li>Goroutine Profiling:报告goroutines的使用情况，有那些goroutine，她们的调用关系是怎么样的</li>
</ul>
<h5 id="采集性能数据">采集性能数据</h5>
<p>go语言内置了获取程序的运行数据的工具，包括一下两个标准库</p>
<ul>
<li>runtime/pprof:采集工具型应用运行数据进行分析</li>
<li>net/http/pprof:采集服务型应用运行时数据进行分析</li>
</ul>
<p>pprof开机后，每个一段时间10ms就会收集当前的堆栈信息，获取各个函数占用的cpu以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p>
<p>注意，我们只应该在性能测试的时候才在代码中引入pprof</p>
<h5 id="cpu性能分析">CPU性能分析</h5>
<p>pprof.StartCPUProfile(w io.Writer)</p>
<p>pprof.stopCPUPorfile()</p>
<p>应用执行结束后，就会生成一个文件，保存了我们的CPUprofiling数据。得到采样数据之后，使用go tool pprof工具进行CPU性能分析</p>
<p>等待30s</p>
<h5 id="内存性能优化">内存性能优化</h5>
<p>pprof.WriteHeapProfile(w io.Writer)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;flag&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;os&#34;</span>   <span class="s">&#34;runtime/pprof&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="kd">var</span> <span class="nx">isCPUPprof</span> <span class="kt">bool</span>  <span class="c1">//是否开启cpuprofile标志位   var isMemPprof bool    //是否开启内存profile标志位   flag.BoolVar(&amp;isCPUPprof,&#34;cpu&#34;,false,&#34;turn cpu pprof on&#34;)   flag.BoolVar(&amp;isMemPprof,&#34;mem&#34;,false,&#34;turn mem pprof on&#34;)   flag.Parse()   if isCPUPprof {      create, err := os.Create(&#34;./cpu.pprof&#34;)      if err != nil {         fmt.Println(&#34;create file failed , error : &#34;,err)         return      }      pprof.StartCPUProfile(create)  //往文件中记录cpu profile信息      defer create.Close()      defer pprof.StopCPUProfile()   }   for i := 0; i &lt; 6; i++ {      go logicCode()   }   time.Sleep(20*time.Second)   if isMemPprof{      create, err := os.Create(&#34;./mem.pprof&#34;)      if err != nil {         fmt.Println(&#34;create file failed , error : &#34;,err)         return      }      pprof.WriteHeapProfile(create)      defer create.Close()   }}func logicCode() {   var c chan int //nil   for {      select {         case v:=&lt;-c: //阻塞            fmt.Printf(&#34;received from chan , value : %v\n&#34;,v)      default:            time.Sleep(time.Millisecond*500)      }   }}
</span></code></pre></div><h5 id="命令行交互界面">命令行交互界面</h5>
<p>使用go工具链里的pprof来分析一下</p>
<h5 id="服务型应用">服务型应用</h5>
<h5 id="flag">flag</h5>
<p>通过flag.string or flag.stringvar 定义好命令行flag参数后，需要通过调用flag.parse()来对命令行参数进行解析</p>
<p>支持的命令行参数格式有以下几种</p>
<ul>
<li>-flage xxx</li>
<li>&ndash;flag xxx</li>
<li>-flag=xxx</li>
<li>&ndash;flag=xxx</li>
</ul>
<p>其中，布尔类型的参数必须使用等号方式指定</p>
<p>flag解析在第一个非flag参数之前停止 或者在终止符-之后停止</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;flag&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="c1">//flag 获取命令行参数func main() {   //创建一个标志位参数flag   name :=flag.String(&#34;name&#34;,&#34;ljs&#34;,&#34;请输入名字&#34;)   age :=flag.Int(&#34;age&#34;,100,&#34;请输入年龄&#34;)   married :=flag.Bool(&#34;married&#34;,false,&#34;结婚了么&#34;)   cTime:=flag.Duration(&#34;duration&#34;,time.Second,&#34;有多快&#34;)   //使用flag   //flag.Parse()   fmt.Println(*name)   fmt.Println(*age)   fmt.Println(*married)   fmt.Println(*cTime)   var name1 string   flag.StringVar(&amp;name1,&#34;name1&#34;,&#34;name1&#34;,&#34;请输入name1&#34;)   flag.Parse()   fmt.Println(name1)   fmt.Println(flag.NArg())  //返回除了规定的参数之外的命令行参数有几个   fmt.Println(flag.NFlag())  //返回规定的flag命令行参数有几个   fmt.Println(flag.Args())   //返回除了规定的参数之外的命令行参数具体是}
</span></code></pre></div><h5 id="面试题">面试题</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210819001237778.png" >
		<img src="/GoLearning.assets/image-20210819001237778.png"
			
			
			
			loading="lazy"
			alt="image-20210819001237778">
	</a>
	
	<figcaption>image-20210819001237778</figcaption>
	
</figure></p>
<h5 id="本周复习">本周复习</h5>
<p>两个面试题</p>
<p>leetcode刷题每天一道题</p>
<p>数据结构和算法很重要，要找机会抓紧补上</p>
<h5 id="内容回顾-6">内容回顾</h5>
<h5 id="nethttp包的用法">net/http包的用法</h5>
<p>如何发请求</p>
<p>当需要频繁发送请求的时候（每5s从阿里云接口同步数据）：定义一个全局的client，后续发请求的操作都使用这个全局的client</p>
<h5 id="单元测试-1">单元测试</h5>
<p>xxx/ccc.go</p>
<p>单元测试的文件名必须是xxx/ccc_test.go</p>
<p>go内置的单元测试工具：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span>
</code></pre></div><p>单元测试函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//Test开头后接函数名func TestSplit(t *testing.T){    }
</span></code></pre></div><h5 id="性能测试基准测试">性能测试/基准测试</h5>
<p>函数格式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkSplit</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">){</span>    <span class="c1">//b.N:被测试函数执行的次数}
</span></code></pre></div><p>执行命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">bench</span><span class="p">=</span><span class="nx">Split</span> <span class="o">-</span><span class="nx">v</span>
</code></pre></div><h5 id="并行测试-1">并行测试</h5>
<h5 id="setup和teardown-1">setup和teardown</h5>
<h5 id="pprof">pprof</h5>
<p>记录cpu和内存的快照信息</p>
<h5 id="flag标准库">flag标准库</h5>
<p>os.Args</p>
<p>flag.stringvar()返回的是一个指针变量</p>
<p>必须调用flag.parse()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">./xxx -name <span class="o">=</span> <span class="s2">&#34;lsj&#34;</span> -age<span class="o">=</span><span class="m">90</span>
</code></pre></div><p>flag.args</p>
<p>flag.nargs</p>
<p>flag.nflag</p>
<h4 id="今日内容-5">今日内容</h4>
<p>Mysql：主流的关系型数据库 类似的还有postgreSQL</p>
<p>redis：kv数据库</p>
<p>nsq:go语言开发的分布式消息队列</p>
<p>包的依赖管理go module     go1.1之后官方出的依赖管理工具</p>
<h5 id="mysql">MySql</h5>
<p>数据库</p>
<p>常见的数据库：oracle sqlite文件数据库 mysql sqlserver</p>
<p>关系型数据库：用表来存一类数据</p>
<p>表结构设计的三大范式《漫画数据库》</p>
<p>mysql知识点</p>
<p>sql语句：结构化查询语言</p>
<h5 id="存储引擎">存储引擎</h5>
<p>mysql支持插件式的存储引擎</p>
<p>常见的存储引擎：myisam、innodb</p>
<p>myisam：</p>
<ul>
<li>查询速度快</li>
<li>只支持表锁</li>
<li>不支持事务</li>
</ul>
<p>innodb：</p>
<ul>
<li>整体速度快</li>
<li>支持表锁和行锁</li>
<li>支持事务</li>
</ul>
<p>事务：把多个操作当成一个整体</p>
<p>事务的特点：</p>
<p>ACID</p>
<ul>
<li>原子性：事务要么成功，要么失败，没有中间状态</li>
<li>一致性：数据库的完整性没有被破坏</li>
<li>持久性：事务操作的结果是不会被丢失的</li>
<li>隔离性：事务之间是相互隔离的
<ul>
<li>隔离级别
<ul>
<li>读未提交</li>
<li>读提交</li>
<li>可重复读</li>
<li>串行化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="索引">索引</h5>
<p>索引的原理是：B树和B+树</p>
<p>索引类型：</p>
<p>索引的命中</p>
<p>分库分表</p>
<p>SQL注入</p>
<p>SQL慢查询优化</p>
<p>Mysql主从：binlog</p>
<p>Mysql读写分离</p>
<h5 id="go操作mysql">Go操作MySql</h5>
<h5 id="连接">连接</h5>
<p>go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入至少一个数据库驱动。</p>
<p>我们常用的数据库基本上都有完整的第三方实现。</p>
<h5 id="databasesql">database/sql</h5>
<p>原生支持连接池，是并发安全的</p>
<p>这个标准库没有具体实现，只是列出了一些需要第三方库实现的具体内容。</p>
<h5 id="下载依赖">下载依赖</h5>
<p>go get -u github.com/go-sql-driver/mysql</p>
<h5 id="使用mysql驱动">使用Mysql驱动</h5>
<p>func Open(driverName , dataSourceName string)(*DB , error)</p>
<p>open一个drivername指定的数据库，datasourcename指定数据源，一般包至少包括</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210820105514841.png" >
		<img src="/GoLearning.assets/image-20210820105514841.png"
			
			
			
			loading="lazy"
			alt="image-20210820105514841">
	</a>
	
	<figcaption>image-20210820105514841</figcaption>
	
</figure></p>
<p>go get包的路径就是下载第三方的依赖</p>
<p>将第三方的依赖默认保存在$gopath/src/</p>
<h5 id="使用驱动">使用驱动</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;database/sql&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>   <span class="s">&#34;log&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//go连接mysql实例   //数据库源信息   dsn:=&#34;root:123456@tcp(127.0.0.1:3306)/tset&#34;   //连接数据库   db, err := sql.Open(&#34;mysql&#34;, dsn) //不会校验用户名和密码是否正确   if err != nil {      log.Printf(&#34;dsn %s invalid , err : %v\n&#34;,dsn,db)      return   }   err = db.Ping()   if err != nil {      log.Printf(&#34;open %s failed , err : %v\n&#34;,dsn , err)      return    }   fmt.Println(db,&#34;连接数据库成功!&#34;)}
</span></code></pre></div><p>github上的mysql驱动如何关联到database/sql这个包里呢？</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210820123021805.png" >
		<img src="/GoLearning.assets/image-20210820123021805.png"
			
			
			
			loading="lazy"
			alt="image-20210820123021805">
	</a>
	
	<figcaption>image-20210820123021805</figcaption>
	
</figure></p>
<h5 id="单行查询">单行查询</h5>
<p>单行查询db.queryrow()执行一次查询，并期望返回最多一行结果row。queryrow总是返回非nil值，直到返回值的scan方法被调用时，才会返回被延迟的错误（如未找到）</p>
<h5 id="setmaxopenconns方法">setmaxopenconns方法</h5>
<p>设置与数据库连接池的最大连接数</p>
<h5 id="setmaxidleconns方法">setmaxidleconns方法</h5>
<p>setmaxidleconnes设置连接池中的最大闲置连接数。如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。如果n&lt;=0 不会保留闲置连接</p>
<h5 id="多行查询">多行查询</h5>
<p>多行查询db.query()执行一次查询，返回多行结果（rows），一般用于执行select命令。参数args表示query中的占位参数</p>
<h5 id="插入数据">插入数据</h5>
<p>插入、更新和删除操作都使用方法 Exec</p>
<p>删除也是一样的</p>
<h5 id="mysql预处理">MySQL预处理</h5>
<h5 id="什么是预处理">什么是预处理</h5>
<p>普通sql语句执行过程:</p>
<ol>
<li>客户端对SQL语句进行占位符替换得到完整的SQL语句</li>
<li>客户端发送完整的SQL语句到MySQL服务端</li>
<li>mysql服务端执行完整的sql语句并将结果返回给客户端</li>
</ol>
<p>预处理执行过程:</p>
<ol>
<li>把sql语句分成两部分,命令部分与数据部分</li>
<li>先把命令部分发送给mysql服务端,mysql服务端进行sql预处理</li>
<li>然后吧数据部分发送给mysql服务端,mysql服务端对sql语句进行占位符替换</li>
<li>mysql服务端执行完整的sql语句并将结果返回给客户端</li>
</ol>
<h5 id="为什么要预处理">为什么要预处理</h5>
<p>1.优化mysql服务器重复执行sql的方法,可以提升服务器性能,提前让服务器编译,一次编译多次执行,节省后续编译的成本</p>
<p>2.避免sql注入的问题</p>
<h5 id="go实现mysql预处理">go实现mysql预处理</h5>
<p>prepare方法会先将sql语句发送给mysql服务端,返回一个准备好的状态用于之后的查询和命令.返回值可以同时执行多个查询和命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;database/sql&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>   <span class="s">&#34;log&#34;</span><span class="p">)</span><span class="kd">type</span> <span class="nx">student</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">sno</span> <span class="p">,</span><span class="nx">sname</span><span class="p">,</span><span class="nx">ssex</span> <span class="kt">string</span>   <span class="nx">sage</span> <span class="kt">int</span><span class="p">}</span><span class="kd">var</span> <span class="nx">db</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span> <span class="c1">//是一个连接池对象func main() {   initDB()   //queryOne(&#34;2016210867&#34;)   //queryMany()   //insert()   //update()   prepareSelect()}func initDB() (err error) {   dsn:=&#34;root:123456@tcp(127.0.0.1:3306)/tset&#34;   db,err =sql.Open(&#34;mysql&#34;,dsn)   if err != nil {      log.Printf(&#34;dsn %s is invalid , error : %v\n&#34;,dsn,err)   }   err = db.Ping()   if err != nil {      log.Printf(&#34;open %s failed , err : %v\n&#34;,dsn,err)      return err   }   //设置数据库连接池最大连接数  如果超过了就会阻塞等待其他的程序   db.SetMaxOpenConns(10)   //最大空闲连接数   db.SetMaxIdleConns(5)   return nil}func queryOne(sno string) {   var s student   //查找   row := db.QueryRow(&#34;select * from student where sno = ?&#34;,sno) //从连接池中拿一个连接出来去数据库查询单挑记录   //扫描+释放连接  必须对rowobj调用scan方法   row.Scan(&amp;s.sno,&amp;s.sname,&amp;s.ssex,&amp;s.sage)   var sname string   db.QueryRow(&#34;select sname from student where sno = ?&#34;,sno).Scan(&amp;sname)   fmt.Printf(&#34;student: %v \n&#34;,s)   fmt.Println(sname)}func queryMany()  {   rows, err := db.Query(&#34;select sno , sname , ssex , sage from student &#34;)   if err != nil {      fmt.Println(&#34;db query failed , error : %v\n&#34;,err)      return   }   //非常重要 一定要关闭rows   defer rows.Close()   //循环取值   for rows.Next(){      var s student      rows.Scan(&amp;s.sno,&amp;s.sname,&amp;s.ssex,&amp;s.sage)      fmt.Println(s)   }}func insert() {   sql:=&#34;insert into student values (&#39;2020170281&#39;,&#39;ljs&#39;,&#39;man&#39;,23)&#34;   exec, err := db.Exec(sql)   if err != nil {      fmt.Println(&#34;exec insert %s failed , err : %v\n&#34;,sql,err)      return   }   //如果是插入数据的操作,能够拿到插入数据的id   id, err := exec.LastInsertId()   if err != nil {      fmt.Println(&#34;get id failed ,err : %v\n&#34;, err)      return   }   fmt.Println(&#34;id:&#34;,id)}func update() {   exec, err := db.Exec(&#34;update student set sname = &#39;ljsnew&#39; where sno=&#39;2020170281&#39; &#34;)   if err != nil {      fmt.Println(err)      return   }   fmt.Println(exec.RowsAffected())}//预处理方式select多条数据func prepareSelect() {   prepare, err := db.Prepare(&#34;select * from student where sno like ? &#34;)//吧sql语句先发给mysql预处理一下   if err != nil {      return   }   rows, err := prepare.Query(&#34;%2016%&#34;) //后续只需要传值就行了   if err != nil {      return   }   defer prepare.Close()   defer rows.Close()   for rows.Next    () {      var s student      rows.Scan(&amp;s.sno,&amp;s.sname,&amp;s.ssex,&amp;s.sage)      fmt.Println(s)   }}
</span></code></pre></div><h5 id="go语言实现mysql事务">go语言实现mysql事务</h5>
<p>事务相关方法:begin / commit /  rollback</p>
<h5 id="sqlx使用">sqlx使用</h5>
<p>第三方库 sqlx 能够简化操作,提高开发效率</p>
<p>安装 go get github.com/jmoiron/sqlx</p>
<h5 id="注意事项">注意事项</h5>
<h5 id="sql中的占位符">SQL中的占位符</h5>
<p>不同数据库中,SQL语句使用的占位符语法不尽相同</p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>占位符语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mysql</td>
<td>?</td>
</tr>
<tr>
<td>postgresql</td>
<td>$1,$2</td>
</tr>
<tr>
<td>sqlite</td>
<td>?和$1</td>
</tr>
<tr>
<td>oracle</td>
<td>:name</td>
</tr>
</tbody>
</table>
<h5 id="sql注入">sql注入</h5>
<p>我们任何时候都不应该自己拼接sql语句</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="nx">_</span><span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>   <span class="s">&#34;github.com/jmoiron/sqlx&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nf">sqlInjectDemo</span><span class="p">(</span><span class="s">&#34;xxx&#39;or 1=1#&#34;</span><span class="p">)</span>   <span class="nf">sqlInjectDemo</span><span class="p">(</span><span class="s">&#34;xxx&#39; union select * from student #&#34;</span><span class="p">)}</span><span class="kd">var</span> <span class="nx">db</span> <span class="o">*</span><span class="nx">sqlx</span><span class="p">.</span><span class="nx">DBtype</span> <span class="nx">student</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">SNO</span> <span class="p">,</span> <span class="nx">SNAME</span> <span class="p">,</span> <span class="nx">SSEX</span> <span class="kt">string</span>   <span class="nx">SAGE</span> <span class="kt">int</span><span class="p">}</span><span class="kd">func</span> <span class="nf">sqlInjectDemo</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//自己拼接sql语句   sqlStr:=fmt.Sprintf(&#34;select * from student where sname =&#39;%s&#39;&#34;,name)   fmt.Println(sqlStr)   var err error   db, err = sqlx.Connect(&#34;mysql&#34;, &#34;root:123456@tcp(127.0.0.1:3306)/tset&#34;)   if err != nil {      fmt.Println(err)      return   }   err = db.Ping()   if err != nil {      fmt.Println(err)      return   }   var s []student   err = db.Select(&amp;s, sqlStr)   if err != nil {      fmt.Println(err)      return   }   fmt.Println(s)}
</span></code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210820163242826.png" >
		<img src="/GoLearning.assets/image-20210820163242826.png"
			
			
			
			loading="lazy"
			alt="image-20210820163242826">
	</a>
	
	<figcaption>image-20210820163242826</figcaption>
	
</figure></p>
<h5 id="redis">redis</h5>
<p>kv数据库</p>
<p>redis的用处</p>
<ol>
<li>cache缓存</li>
<li>简单的队列</li>
<li>排行榜</li>
</ol>
<p>redis是一个开源的内存数据库,redis提供了多种不同类型的数据结构,很多业务场景下的问题都可以很自然地映射到这些数据结构上.除此之外,通过复制/持久化和客户端分片等特性,我们可以很方便的将redis扩展成为一个能够包含数百GB数据/每秒处理上百万次请求的系统</p>
<h5 id="redis支持的数据结构">redis支持的数据结构</h5>
<p>redis支持诸如字符串strings 哈希hashes 列表lists 集合sets 带范围查询的排序集合 sorted sets 位图bitmaps hyperloglogs 带半径查询和流的地理空间索引等数据结构 geospatial indexes</p>
<h5 id="redis应用场景">redis应用场景</h5>
<ul>
<li>缓存系统,减轻主数据库mysql的压力</li>
<li>计数场景,比如微博/抖音中的关注数和粉丝数</li>
<li>热门排行榜,需要排序的场景特别适合使用zset</li>
<li>利用list可以实现队列的功能</li>
</ul>
<h5 id="redis与memcached比较">redis与memcached比较</h5>
<p>memcache中的值只支持简单的字符串,redis支持更丰富的5种数据结构类型.redis的性能比memcache好很多.redis支持rdb持久化和aof持久化.redis支持master/slave模式</p>
<h5 id="安装">安装</h5>
<p>go语言中使用第三方库连接redis数据库并进行操作.使用以下命令下载并安装</p>
<p>go get -u github.com/go-redis/redis</p>
<h5 id="get和set">get和set</h5>
<h5 id="zset">zset</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/go-redis/redis&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">redisDb</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Clientfunc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">err</span> <span class="o">:=</span> <span class="nf">initRedis</span><span class="p">()</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;连接redis成功&#34;</span><span class="p">)</span>   <span class="nf">redisExample</span><span class="p">()</span>   <span class="nf">redisExample2</span><span class="p">()}</span><span class="kd">func</span> <span class="nf">initRedis</span><span class="p">()</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>   <span class="nx">redisDb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>      <span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>      <span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>      <span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>   <span class="p">})</span>   <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redisDb</span><span class="p">.</span><span class="nf">Ping</span><span class="p">().</span><span class="nf">Result</span><span class="p">()</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="k">return</span> <span class="nx">err</span>   <span class="p">}</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>   <span class="k">return</span><span class="p">}</span><span class="kd">func</span> <span class="nf">redisExample</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redisDb</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;score&#34;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">Err</span><span class="p">()</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="nx">val1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redisDb</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;score&#34;</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;scoer&#34;</span><span class="p">,</span><span class="nx">val1</span><span class="p">)</span>   <span class="nx">val2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redisDb</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;name does not exist&#34;</span><span class="p">)</span>   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>      <span class="k">return</span>    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">val2</span><span class="p">)</span>   <span class="p">}}</span><span class="kd">func</span> <span class="nf">redisExample2</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//zset   key:=&#34;rank&#34;   items:=[]redis.Z{      redis.Z{         Score:  99,         Member: &#34;php&#34;,      },      redis.Z{         Score:  96,         Member: &#34;golang&#34;,      },      redis.Z{         Score: 97,         Member: &#34;python&#34;,      },      redis.Z{         Score:  99,         Member: &#34;java&#34;,      },   }   fmt.Println(items)   //把元素都追加到key中   num, err := redisDb.ZAdd(key,items...).Result()   if err != nil {      return   }   fmt.Println(num)   //加分数   newScore, err := redisDb.ZIncrBy(key, -1, &#34;java&#34;).Result()   if err != nil {      return   }   fmt.Println(newScore)   //取分数最高的   scoreList, err := redisDb.ZRevRangeWithScores(key,0,3).Result()   if err != nil {      return   }   for _, z := range scoreList {      fmt.Println(z.Member,z.Score)   }   //取95到100分的   option := &amp;redis.ZRangeBy{      Min: &#34;95&#34;,      Max: &#34;100&#34;,   }   ret, err := redisDb.ZRangeByScoreWithScores(key,*option).Result()   if err != nil {      return    }   for _, z := range ret {      fmt.Println(z.Member,z.Score)   }}
</span></code></pre></div><h5 id="nsq">NSQ</h5>
<p>NSQ是目前比较流行的一个分布式的消息队列,本文主要介绍了NSQ及go语言如何操作NSQ</p>
<h5 id="nsq介绍">NSQ介绍</h5>
<p>NSQ是go语言编写的一个开源的实时分布式内存消息队列,其性能十分优异.NSQ的优势有:</p>
<ol>
<li>NSQ提倡分布式和分散的拓扑,没有单点故障,支持容错和高可用性,并提供可靠的消息交付保证</li>
<li>NSQ支持横向扩展,没有任何集中式代理</li>
<li>NSQ易于配置和部署,并且内置了管理界面</li>
</ol>
<h5 id="nsq的应用场景">NSQ的应用场景</h5>
<p>通常来说,消息队列都适用于以下场景</p>
<h5 id="异步处理">异步处理</h5>
<p>利用消息队列把业务流程中的非关键流程异步化,从而显著降低业务请求的响应时间</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210820235216910.png" >
		<img src="/GoLearning.assets/image-20210820235216910.png"
			
			
			
			loading="lazy"
			alt="image-20210820235216910">
	</a>
	
	<figcaption>image-20210820235216910</figcaption>
	
</figure></p>
<h5 id="应用解耦">应用解耦</h5>
<p>通过使用消息队列将不同的业务逻辑解耦,降低系统间的耦合,提高系统的健壮性.后续有其他业务要使用订单数据可直接订阅消息队列,提高系统的灵活性</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210820235428939.png" >
		<img src="/GoLearning.assets/image-20210820235428939.png"
			
			
			
			loading="lazy"
			alt="image-20210820235428939">
	</a>
	
	<figcaption>image-20210820235428939</figcaption>
	
</figure></p>
<h5 id="流量削峰">流量削峰</h5>
<p>类似秒杀等场景下,某一时间可能会产生大量的请求,使用消息队列能够为后端处理请求提供一定的缓冲区,保证后端服务的稳定性</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210820235659875.png" >
		<img src="/GoLearning.assets/image-20210820235659875.png"
			
			
			
			loading="lazy"
			alt="image-20210820235659875">
	</a>
	
	<figcaption>image-20210820235659875</figcaption>
	
</figure></p>
<h5 id="nsq组件">NSQ组件</h5>
<h5 id="nsqd">nsqd</h5>
<p>nsqd是一个守护进程,它接收/排队并向客户端发送消息</p>
<p>启动nsqd,指定-broadcast-address=127.0.0.1来配置广播地址</p>
<p>如果是在搭配nsqdlookupd使用的模式下还需要指定nsqdlookupd地址</p>
<p>如果是部署了多个nsqlookupd节点的集群,那还可以指定多个-lookupd-tcp-address</p>
<h5 id="nsqlookupd">nsqlookupd</h5>
<p>nsqlookupd是维护所有nsqd状态/提供服务发现的守护进程.他能为消费者查找特定topic下的nsqd提供了运行时的自动发现服务.他不是维持持久状态,也不需要与任何其他的nsqdlookupd实例协调以满足查询.因此根据系统的冗余要求尽可能多地部署nsqlookupd节点.她们消耗的资源很少,可以与其他服务共存,我们的建议是为每个数据中心运行至少三个集群</p>
<p>nsqadmin</p>
<p>一个实时监控集群状态/执行各种管理任务的web管理平台,启动nsqdadmin,指定nsqlookupd地址</p>
<p>我们可以使用浏览器打开http://127.0.0.1:4171访问管理界面</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210821104437565.png" >
		<img src="/GoLearning.assets/image-20210821104437565.png"
			
			
			
			loading="lazy"
			alt="image-20210821104437565">
	</a>
	
	<figcaption>image-20210821104437565</figcaption>
	
</figure></p>
<h5 id="topic和channel">topic和channel</h5>
<p>每个nsqd实例旨在一次处理多个数据流.这些数据流成为topics,一个topic具有一个或者多个channels,每个channel都会收到topic所有消息的副本,实际上上下游的服务是通过对应的channel来消费topic消息</p>
<p>topic和channel不是预先设置的.topic在首次使用时创建,方法是将其发布到指定topic,或者订阅指定topic上的channel. channel是通过订阅指定的channel在第一次使用时创建的</p>
<p>topic和channel都互相独立地缓冲数据,防止缓慢的消费者导致其他channel的积压(同样适用于topic级别)</p>
<p>channel可以并且通常会连接多个客户端.假设所有连接的客户端都处于准备接收消息的状态,则每条消息将被传递到随机客户端</p>
<p>总而言之,消息是从topic-&gt;channel(每个channel接收该topic的所有消息的副本) 多播的,但是从channel-&gt;consumers均匀分布(每个消费者接收到该channel的一部分消息)</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210821105522944.png" >
		<img src="/GoLearning.assets/image-20210821105522944.png"
			
			
			
			loading="lazy"
			alt="image-20210821105522944">
	</a>
	
	<figcaption>image-20210821105522944</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210821105528935.png" >
		<img src="/GoLearning.assets/image-20210821105528935.png"
			
			
			
			loading="lazy"
			alt="image-20210821105528935">
	</a>
	
	<figcaption>image-20210821105528935</figcaption>
	
</figure></p>
<h5 id="nsq特性">NSQ特性</h5>
<ul>
<li>消息默认不持久化,可以配置成持久化模式. nsq采用的方式是内存+硬盘的模式,当内存达到一定程度时就会将数据持久化到硬盘上.
<ul>
<li>如果将 &ndash;mem-queue-size 设置为0</li>
<li>服务器重启时也会将当时在内存中的消息持久化</li>
</ul>
</li>
<li>每条消息至少传递一次</li>
<li>消息不保证有序</li>
</ul>
<h5 id="go操作nsq">go操作nsq</h5>
<h5 id="day11课上笔记">day11课上笔记</h5>
<h5 id="今日内容-6">今日内容</h5>
<h5 id="依赖管理go-module">依赖管理go module</h5>
<h5 id="context">context</h5>
<h5 id="服务端agent开发">服务端agent开发</h5>
<h5 id="日志项目架构设计">日志项目架构设计</h5>
<h5 id="kafka和zookeeper">kafka和zookeeper</h5>
<h5 id="tailf介绍">tailf介绍</h5>
<h5 id="为什么需要依赖管理">为什么需要依赖管理</h5>
<p>最早的时候,go所依赖的所有第三方库 放在gopath这个目录下面.这就导致了同一个库只能保存一个版本的代码.如果不同的项目依赖同一个第三方的库的不同版本,应该怎么解决</p>
<h5 id="godep">godep</h5>
<p>go语言从v1.5开始引入vendor模式,如果项目目录下有vendor目录,那么go工具链会优先使用vendor内的包进行编译/测试 等等</p>
<p>godep是一个通过vendor模式实现的go语言的第三方依赖管理工具,类似的还有由社区维护准官方包管理工具dep</p>
<h5 id="go-module">go module</h5>
<p>go1.11之后退出的官方版本管理工具,从go1.13版本开始,go module将是go语言默认的依赖管理工具</p>
<p>go111module</p>
<p>要启用go module 支持首先要设置环境变量 go111module,通过他可以开启和关闭模块支持,他可以有三个可选值:</p>
<p>off on auto 默认值是auto</p>
<p>off就是禁用模块支持,编译时会从gopath和vendor文件夹中查找包</p>
<p>on就是启用模块支持,编译时会忽略gopath和vendor文件夹,只根据go.mod下载依赖</p>
<p>auto就是当gopath外有go.mod文件时,开启模块支持</p>
<p>简单来说,设置on之后就可以使用go module了</p>
<p>使用go module管理依赖后会在项目根目录下生成两个文件go.mod和go.sum</p>
<h5 id="goproxy">goproxy</h5>
<p>go1.11之后设置goproxy命令,由于国内无法访问,所以建议设置goproxy</p>
<h5 id="go-mod命令">go mod命令</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">mod</span> <span class="nx">downloadgo</span> <span class="nx">mod</span> <span class="nx">editgo</span> <span class="nx">mod</span> <span class="nx">graph</span> <span class="k">go</span> <span class="nx">mod</span> <span class="nx">initgo</span> <span class="nx">mod</span> <span class="nx">tidygo</span> <span class="nx">mod</span> <span class="nx">vendorgo</span> <span class="nx">mod</span> <span class="nx">verifygo</span> <span class="nx">mod</span> <span class="nx">why</span>
</code></pre></div><h5 id="gomod">go.mod</h5>
<p>go.mod文件记录了项目所有的依赖信息,其结构大致如下</p>
<p>其中:</p>
<ul>
<li>module用来定义包名</li>
<li>require用来定义依赖包及版本</li>
<li>indirect表示简介引用</li>
</ul>
<h5 id="gosum">go.sum</h5>
<p>详细包和版本信息</p>
<h5 id="go-get">go get</h5>
<p>下载依赖包,并且还可以指定下载的版本</p>
<h5 id="go-mod-edit">go mod edit</h5>
<p>因为我们可以手动修改go.mod文件,所以有时候需要格式化该文件/添加依赖项/移除依赖项</p>
<h5 id="在项目中使用go-module">在项目中使用go module</h5>
<h5 id="既有项目">既有项目</h5>
<p>如果需要对一个已经存在的项目启用go module,可以按照以下步骤</p>
<ol>
<li>在项目目录下执行go mod init , 生成一个go.mod文件</li>
<li>执行go get , 查找并记录当前项目的依赖,同时生成一个go. sum记录每个依赖库的版本和哈希值</li>
</ol>
<h5 id="新项目">新项目</h5>
<ol>
<li>执行go mod init 项目名 , 在当前项目文件夹下创建一个go.mod文件</li>
<li>手动编辑go.mod中的require依赖项或执行go get自动发现/维护依赖</li>
</ol>
<h5 id="context-1">context</h5>
<p>非常重要!!!</p>
<p>如何优雅的控制子goroutine退出</p>
<p>在go http包的server中,每一个请求在都有一个对应的goroutine去处理,请求处理函数通常会启动额外的goroutine用来访问后端服务,比如数据库和rpc服务.用来处理一个请求的goroutine,通常需要访问一些与请求特定的数据,比如终端用户的身份认证信息/验证相关的token/请求的截止时间.当一个请求被取消或超时时,所有用来处理该请求的goroutine都应该迅速退出,然后系统才能释放这些goroutine占用的资源</p>
<h5 id="使用全局变量">使用全局变量</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;sync&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="c1">//第一种就是通过全局变量 来控制goroutine退出var notify boolvar wg sync.WaitGroup//为什么需要contextfunc main() {   wg.Add(1)   go f()   //如何通知子goroutine退出   time.Sleep(time.Second)   notify=true   wg.Wait()}func f() {   defer wg.Done()   for !notify {      fmt.Println(&#34;ljs&#34;)      time.Sleep(time.Millisecond*500)   }}
</span></code></pre></div><h5 id="使用通道">使用通道</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;sync&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">i</span>  <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="c1">//为什么需要contextfunc main() {   wg.Add(1)   go f()   //如何通知子goroutine退出   time.Sleep(time.Second)   i&lt;-true   wg.Wait()}func f() {   defer wg.Done()   LOOP:   for {      fmt.Println(&#34;ljs&#34;)      time.Sleep(time.Millisecond*500)      select {         case &lt;-i:            break LOOP      default:      }   }}
</span></code></pre></div><h5 id="使用context">使用context</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;context&#34;</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;sync&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroupfunc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>   <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="k">go</span> <span class="nf">f</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>   <span class="c1">//如何通知子goroutine退出   time.Sleep(time.Second)   //通知子goroutine退出   cancel()   wg.Wait()}func f(ctx context.Context) {   defer wg.Done()   go f2(ctx)   LOOP:   for  {      fmt.Println(&#34;ljs&#34;)      time.Sleep(time.Millisecond*500)      select {         case &lt;-ctx.Done():            break LOOP      default:      }   }}func f2(ctx context.Context) {   defer wg.Done()   LOOP:   for {      fmt.Println(&#34;jwt&#34;)      time.Sleep(time.Millisecond*250)      select {         case&lt;-ctx.Done():            break LOOP      default:      }   }}
</span></code></pre></div><h5 id="context初识">context初识</h5>
<p>go1.7加入了一个新的标准库context,他定义了context类型,专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据/取消信号/截止时间等相关操作,这些操作可能涉及多个api调用</p>
<p>对服务器传入的请求应该创建上下文,而对服务器的传出调用应该接受上下文.她们之间的函数调用链必须传递上下文,或者可以使用withcancle/withdeadline/withtimeout或withvalue创建的派生上下文,当一个上下文被取消时,他派生的所有上下文也被取消</p>
<p>其中:</p>
<ul>
<li>deadline方法需要返回当前context被取消的时间,也就是完成工作的截至时间(deadline)</li>
<li>done方法需要返回一个channel,这个channel会在当前工作完成或者上下文被取消之后关闭,多次调用done方法会返回同一个channel</li>
<li>err方法会返回当前context结束的原因,他只会在done返回的channel被关闭时才会返回非空的值
<ul>
<li>如果当前context被取消就会返回canceled错误</li>
<li>如果当前context超市就会返回deadlineexceeded</li>
</ul>
</li>
<li>value方法会从context中返回键对应的值,对于同一个上下文来说,多次调用value并传入相同的key会返回相同的结果,该方法仅用于传递跨api和进程间跟请求域的数据</li>
</ul>
<h5 id="background和todo">background和todo</h5>
<p>go内置两个函数:background和todo,这两个函数分别返回了一个实现了context接口的background和todo.我们代码中最开始都是以这两个内置的上下文对象作为最顶层的parent context,衍生出更多的子上下文对象</p>
<p>background主要用于main函数/初始化以及测试代码中,作为context这个树结构的最顶层的context,也就是根的context</p>
<p>todo,它目前还不知道具体的使用场景,如果我们不知道该使用什么context的时候,可以使用这个</p>
<p>background和todo本质上都是emptyctx结构体类型,是一个不可取消,没有设置截止时间,没有携带任何值的context</p>
<h5 id="with系列函数">with系列函数</h5>
<h5 id="withcancel">withcancel</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">withcancel</span> <span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span> <span class="p">,</span> <span class="nx">cancel</span> <span class="nx">cancelFunc</span><span class="p">)</span>
</code></pre></div><p>withcancel返回带有新done通道的父节点的副本.当调用返回的cancel函数或当关闭父上下文的done通道时,将关闭返回上下文的done通道,无论先发生什么情况.</p>
<p>取消此上下文将释放与其关联的资源</p>
<h5 id="withdeadline">withdeadline</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">withdeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span> <span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">time</span><span class="p">)</span> <span class="p">(</span><span class="nx">context</span> <span class="p">,</span> <span class="nx">cancelfunc</span><span class="p">)</span>
</code></pre></div><p>返回父上下文的副本,并将deadline调整为不迟于d.如果父上下文的deadline已经早于d,则withdeadline(parent,d)在语义上等同于父上下文,当截止日过期时,当调用返回的cancel函数时,或者当父上下文的done通道关闭时,返回上下文的done通道将被关闭,以最先发生的情况为准</p>
<p>取消此上下文将释放与其关联的资源,因此代码应该在此上下文中运行的操作完成后立即调用cancel</p>
<h5 id="withtimeout">withtimeout</h5>
<p>withtimeout的函数签名如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTimeout</span> <span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span> <span class="p">,</span><span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">context</span> <span class="p">,</span> <span class="nx">cancelfunc</span><span class="p">)</span>
</code></pre></div><p>withtimeout返回withdeadline(parent,time.now().add(timeout))</p>
<p>取消此上下文将释放与其相关的资源,因此代码应该在此上下文中运行的操作完成后立即调用cancel,通常用于数据库或者网络连接的超时控制</p>
<h5 id="withvalue">withvalue</h5>
<p>withvalue函数能够将请求作用域的数据与context对象建立关系</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span> <span class="p">,</span> <span class="nx">key</span> <span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">context</span>
</code></pre></div><p>withvalue 返回父节点的副本,其中与key关联的值为val</p>
<p>仅对api和进程间传递请求域的数据使用上下文值,而不是使用他来传递可选参数给函数</p>
<p>所提供的键必须是可比较的,并且不应该是string类型或任何其他内置类型,以避免使用上下文在包之间发生冲突.withvalue的用户应该为键自己定义自己的类型.为了避免在分配给interface{}时进行分配,上下文键通常使用具体类型struct{}.或者导出的上下文关键变量的静态类型应该是指针或接口</p>
<h5 id="gosum文件">go.sum文件</h5>
<p>详细的包名和版本信息</p>
<h5 id="常见的命令">常见的命令</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">mod</span> <span class="nx">init</span> <span class="c1">//初始化项目go mod tidy //检查代码里的依赖去更新go.mod文件中的依赖go get go mod download
</span></code></pre></div><h5 id="日志收集项目">日志收集项目</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823155422863.png" >
		<img src="/GoLearning.assets/image-20210823155422863.png"
			
			
			
			loading="lazy"
			alt="image-20210823155422863">
	</a>
	
	<figcaption>image-20210823155422863</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823155631862.png" >
		<img src="/GoLearning.assets/image-20210823155631862.png"
			
			
			
			loading="lazy"
			alt="image-20210823155631862">
	</a>
	
	<figcaption>image-20210823155631862</figcaption>
	
</figure></p>
<h5 id="组件介绍">组件介绍：</h5>
<p>logagent：日志收集客户端，用来收集服务器上的日志</p>
<p>kafka：高吞吐量的分布式队列（linkin开发，apache顶级开源项目）</p>
<p>ElasticSearch：开源的搜索引擎，提供基于http restful 的web接口</p>
<p>kibana：开源的ES数据分析和可视化工具</p>
<p>hadoop：分布式计算框架，能够对大量数据进行分布式处理的平台</p>
<p>storm：一个免费并开源的分布式实时计算系统</p>
<h5 id="消息队列的通信模式">消息队列的通信模式</h5>
<h5 id="点对点模式queue">点对点模式queue</h5>
<p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并消费消息。一条消息被消费以后，queue中就没有了，不存在重复消费。</p>
<h5 id="发布订阅topic">发布/订阅topic</h5>
<p>消息生产者（发布）将消息发布到topic中，同时 有多个消息消费者（订阅）消费该消息。和点对点模式不同，发布到topic的消息会被所有订阅者消费（类似于关注了微信公众号的人都能收到推送的文章）</p>
<p>补充：发布订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。实际上现实场景中是多个订阅者节点组成一个订阅组负载均衡消费topic消息即分组订阅，这样订阅者很容易实现消费能力的线性扩展。可以看成是一个topic下有多个queue，每个queue是点对点的方式，queue之间是发布订阅方式</p>
<h5 id="kafka">kafka</h5>
<p>apache kafka最初用来设计解决海量日志传输等问题。kafka使用scala编写。是一个分布式数据流平台，可以运行在单台服务器上，也可以在多台服务器上部署形成集群。它提供了发布和订阅功能，使用者可以发送数据到kafka中，也可以从kafka中读取数据（以便进行后续的处理）。kafka具有高吞吐量、低延迟、高容错等特点。</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823161642535.png" >
		<img src="/GoLearning.assets/image-20210823161642535.png"
			
			
			
			loading="lazy"
			alt="image-20210823161642535">
	</a>
	
	<figcaption>image-20210823161642535</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823161731945.png" >
		<img src="/GoLearning.assets/image-20210823161731945.png"
			
			
			
			loading="lazy"
			alt="image-20210823161731945">
	</a>
	
	<figcaption>image-20210823161731945</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/C:/Users/Sweetie/Desktop/Go%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0.assets/image-20210823161916638.png" >
		<img src="/C:/Users/Sweetie/Desktop/Go%e8%af%ad%e8%a8%80%e5%ad%a6%e4%b9%a0.assets/image-20210823161916638.png"
			
			
			
			loading="lazy"
			alt="image-20210823161916638">
	</a>
	
	<figcaption>image-20210823161916638</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823162018291.png" >
		<img src="/GoLearning.assets/image-20210823162018291.png"
			
			
			
			loading="lazy"
			alt="image-20210823162018291">
	</a>
	
	<figcaption>image-20210823162018291</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823162112407.png" >
		<img src="/GoLearning.assets/image-20210823162112407.png"
			
			
			
			loading="lazy"
			alt="image-20210823162112407">
	</a>
	
	<figcaption>image-20210823162112407</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823162150526.png" >
		<img src="/GoLearning.assets/image-20210823162150526.png"
			
			
			
			loading="lazy"
			alt="image-20210823162150526">
	</a>
	
	<figcaption>image-20210823162150526</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823162256871.png" >
		<img src="/GoLearning.assets/image-20210823162256871.png"
			
			
			
			loading="lazy"
			alt="image-20210823162256871">
	</a>
	
	<figcaption>image-20210823162256871</figcaption>
	
</figure></p>
<h5 id="kafka-1">kafka</h5>
<ol>
<li>kafka集群的架构
<ol>
<li>broker</li>
<li>topic</li>
<li>partition分区，把同一个topic分成不同的分区，提高负载
<ol>
<li>leader：分区的主节点，boss</li>
<li>flower：分区的从节点</li>
</ol>
</li>
<li>consumer group</li>
</ol>
</li>
<li>生产者往kafka发送数据的流程
<ol>
<li>获取集群的leader</li>
<li>生产者发送给leader</li>
<li>leader落盘</li>
<li>follower从leader拉取</li>
<li>follower落盘回复ack</li>
<li>leader回复生产者</li>
</ol>
</li>
<li>kafka选择分区的模式
<ol>
<li>指定往哪个分区写</li>
<li>指定key，kafka根据key做hash然后决定写哪个分区</li>
<li>轮询</li>
</ol>
</li>
<li>生产者往kafka发送数据的模式
<ol>
<li>0 把数据发给leader就成功，效率最高、安全性最低</li>
<li>1 把数据发给leader，等待leader回ack</li>
<li>all 把数据发给leader，follower拉取后回ack，leader再回ack，安全性最高</li>
</ol>
</li>
<li>为什么快？ 落盘的时候不是随机的而是顺序的</li>
</ol>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823163451045.png" >
		<img src="/GoLearning.assets/image-20210823163451045.png"
			
			
			
			loading="lazy"
			alt="image-20210823163451045">
	</a>
	
	<figcaption>image-20210823163451045</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823163547230.png" >
		<img src="/GoLearning.assets/image-20210823163547230.png"
			
			
			
			loading="lazy"
			alt="image-20210823163547230">
	</a>
	
	<figcaption>image-20210823163547230</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823163621907.png" >
		<img src="/GoLearning.assets/image-20210823163621907.png"
			
			
			
			loading="lazy"
			alt="image-20210823163621907">
	</a>
	
	<figcaption>image-20210823163621907</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823163708974.png" >
		<img src="/GoLearning.assets/image-20210823163708974.png"
			
			
			
			loading="lazy"
			alt="image-20210823163708974">
	</a>
	
	<figcaption>image-20210823163708974</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823163926776.png" >
		<img src="/GoLearning.assets/image-20210823163926776.png"
			
			
			
			loading="lazy"
			alt="image-20210823163926776">
	</a>
	
	<figcaption>image-20210823163926776</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823164008727.png" >
		<img src="/GoLearning.assets/image-20210823164008727.png"
			
			
			
			loading="lazy"
			alt="image-20210823164008727">
	</a>
	
	<figcaption>image-20210823164008727</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823164021727.png" >
		<img src="/GoLearning.assets/image-20210823164021727.png"
			
			
			
			loading="lazy"
			alt="image-20210823164021727">
	</a>
	
	<figcaption>image-20210823164021727</figcaption>
	
</figure></p>
<h5 id="启动zookeeper">启动zookeeper</h5>
<ol>
<li>
<p>下载kafka</p>
</li>
<li>
<p>kafka内置zookeeper</p>
</li>
<li>
<p>修改config下zookeeper.properties配置文件<figure 
	>
	<a href="/GoLearning.assets/image-20210823191107893.png" >
		<img src="/GoLearning.assets/image-20210823191107893.png"
			
			
			
			loading="lazy"
			alt="image-20210823191107893">
	</a>
	
	<figcaption>image-20210823191107893</figcaption>
	
</figure></p>
</li>
<li>
<p>命令行启动zookeeper</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">D:<span class="se">\S</span>oftwares<span class="se">\k</span>afka_2.12-2.8.0&gt;bin<span class="se">\w</span>indows<span class="se">\z</span>ookeeper-server-start.bat config<span class="se">\z</span>ookeeper.properties
</code></pre></div></li>
<li>
<p>修改config下kafka.properties配置文件<figure 
	>
	<a href="/GoLearning.assets/image-20210823192529505.png" >
		<img src="/GoLearning.assets/image-20210823192529505.png"
			
			
			
			loading="lazy"
			alt="image-20210823192529505">
	</a>
	
	<figcaption>image-20210823192529505</figcaption>
	
</figure></p>
</li>
<li>
<p>命令行启动kafka</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">D</span><span class="p">:</span><span class="err">\</span><span class="nx">Softwares</span><span class="err">\</span><span class="nx">kafka_2</span><span class="mf">.12</span><span class="o">-</span><span class="mf">2.8.0</span><span class="p">&gt;</span><span class="nx">bin</span><span class="err">\</span><span class="nx">windows</span><span class="err">\</span><span class="nx">kafka</span><span class="o">-</span><span class="nx">server</span><span class="o">-</span><span class="nx">start</span><span class="p">.</span><span class="nx">bat</span> <span class="nx">config</span><span class="err">\</span><span class="nx">server</span><span class="p">.</span><span class="nx">properties</span>
</code></pre></div><p><strong>要用管理员身份打开命令行</strong></p>
</li>
</ol>
<h5 id="zookeeper">zookeeper</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823192857710.png" >
		<img src="/GoLearning.assets/image-20210823192857710.png"
			
			
			
			loading="lazy"
			alt="image-20210823192857710">
	</a>
	
	<figcaption>image-20210823192857710</figcaption>
	
</figure></p>
<p>类似于consul 服务注册与发现</p>
<h5 id="tail第三方日志库demo">tail第三方日志库demo</h5>
<p>tail作用 尝试读取某个log日志文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/nxadm/tail&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//tail用法   fileName:=&#34;./my.log&#34;   config:=tail.Config{      Location:    &amp;tail.SeekInfo{Offset: 0,Whence: 2}, //从文件的那个地方开始读      ReOpen:      true, //重新打开      MustExist:   false,    //文件不存在不报错      Poll:        true,      Pipe:        false,      Follow:      true, //是否跟随      MaxLineSize: 0,      RateLimiter: nil,      Logger:      nil,   }   tails, err := tail.TailFile(fileName, config)   if err != nil {      fmt.Println(&#34;tail file failed , err: &#34;,err)      return   }   var (      line *tail.Line      ok bool   )   for {      line, ok =&lt;-tails.Lines      if !ok {         fmt.Printf(&#34;tail file close reopen , filename :%s\n&#34;,tails.Filename)         time.Sleep(time.Second)         continue      }      fmt.Println(&#34;msg: &#34;,line.Text)   }}
</span></code></pre></div><h5 id="sarama第三方库demo">sarama第三方库demo</h5>
<p>作用:向kafka发送消息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/Shopify/sarama&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">config</span> <span class="o">:=</span> <span class="nx">sarama</span><span class="p">.</span><span class="nf">NewConfig</span><span class="p">()</span>   <span class="c1">//tailf包使用   config.Producer.RequiredAcks= sarama.WaitForAll  //发送完数据需要 leader 和 follower 都确认   config.Producer.Partitioner = sarama.NewRandomPartitioner  //新选出一个 partitioner   config.Producer.Return.Successes = true //成功交付的消息将在success channel 返回   //构造一个消息   msg:= &amp;sarama.ProducerMessage{}   msg.Topic = &#34;web_log&#34;   msg.Value = sarama.StringEncoder(&#34;this is a test blog&#34;)   //连接kafka   client, err := sarama.NewSyncProducer([]string{&#34;127.0.0.1:9092&#34;}, config)   if err != nil {      fmt.Println(&#34;producer closed, err : &#34;, err)      return   }   defer client.Close()   //发送消息   pid, offSet, err := client.SendMessage(msg)   if err != nil {      fmt.Println(&#34;send msg failed , err : &#34;, err)      return   }   fmt.Printf(&#34;pid:%v offSet:%v\n&#34;,pid,offSet)}
</span></code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210823202230801.png" >
		<img src="/GoLearning.assets/image-20210823202230801.png"
			
			
			
			loading="lazy"
			alt="image-20210823202230801">
	</a>
	
	<figcaption>image-20210823202230801</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210823202240537.png" >
		<img src="/GoLearning.assets/image-20210823202240537.png"
			
			
			
			loading="lazy"
			alt="image-20210823202240537">
	</a>
	
	<figcaption>image-20210823202240537</figcaption>
	
</figure></p>
<p>索引</p>
<h5 id="接下来就是日志收集项目">接下来就是日志收集项目</h5>
<ul>
<li>初始化sarama 让他连接上kafka 以便给kafka发送消息</li>
<li>初始化tail 让他能够读取日志文件</li>
<li>使用初始化好的sarama 将tail读取到的东西发送给kafka</li>
</ul>
<p>kafka模块代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">kafkaimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/Shopify/sarama&#34;</span><span class="p">)</span><span class="c1">//专门往kafka写日志的模块var (   client sarama.SyncProducer  //声明一个全局的连接kafka的生产者client)//Init 初始化clientfunc Init(address []string)(err error) {   config := sarama.NewConfig()   //tailf包使用   config.Producer.RequiredAcks= sarama.WaitForAll  //发送完数据需要 leader 和 follower 都确认   config.Producer.Partitioner = sarama.NewRandomPartitioner  //新选出一个 partitioner   config.Producer.Return.Successes = true //成功交付的消息将在success channel 返回   //连接kafka   client, err = sarama.NewSyncProducer(address, config)   if err != nil {      fmt.Println(&#34;producer closed, err : &#34;, err)      return   }   return}func SendToKafka(topic, msg string) {   //构造一个消息   saramaMsg:= &amp;sarama.ProducerMessage{}   saramaMsg.Topic = topic   saramaMsg.Value = sarama.StringEncoder(msg)   //发送消息   pid, offSet, err := client.SendMessage(saramaMsg)   if err != nil {      fmt.Println(&#34;send msg failed , err : &#34;, err)      return   }   fmt.Printf(&#34;pid:%v offSet:%v\n&#34;,pid,offSet)}
</span></code></pre></div><p>tail模块代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">tailimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/nxadm/tail&#34;</span><span class="p">)</span><span class="kd">var</span> <span class="nx">tails</span> <span class="o">*</span><span class="nx">tail</span><span class="p">.</span><span class="nx">Tail</span><span class="c1">//Init 专门收集日志func Init(address string) (err error){   //tail用法   fileName:=address   config:=tail.Config{      Location:    &amp;tail.SeekInfo{Offset: 0,Whence: 2}, //从文件的那个地方开始读      ReOpen:      true, //重新打开      MustExist:   false,    //文件不存在不报错      Poll:        true,      Pipe:        false,      Follow:      true, //是否跟随      MaxLineSize: 0,      RateLimiter: nil,      Logger:      nil,   }   tails, err = tail.TailFile(fileName, config)   if err != nil {      fmt.Println(&#34;tail file failed , err: &#34;,err)      return   }   return}func ReadLog() &lt;-chan *tail.Line {      return tails.Lines}
</span></code></pre></div><p>main模块代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;src/code.oldboyedu.com/logAgent/kafka&#34;</span>   <span class="nx">tail</span> <span class="s">&#34;src/code.oldboyedu.com/logAgent/tail_log&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//1.初始化kafka连接   err := kafka.Init([]string{&#34;127.0.0.1:9092&#34;})   if err != nil {      fmt.Println(&#34;init kafka failed, err : &#34; ,err)      return   }   fmt.Println(&#34;init kafka success!&#34;)   //2.打开日志文件准备收集日志   err = tail.Init(&#34;./my.log&#34;)   if err != nil {      fmt.Println(&#34;init taillog failed, err : &#34;,err)      return   }   fmt.Println(&#34;init tail success!&#34;)   run()}func run() {   //1.收集日志   for  {      select {      case line:=&lt;-tail.ReadLog():         //2.发送给kafka         kafka.SendToKafka(&#34;web_log&#34;,line.Text)      default:         time.Sleep(time.Second)      }   }}
</span></code></pre></div><p>定义消费者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">bin<span class="se">\w</span>indows<span class="se">\k</span>afka-console-consumer.bat --bootstrap-server<span class="o">=</span>127.0.0.1:9092 --topic<span class="o">=</span>web_log --from-beginning
</code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210823210549292.png" >
		<img src="/GoLearning.assets/image-20210823210549292.png"
			
			
			
			loading="lazy"
			alt="image-20210823210549292">
	</a>
	
	<figcaption>image-20210823210549292</figcaption>
	
</figure></p>
<p>优化版配置文件中读取</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;gopkg.in/ini.v1&#34;</span>   <span class="s">&#34;src/code.oldboyedu.com/logAgent/kafka&#34;</span>   <span class="nx">tail</span> <span class="s">&#34;src/code.oldboyedu.com/logAgent/tail_log&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">type</span> <span class="nx">appConf</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">KafkaConf</span> <span class="s">`ini:&#34;Kafka&#34;`</span>   <span class="nx">TailLogConf</span> <span class="s">`ini:&#34;Taillog&#34;`</span><span class="p">}</span><span class="kd">type</span> <span class="nx">KafkaConf</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">Address</span> <span class="kt">string</span> <span class="s">`ini:&#34;Address&#34;`</span>   <span class="nx">Topic</span> <span class="kt">string</span> <span class="s">`ini:&#34;Topic&#34;`</span><span class="p">}</span><span class="kd">type</span> <span class="nx">TailLogConf</span> <span class="kd">struct</span> <span class="p">{</span>   <span class="nx">FileName</span> <span class="kt">string</span> <span class="s">`ini:&#34;Filename&#34;`</span><span class="p">}</span><span class="kd">var</span> <span class="nx">appCfg</span> <span class="p">=</span><span class="nb">new</span><span class="p">(</span><span class="nx">appConf</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//0.加载配置文件 获取ip:端口 日志文件 发送的topic   err := ini.MapTo(appCfg, &#34;./config.ini&#34;)   if err != nil {      fmt.Println(&#34;config init failed, err : &#34;,err)      return   }   //1.初始化kafka连接   fmt.Println(appCfg.KafkaConf.Address)   fmt.Println(appCfg.KafkaConf.Topic)   fmt.Println(appCfg.TailLogConf.FileName)   err = kafka.Init([]string{appCfg.KafkaConf.Address})   if err != nil {      fmt.Println(&#34;init kafka failed, err : &#34; ,err)      return   }   fmt.Println(&#34;init kafka success!&#34;)   //2.打开日志文件准备收集日志   err = tail.Init(appCfg.TailLogConf.FileName)   if err != nil {      fmt.Println(&#34;init taillog failed, err : &#34;,err)      return   }   fmt.Println(&#34;init tail success!&#34;)   run()}func run() {   //1.收集日志   for  {      select {      case line:=&lt;-tail.ReadLog():         //2.发送给kafka         kafka.SendToKafka(appCfg.KafkaConf.Topic,line.Text)      default:         time.Sleep(time.Second)      }   }}
</span></code></pre></div><h5 id="内容复习">内容复习</h5>
<h5 id="go-module-1">go module</h5>
<p>依赖管理工具</p>
<h5 id="context-2">context</h5>
<p>goroutine管理</p>
<p><code>context.Context</code></p>
<p>两个根节点 context.todo context.background</p>
<p>四个方法 context.withTimeout() context.withCancel() context.withdeadline() context.withvalue()</p>
<h5 id="日志收集项目-1">日志收集项目</h5>
<p>ELK:部署的时候麻烦,每一个filebeat都需要配置一个配置文件</p>
<p>使用etcd来管理被收集的日志项</p>
<h5 id="项目的架构">项目的架构</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824195131980.png" >
		<img src="/GoLearning.assets/image-20210824195131980.png"
			
			
			
			loading="lazy"
			alt="image-20210824195131980">
	</a>
	
	<figcaption>image-20210824195131980</figcaption>
	
</figure></p>
<h5 id="上节课项目进度">上节课项目进度</h5>
<ol>
<li>kafka:消息队列</li>
<li>tailf:从文件里读日志</li>
<li>sarama:向kafka发送数据</li>
<li>go-ini:解析配置文件</li>
</ol>
<h5 id="今日内容-7">今日内容</h5>
<h5 id="etcd">etcd</h5>
<h5 id="使用etcd优化日志收集项目">使用etcd优化日志收集项目</h5>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824195924259.png" >
		<img src="/GoLearning.assets/image-20210824195924259.png"
			
			
			
			loading="lazy"
			alt="image-20210824195924259">
	</a>
	
	<figcaption>image-20210824195924259</figcaption>
	
</figure></p>
<p>raft协议</p>
<ul>
<li>选举</li>
<li>日志复制机制</li>
<li>异常处理</li>
</ul>
<p>zookeeper的zad协议和raft协议的区别</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201151410.png" >
		<img src="/GoLearning.assets/image-20210824201151410.png"
			
			
			
			loading="lazy"
			alt="image-20210824201151410">
	</a>
	
	<figcaption>image-20210824201151410</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201255712.png" >
		<img src="/GoLearning.assets/image-20210824201255712.png"
			
			
			
			loading="lazy"
			alt="image-20210824201255712">
	</a>
	
	<figcaption>image-20210824201255712</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201531623.png" >
		<img src="/GoLearning.assets/image-20210824201531623.png"
			
			
			
			loading="lazy"
			alt="image-20210824201531623">
	</a>
	
	<figcaption>image-20210824201531623</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201641847.png" >
		<img src="/GoLearning.assets/image-20210824201641847.png"
			
			
			
			loading="lazy"
			alt="image-20210824201641847">
	</a>
	
	<figcaption>image-20210824201641847</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201859917.png" >
		<img src="/GoLearning.assets/image-20210824201859917.png"
			
			
			
			loading="lazy"
			alt="image-20210824201859917">
	</a>
	
	<figcaption>image-20210824201859917</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824201921279.png" >
		<img src="/GoLearning.assets/image-20210824201921279.png"
			
			
			
			loading="lazy"
			alt="image-20210824201921279">
	</a>
	
	<figcaption>image-20210824201921279</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824202013396.png" >
		<img src="/GoLearning.assets/image-20210824202013396.png"
			
			
			
			loading="lazy"
			alt="image-20210824202013396">
	</a>
	
	<figcaption>image-20210824202013396</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824202041613.png" >
		<img src="/GoLearning.assets/image-20210824202041613.png"
			
			
			
			loading="lazy"
			alt="image-20210824202041613">
	</a>
	
	<figcaption>image-20210824202041613</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824202051395.png" >
		<img src="/GoLearning.assets/image-20210824202051395.png"
			
			
			
			loading="lazy"
			alt="image-20210824202051395">
	</a>
	
	<figcaption>image-20210824202051395</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824202203749.png" >
		<img src="/GoLearning.assets/image-20210824202203749.png"
			
			
			
			loading="lazy"
			alt="image-20210824202203749">
	</a>
	
	<figcaption>image-20210824202203749</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210824202403398.png" >
		<img src="/GoLearning.assets/image-20210824202403398.png"
			
			
			
			loading="lazy"
			alt="image-20210824202403398">
	</a>
	
	<figcaption>image-20210824202403398</figcaption>
	
</figure></p>
<p>清华学神尹成</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210826231049867.png" >
		<img src="/GoLearning.assets/image-20210826231049867.png"
			
			
			
			loading="lazy"
			alt="image-20210826231049867">
	</a>
	
	<figcaption>image-20210826231049867</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210826231828312.png" >
		<img src="/GoLearning.assets/image-20210826231828312.png"
			
			
			
			loading="lazy"
			alt="image-20210826231828312">
	</a>
	
	<figcaption>image-20210826231828312</figcaption>
	
</figure></p>
<h4 id="gin学习">gin学习</h4>
<p>hello world demo</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>   <span class="s">&#34;net/http&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//1.创建路由   engine := gin.Default()   //2.绑定路由规则,执行的函数   //gin.context , 封装了request和response   engine.GET(&#34;/&#34;, func(c *gin.Context) {      c.String(http.StatusOK,&#34;hello world!!!&#34;)   })   //3.监听端口 默认在8080端口   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><h4 id="gin路由">gin路由</h4>
<h5 id="基本路由">基本路由</h5>
<ul>
<li>gin框架中采用的路由库是基于tprouter做的</li>
<li>地址为:https://github.com/julienschmidt/httprouter</li>
</ul>
<h5 id="restful风格的api">restful风格的API</h5>
<ul>
<li>gin支持restful风格的API</li>
<li>即representational state transfer 的缩写 直接翻译是表现层状态转化,是一种互联网应用程序的api设计理念,url定位资源,用http描述操作</li>
</ul>
<p>获取文章 /blog/getxxx   get blog/xxx</p>
<p>添加 /blog/addxxx		post blog/xxx</p>
<p>修改 /blog/updatexxx  put  blog/xxx</p>
<p>删除 /blog/delxxx  		delete blog/xxx</p>
<h5 id="api参数">API参数</h5>
<ul>
<li>可以通过context的param方法来获取api参数</li>
<li>localhost:8000/xxx/zhangsan</li>
</ul>
<p><a class="link" href="http://localhost:8000/user/zhangsan/lisi"  target="_blank" rel="noopener"
    >localhost:8000/user/zhangsan/lisi</a></p>
<h5 id="url参数">URL参数</h5>
<ul>
<li>URL参数可以通过defaultquery()或者query()方法来取</li>
<li>defaultquery()若参数不存在,返回默认值 query()若参数不存在,返回空字符串</li>
</ul>
<p><a class="link" href="http://localhost:8000/welcome?name=yourtreedad"  target="_blank" rel="noopener"
    >localhost:8000/welcome?name=yourtreedad</a></p>
<h5 id="表单参数">表单参数</h5>
<ul>
<li>表单传输为post请求,http常见的传输格式化为四种
<ul>
<li>application/json  json传参</li>
<li>application/x-www-urlencoded  表单传参</li>
<li>application/xml  xml传参</li>
<li>multipart/form-data  表单上传文件</li>
</ul>
</li>
<li>表单参数可以通过postform()方法获取,该方法默认解析的是x-www-form-urlencoded 或 from-data格式的参数</li>
</ul>
<h5 id="上传单个文件">上传单个文件</h5>
<ul>
<li>multipart/form-data格式用于文件上传</li>
<li>gin 文件上传与原生的net/http 方法类似,不同在于gin把原生的request封装到了c.Request中</li>
</ul>
<h5 id="上传多个文件">上传多个文件</h5>
<p>MultipartForm使用这个方法获得所有文件的</p>
<p>使用multipartForm.File[&ldquo;files&rdquo;]来取所有文件指针</p>
<p>遍历, 然后存着就行了</p>
<h5 id="routes-group">routes Group</h5>
<ul>
<li>routes Group  是为了管理一些相同的URL</li>
</ul>
<h5 id="路由原理">路由原理</h5>
<ul>
<li>httprouter 会将所有路由规则构造成一个前缀树</li>
</ul>
<p>命令行也可以尝试传post和get指令</p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210828214026568.png" >
		<img src="/GoLearning.assets/image-20210828214026568.png"
			
			
			
			loading="lazy"
			alt="image-20210828214026568">
	</a>
	
	<figcaption>image-20210828214026568</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>   <span class="s">&#34;log&#34;</span>   <span class="s">&#34;net/http&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="c1">//1.创建路由   //默认使用了2个中间件 Logger(), Recovery()   engine := gin.Default()   //engine:=gin.New()也可以的   //2.绑定路由规则,执行的函数   //gin.context , 封装了request和response   //路由组 实际上就是便于管理 少写点东西   routerGroup := engine.Group(&#34;/Get&#34;)   routerGroup.GET(&#34;/v1&#34;, func(context *gin.Context) {      query := context.DefaultQuery(&#34;name&#34;, &#34;getParam&#34;)      context.String(http.StatusOK,query)   })   group := engine.Group(&#34;/Post&#34;)   group.POST(&#34;/v1&#34;, func(context *gin.Context) {      postParam := context.DefaultPostForm(&#34;name&#34;, &#34;postParam&#34;)      context.String(http.StatusOK,postParam)   })   //index 界面   engine.GET(&#34;/&#34;, func(c *gin.Context) {      c.String(http.StatusOK,&#34;hello world!!!&#34;)   })   //api参数 用 : 来取   engine.GET(&#34;/user/:name/*action&#34;, func(context *gin.Context) {      //      name:= context.Param(&#34;name&#34;)      action := context.Param(&#34;action&#34;)      context.String(http.StatusOK,name+&#34; is &#34;+action)   })   //url参数 ?name=&#34;xxx&#34;   engine.GET(&#34;/welcome&#34;, func(context *gin.Context) {      query := context.DefaultQuery(&#34;name&#34;, &#34;Jack&#34;)      context.String(http.StatusOK,fmt.Sprintf(&#34;Hello %s !&#34;,query))   })   //form表单传参   engine.POST(&#34;/PostForm&#34;, PostFormParams)   //from上传单个文件   engine.POST(&#34;/Upload&#34;,UploadFile)   //限制表单上传大小 8mb,默认值为32mb   engine.MaxMultipartMemory = 8&lt;&lt;20   //form上传多个文件   engine.POST(&#34;UploadFiles&#34;,UploadFiles)   engine.PUT(&#34;/xxxput&#34;)   //3.监听端口 默认在8080端口   engine.Run(&#34;:8000&#34;)}func UploadFiles(context *gin.Context) {   multipartForm, err := context.MultipartForm()   if err != nil {      fmt.Println(&#34;received multiple files failed , err :&#34;,err)       context.String(http.StatusBadRequest,fmt.Sprintf(&#34;get err %s &#34;,err.Error()))      return   }   //获取所有文件   files := multipartForm.File[&#34;files&#34;]   //遍历所有files   for _, file := range files {      //逐个存      err := context.SaveUploadedFile(file, file.Filename)      if err != nil {         context.String(http.StatusBadRequest,fmt.Sprintf(&#34;upload err %s &#34;,err.Error()))         return      }   }   context.String(200,fmt.Sprintf(&#34;upload ok %d files!&#34;, len(files)))}func UploadFile(context *gin.Context) {   //从表单中取文件   file, err := context.FormFile(&#34;file&#34;)   if err != nil {      fmt.Println(&#34;receive file error, cause : &#34;,err)      return   }   log.Println(file.Filename)   //传到项目的根目录, 名字就用本身的就好   err = context.SaveUploadedFile(file, file.Filename)   if err != nil {      fmt.Println(&#34;file save failed , error : &#34;,err)      return   }   //打印信息   context.String(200,fmt.Sprintf(&#34;&#39;%s&#39; has already uploaded!&#34;,file.Filename))}func PostFormParams(context *gin.Context) {   //表单参数 设置默认值   type1 := context.DefaultPostForm(&#34;type&#34;, &#34;alert&#34;)   //接收其他的   userName := context.PostForm(&#34;username&#34;)   password := context.PostForm(&#34;password&#34;)   //多选框   hobbys := context.PostFormArray(&#34;hobby&#34;)   context.String(http.StatusOK,fmt.Sprintf(&#34;type is %s, username is %s, password is %s , hobbys is %v&#34;,type1,userName,password,hobbys))}
</span></code></pre></div><p>html前端界面</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;&lt;</span><span class="nt">head</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>登陆<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;&lt;/</span><span class="nt">head</span><span class="p">&gt;&lt;</span><span class="nt">body</span><span class="p">&gt;&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://127.0.0.1:8000/PostForm&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;post&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">&gt;</span>    用户名:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;username&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    密<span class="err">&amp;</span>nbsp<span class="err">&amp;</span>nbsp码: <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;password&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;password&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    兴<span class="err">&amp;</span>nbsp<span class="err">&amp;</span>nbsp趣:    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;checkbox&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;run&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;hobby&#34;</span><span class="p">&gt;</span>跑步    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;checkbox&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;game&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;hobby&#34;</span><span class="p">&gt;</span>游戏    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;checkbox&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;money&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;hobby&#34;</span><span class="p">&gt;</span>金钱    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;登陆&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;&lt;</span><span class="nt">br</span><span class="p">&gt;&lt;</span><span class="nt">br</span><span class="p">&gt;&lt;</span><span class="nt">br</span><span class="p">&gt;&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://127.0.0.1:8000/Upload&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;post&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;multipart/form-data&#34;</span><span class="p">&gt;</span>    头像:    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;file&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;file&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;提交&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://127.0.0.1:8000/UploadFiles&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;post&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;multipart/form-data&#34;</span><span class="p">&gt;</span>    上传多个文件:    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;file&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;files&#34;</span> <span class="na">multiple</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;提交&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><h4 id="gin数据解析和绑定">gin数据解析和绑定</h4>
<h5 id="json数据解析和绑定">json数据解析和绑定</h5>
<ul>
<li>客户端传参,后端接收并解析到结构体</li>
</ul>
<p>使用ShouldBindJSON来解析到结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;loginJSON&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//声明接收的变量   var json Login   //将request的body中的数据,自动按照json格式解析到结构体   err := context.ShouldBindJSON(&amp;json)   if err != nil {      //返回错误信息      //gin.H 封装了生成json数据的工具      context.JSON(http.StatusBadRequest,gin.H{&#34;error &#34;:err.Error()})      return   }   //判断用户名密码是否正确   if json.User!=&#34;2020170281&#34;||json.Password!=&#34;lalala123&#34; {      context.JSON(http.StatusBadRequest,gin.H{&#34;status&#34;:&#34;304&#34;})      return   }   context.JSON(http.StatusOK,gin.H{&#34;status&#34;:&#34;200&#34;})})
</span></code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210828224803650.png" >
		<img src="/GoLearning.assets/image-20210828224803650.png"
			
			
			
			loading="lazy"
			alt="image-20210828224803650">
	</a>
	
	<figcaption>image-20210828224803650</figcaption>
	
</figure></p>
<h5 id="表单数据解析和绑定">表单数据解析和绑定</h5>
<p>使用Bind来解析结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;loginForm&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>   <span class="kd">var</span> <span class="nx">form</span> <span class="nx">Login</span>   <span class="c1">//bind()默认解析并绑定form格式   //根据请求头中的content-type自动推断   err := context.Bind(&amp;form)   if err != nil {      context.JSON(http.StatusBadRequest,gin.H{&#34;error&#34;:err.Error()})      return   }   if form.User!=&#34;2020170281&#34;||form.Password!=&#34;lalala123&#34;{      context.JSON(http.StatusBadRequest,gin.H{&#34;status&#34;:&#34;304&#34;})      return   }   context.JSON(http.StatusOK,gin.H{&#34;status&#34;:&#34;200&#34;})})
</span></code></pre></div><p>html界面</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;&lt;</span><span class="nt">head</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>登陆<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;&lt;/</span><span class="nt">head</span><span class="p">&gt;&lt;</span><span class="nt">body</span><span class="p">&gt;&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://127.0.0.1:8000/loginForm&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;get&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;application/x-www-form-urlencoded&#34;</span><span class="p">&gt;</span>    用户名:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;username&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    密<span class="err">&amp;</span>nbsp<span class="err">&amp;</span>nbsp码: <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;password&#34;</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;password&#34;</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;登陆&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;&lt;</span><span class="nt">br</span><span class="p">&gt;&lt;</span><span class="nt">br</span><span class="p">&gt;&lt;/</span><span class="nt">body</span><span class="p">&gt;&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><h5 id="uri数据解析和绑定">URI数据解析和绑定</h5>
<p>使用shouldbinduri方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;loginURI/:user/:password&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>   <span class="kd">var</span> <span class="nx">URI</span> <span class="nx">Login</span>   <span class="nx">err</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">ShouldBindUri</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">URI</span><span class="p">)</span>   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>      <span class="nx">context</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span><span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span><span class="s">&#34;error&#34;</span><span class="p">:</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()})</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="k">if</span> <span class="nx">URI</span><span class="p">.</span><span class="nx">User</span><span class="o">!=</span><span class="s">&#34;2020170281&#34;</span><span class="o">||</span><span class="nx">URI</span><span class="p">.</span><span class="nx">Password</span><span class="o">!=</span><span class="s">&#34;lalala123&#34;</span> <span class="p">{</span>      <span class="nx">context</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span><span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span><span class="s">&#34;status&#34;</span><span class="p">:</span><span class="mi">304</span><span class="p">})</span>      <span class="k">return</span>   <span class="p">}</span>   <span class="nx">context</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span><span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span><span class="s">&#34;status&#34;</span><span class="p">:</span><span class="mi">200</span><span class="p">})})</span>
</code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210828231200951.png" >
		<img src="/GoLearning.assets/image-20210828231200951.png"
			
			
			
			loading="lazy"
			alt="image-20210828231200951">
	</a>
	
	<figcaption>image-20210828231200951</figcaption>
	
</figure></p>
<h5 id="响应类型">响应类型</h5>
<ul>
<li>xml</li>
<li>json</li>
<li>protobuf</li>
<li>yaml</li>
</ul>
<pre><code class="language-go'" data-lang="go'">package mainimport (   &quot;github.com/gin-gonic/gin&quot;   &quot;github.com/gin-gonic/gin/testdata/protoexample&quot;   &quot;net/http&quot;)//多种响应方式func main() {   //1.创建路由   //2.默认使用了2个中间件logger recovery   engine := gin.Default()   //1.json   engine.GET(&quot;/someJson&quot;, func(context *gin.Context) {      context.JSON(http.StatusOK,gin.H{&quot;message&quot;:&quot;someJson&quot;,&quot;Status&quot;:200})   })   //2.结构体响应   engine.GET(&quot;someStruct&quot;, func(context *gin.Context) {      context.JSON(http.StatusOK, struct {         Name , Message string         Number int      }{&quot;root&quot;,&quot;message&quot;,123})   })   //3.XML响应   engine.GET(&quot;/someXML&quot;, func(context *gin.Context) {      context.XML(http.StatusOK,gin.H{&quot;message&quot;:&quot;xml&quot;})   })   //4.yaml响应   engine.GET(&quot;/someYaml&quot;, func(context *gin.Context) {      context.YAML(http.StatusOK,gin.H{&quot;name&quot;:&quot;YAML&quot;})   })   //5.protobuf格式 副歌开发的高校存储读取的工具   engine.GET(&quot;/someProtoBuf&quot;, func(context *gin.Context) {       reps:=[]int64{1,2}       //定义返回数据       label:=&quot;protobuf&quot;       data:=&amp;protoexample.Test{          Label: &amp;label,          Reps: reps,       }       context.ProtoBuf(http.StatusOK,data)   })   engine.Run(&quot;:8000&quot;)}
</code></pre><h5 id="html-模版渲染">HTML 模版渲染</h5>
<ul>
<li>gin支持加载html模版,然后根据模版参数进行配置并返回相应的数据,本质上就是字符串的替换</li>
<li>loadhtmlglob()方法可以加载模版文件</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">engine</span><span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>   <span class="c1">//加载模版文件   engine.LoadHTMLGlob(&#34;templates/*&#34;)   //以下这种方式也可以啦   //engine.LoadHTMLFiles(&#34;templates/index.tmpl&#34;)   engine.GET(&#34;/index&#34;, func(context *gin.Context) {      //根据文件名渲染      //最终json将title替换      context.HTML(http.StatusOK,&#34;index.tmpl&#34;,gin.H{&#34;title&#34;:&#34;我的标题&#34;})   })   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><p><figure 
	>
	<a href="/GoLearning.assets/image-20210828234359001.png" >
		<img src="/GoLearning.assets/image-20210828234359001.png"
			
			
			
			loading="lazy"
			alt="image-20210828234359001">
	</a>
	
	<figcaption>image-20210828234359001</figcaption>
	
</figure></p>
<h5 id="重定向">重定向</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">engine</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>   <span class="nx">engine</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/redirect&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">//支持内部和外部的重定向      context.Redirect(http.StatusMovedPermanently,&#34;http://www.baidu.com&#34;)   })   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><h5 id="同步异步">同步异步</h5>
<ul>
<li>goroutine机制可以方便地实现异步处理</li>
<li>另外,在启动新的goroutine时,<strong>不应该使用原始上下文,必须使用他的只读副本</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">unc</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">engine</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>   <span class="c1">//1.异步   engine.GET(&#34;/long_async&#34;, func(context *gin.Context) {      //需要搞一个只读的副本      copyContext := context.Copy()      //模仿异步处理      go func() {         time.Sleep(3 *time.Second)         log.Println(&#34;异步执行...&#34;+copyContext.Request.URL.Path)      }()   })   //2.同步   engine.GET(&#34;/long_sync&#34;, func(context *gin.Context) {      time.Sleep(3*time.Second)      log.Println(&#34;同步执行...&#34;+context.Request.URL.Path)   })   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><h4 id="gin中间件">gin中间件</h4>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210828235642323.png" >
		<img src="/GoLearning.assets/image-20210828235642323.png"
			
			
			
			loading="lazy"
			alt="image-20210828235642323">
	</a>
	
	<figcaption>image-20210828235642323</figcaption>
	
</figure></p>
<ul>
<li>gin可以构建中间件,但它只对注册过的路由函数起作用</li>
<li>对于分组路由,嵌套使用中间件,可以限定中间件的作用范围</li>
<li>中间件分为全局中间件,单个路由中间件和群组中间件</li>
<li>gin中间件必须是一个gin.handlerfunc类型</li>
</ul>
<h5 id="全局中间件">全局中间件</h5>
<ul>
<li>所有请求都经过此中间件</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>   <span class="s">&#34;net/http&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="c1">//定义全局中间件func MiddleWare() gin.HandlerFunc {   return func(context *gin.Context) {      t:=time.Now()      fmt.Println(&#34;中间件开始执行了...&#34;)      //设置变量到context的key中,可以通过get取      context.Set(&#34;request&#34;,&#34;中间件&#34;)      //执行函数      context.Next()      //中间件执行完后续的一些事情      status := context.Writer.Status()      fmt.Println(&#34;中间件执行完毕&#34;,status)      fmt.Println(&#34;用时 : &#34;,time.Now().Sub(t))   }}func main() {   engine:= gin.Default()   //注册中间件   engine.Use(MiddleWare())   {      engine.GET(&#34;/middleware&#34;, func(context *gin.Context) {         //取值         request, _ := context.Get(&#34;request&#34;)         fmt.Println(request)         //页面接收         context.JSON(http.StatusOK,gin.H{&#34;request&#34;:request})      })   }   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><h5 id="next方法">next()方法</h5>
<p>看原码 实际上就是遍历了注册的所有中间件的个数,</p>
<h5 id="局部中间件">局部中间件</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//如此就是在这个路由之下定义了新的中间件,可以视为单个中间件engine.GET(&#34;/middlewareDouble&#34;,MiddleWare(), func(context *gin.Context) {   //取值   request, _ := context.Get(&#34;request&#34;)   fmt.Println(request)   //页面接收   context.JSON(http.StatusOK,gin.H{&#34;request&#34;:request})})
</span></code></pre></div><h5 id="练习-1">练习</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;fmt&#34;</span>   <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>   <span class="s">&#34;time&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">middleTimer</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>   <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">now</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>      <span class="nx">context</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;用时: &#34;</span><span class="p">,</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>   <span class="p">}}</span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>   <span class="nx">engine</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>   <span class="nx">engine</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nf">middleTimer</span><span class="p">())</span>   <span class="nx">group</span> <span class="o">:=</span> <span class="nx">engine</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/timer&#34;</span><span class="p">)</span>   <span class="nx">group</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/countTimer&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>   <span class="p">})</span>   <span class="nx">group</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/counTimer1&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>   <span class="p">})</span>   <span class="nx">engine</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8000&#34;</span><span class="p">)}</span>
</code></pre></div><h4 id="会话控制">会话控制</h4>
<h5 id="cookie是什么">cookie是什么</h5>
<ul>
<li>http是无状态协议,服务器不能记录里浏览器的访问状态,也就是说服务器不能区分两次请求是否是由同一个客户端发出的</li>
<li>cookie就是解决http协议无状态的方案之一,中文是小甜饼的意思</li>
<li>cookie实际上就是服务器保存在浏览器上的一段信息,浏览器有了cookie之后,每次向服务器发送请求时都会同时将该信息发送给服务器,服务器收到请求后,就可以根据该信息处理请求</li>
<li>cookie由服务器创建,并发送给浏览器,最终由浏览器保存</li>
</ul>
<h5 id="cookie用途">cookie用途</h5>
<ul>
<li>保持登陆状态</li>
<li>京东购物车</li>
</ul>
<h5 id="cookie的使用">cookie的使用</h5>
<ul>
<li>服务端发送cookieid</li>
</ul>
<h5 id="cookie练习">cookie练习</h5>
<ul>
<li>模拟实现权限验证中间件
<ul>
<li>有两个路由,login用来设置cookie</li>
<li>home用来访问</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nf">mainimport</span> <span class="p">(</span>   <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>   <span class="s">&#34;net/http&#34;</span><span class="p">)</span><span class="kd">func</span> <span class="nf">MiddleWareAuth</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>   <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>      <span class="nx">cookie</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="s">&#34;loginToken&#34;</span><span class="p">)</span>      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>         <span class="c1">//返回错误         context.JSON(http.StatusOK, gin.H{&#34;error&#34;: &#34;StatusUnauthorized&#34;})         context.Abort()         return      }      if cookie == &#34;true&#34; {         context.Next()      }   }}func main() {   engine := gin.Default()   engine.GET(&#34;/login&#34;, func(context *gin.Context) {      http.SetCookie(context.Writer, &amp;http.Cookie{         Name:  &#34;loginToken&#34;,         Value: &#34;true&#34;,      })      context.String(http.StatusOK, &#34;Login successful&#34;)   })   engine.GET(&#34;/home&#34;, MiddleWareAuth(), func(context *gin.Context) {      context.JSON(http.StatusOK, gin.H{&#34;data&#34;: &#34;home&#34;})   })   engine.Run(&#34;:8000&#34;)}
</span></code></pre></div><h5 id="cookie的缺点">cookie的缺点</h5>
<ul>
<li>不安全 明文</li>
<li>增加带宽消耗</li>
<li>可以被禁用</li>
<li>cookie有上限</li>
</ul>
<h5 id="session是什么">session是什么</h5>
<ul>
<li>session可以弥补cookie的不足,session必须依赖于cookie才能使用,生成一个sessionid放在cookie里传给客户端就可以了</li>
</ul>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210829104620811.png" >
		<img src="/GoLearning.assets/image-20210829104620811.png"
			
			
			
			loading="lazy"
			alt="image-20210829104620811">
	</a>
	
	<figcaption>image-20210829104620811</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210829104914310.png" >
		<img src="/GoLearning.assets/image-20210829104914310.png"
			
			
			
			loading="lazy"
			alt="image-20210829104914310">
	</a>
	
	<figcaption>image-20210829104914310</figcaption>
	
</figure></p>
<p>session存在服务端中</p>
<h5 id="session中间件开发">session中间件开发</h5>
<ul>
<li>
<p>设计一个通用的session服务,支持内存存储和redis存储</p>
</li>
<li>
<p>session模块设计</p>
<ul>
<li>本质上是k-v系统,通过key来进行增删改查</li>
<li>session可以存储在内存或者redis(2个版本)</li>
</ul>
</li>
</ul>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210829105225472.png" >
		<img src="/GoLearning.assets/image-20210829105225472.png"
			
			
			
			loading="lazy"
			alt="image-20210829105225472">
	</a>
	
	<figcaption>image-20210829105225472</figcaption>
	
</figure></p>
<ul>
<li>session接口设计
<ul>
<li>set</li>
<li>get</li>
<li>del</li>
<li>save   session存储,redis的实现延迟加载</li>
</ul>
</li>
<li>sessionmgr接口设计
<ul>
<li>init 初始化 加载redis地址</li>
<li>createsession 创建一个新的session</li>
<li>getsession 通过sessionid获取对应的session对象</li>
</ul>
</li>
<li>memorysession设计
<ul>
<li>定义memorysession对象 字段sessionid  存kv的map 读写锁</li>
<li>构造函数 为了获取对象</li>
</ul>
</li>
<li>sessionmgr设计
<ul>
<li>定义memorysessionmgr对象 字段存放所有的session的map,读写锁</li>
<li>构造函数</li>
<li>init</li>
<li>cretesession</li>
<li>getsession</li>
</ul>
</li>
<li>redisression设计
<ul>
<li>定义redissession对象 ssionid字段 存kv的map 读写锁 redis连接池 记录内存中map否被修改的标记</li>
<li>构造函数</li>
<li>set将session存到内存中的map</li>
<li>get取数据实现延迟加载</li>
<li>del</li>
<li>save 将session存到redis</li>
</ul>
</li>
<li>redissessionmgr设计
<ul>
<li>定义redissessionmgr对象</li>
</ul>
</li>
</ul>
<p><figure 
	>
	<a href="/GoLearning.assets/image-20210829110208079.png" >
		<img src="/GoLearning.assets/image-20210829110208079.png"
			
			
			
			loading="lazy"
			alt="image-20210829110208079">
	</a>
	
	<figcaption>image-20210829110208079</figcaption>
	
</figure></p>
<p>这里还是要重申一下 http传参啊</p>
<p>首先 传参可以分为网址传参和表单传参</p>
<p>网址传参又分为api传参和url传参</p>
<p>api传参使用/book/:name</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">name</span><span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
</code></pre></div><p>url传参使用/book</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">query</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
</code></pre></div><p>表单传参</p>
<p>分为get和post  get的话我们发现 get的method最终会变成url</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">query</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;searchThing&#34;</span><span class="p">)</span>
</code></pre></div><p>post就使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">searchThing</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">GetPostForm</span><span class="p">(</span><span class="s">&#34;searchThing&#34;</span><span class="p">)</span><span class="nx">form</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;searchThing&#34;</span><span class="p">)</span>
</code></pre></div>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>

     
     
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 think hy how to learn
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#go语言学习">Go语言学习</a></li>
        <li><a href="#字符串">字符串</a></li>
        <li><a href="#内容回顾">内容回顾</a>
          <ol>
            <li><a href="#go-命令">go 命令</a></li>
          </ol>
        </li>
        <li><a href="#基本数据类型">基本数据类型</a>
          <ol>
            <li></li>
            <li><a href="#指针">指针</a></li>
            <li><a href="#map">map</a></li>
            <li><a href="#内容回顾-1">内容回顾</a></li>
          </ol>
        </li>
        <li><a href="#变量-1">变量</a>
          <ol>
            <li></li>
            <li><a href="#函数类型和变量">函数类型和变量</a></li>
          </ol>
        </li>
        <li><a href="#今日内容">今日内容</a>
          <ol>
            <li><a href="#函数">函数</a></li>
            <li><a href="#go语言fmtprintf使用指南">go语言fmt.printf使用指南</a></li>
            <li><a href="#结构体-struct">结构体 struct</a></li>
            <li><a href="#内容回顾-2">内容回顾</a></li>
            <li><a href="#结构体">结构体</a></li>
            <li><a href="#day05内容回顾">day05内容回顾</a></li>
            <li><a href="#内容回顾-3">内容回顾</a></li>
            <li><a href="#今日内容-1">今日内容</a></li>
            <li><a href="#今日内容-2">今日内容</a></li>
            <li><a href="#goroutine与线程">goroutine与线程</a></li>
            <li><a href="#day08">day08</a></li>
            <li><a href="#sync包">sync包</a></li>
            <li><a href="#网络编程">网络编程</a></li>
            <li><a href="#socket编程">socket编程</a></li>
            <li><a href="#go语言实现tcp通信">go语言实现TCP通信</a></li>
            <li><a href="#day09">day09</a></li>
            <li><a href="#今日分享">今日分享</a></li>
            <li><a href="#今日内容-4">今日内容</a></li>
            <li><a href="#内容回顾-5">内容回顾</a></li>
            <li><a href="#http客户端和服务端">HTTP客户端和服务端</a></li>
            <li><a href="#今日内容-5">今日内容</a></li>
            <li><a href="#gin学习">gin学习</a></li>
            <li><a href="#gin路由">gin路由</a></li>
            <li><a href="#gin数据解析和绑定">gin数据解析和绑定</a></li>
            <li><a href="#gin中间件">gin中间件</a></li>
            <li><a href="#会话控制">会话控制</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
